import { StandardSchemaV1 } from "@standard-schema/spec";

//#region src/cache.d.ts
type Options$2 = {
  key: string;
};
type CacheFn = <TInput, TOutput>(input: TInput, compute: (input: TInput) => Promise<TOutput> | TOutput, options?: Options$2) => Promise<TOutput>;
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/standard-schema.d.cts
/** The Standard Schema interface. */
interface StandardSchemaV1$1<Input = unknown, Output = Input> {
  /** The Standard Schema properties. */
  readonly "~standard": StandardSchemaV1$1.Props<Input, Output>;
}
declare namespace StandardSchemaV1$1 {
  /** The Standard Schema properties interface. */
  interface Props<Input = unknown, Output = Input> {
    /** The version number of the standard. */
    readonly version: 1;
    /** The vendor name of the schema library. */
    readonly vendor: string;
    /** Validates unknown input values. */
    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
    /** Inferred types associated with the schema. */
    readonly types?: Types<Input, Output> | undefined;
  }
  /** The result interface of the validate function. */
  type Result<Output> = SuccessResult<Output> | FailureResult;
  /** The result interface if validation succeeds. */
  interface SuccessResult<Output> {
    /** The typed output value. */
    readonly value: Output;
    /** The non-existent issues. */
    readonly issues?: undefined;
  }
  /** The result interface if validation fails. */
  interface FailureResult {
    /** The issues of failed validation. */
    readonly issues: ReadonlyArray<Issue>;
  }
  /** The issue interface of the failure output. */
  interface Issue {
    /** The error message of the issue. */
    readonly message: string;
    /** The path of the issue, if any. */
    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
  }
  /** The path segment interface of the issue. */
  interface PathSegment {
    /** The key representing a path segment. */
    readonly key: PropertyKey;
  }
  /** The Standard Schema types interface. */
  interface Types<Input = unknown, Output = Input> {
    /** The input type of the schema. */
    readonly input: Input;
    /** The output type of the schema. */
    readonly output: Output;
  }
  /** Infers the input type of a Standard Schema. */
  type InferInput<Schema$1 extends StandardSchemaV1$1> = NonNullable<Schema$1["~standard"]["types"]>["input"];
  /** Infers the output type of a Standard Schema. */
  type InferOutput<Schema$1 extends StandardSchemaV1$1> = NonNullable<Schema$1["~standard"]["types"]>["output"];
}
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/util.d.cts
type IsAny<T$1> = 0 extends 1 & T$1 ? true : false;
type Omit$1<T$1, K$1 extends keyof T$1> = Pick<T$1, Exclude<keyof T$1, K$1>>;
type MakePartial<T$1, K$1 extends keyof T$1> = Omit$1<T$1, K$1> & InexactPartial<Pick<T$1, K$1>>;
type LoosePartial<T$1 extends object> = InexactPartial<T$1> & {
  [k: string]: unknown;
};
type InexactPartial<T$1> = { [P in keyof T$1]?: T$1[P] | undefined };
type Identity<T$1> = T$1;
type Flatten<T$1> = Identity<{ [k in keyof T$1]: T$1[k] }>;
type Prettify$1<T$1> = { [K in keyof T$1]: T$1[K] } & {};
type AnyFunc = (...args: any[]) => any;
type MaybeAsync<T$1> = T$1 | Promise<T$1>;
type Literal$1 = string | number | bigint | boolean | null | undefined;
type Primitive = string | number | symbol | bigint | boolean | null | undefined;
type SafeParseResult<T$1> = SafeParseSuccess<T$1> | SafeParseError<T$1>;
type SafeParseSuccess<T$1> = {
  success: true;
  data: T$1;
  error?: never;
};
type SafeParseError<T$1> = {
  success: false;
  data?: never;
  error: $ZodError<T$1>;
};
type PropValues = Record<string, Set<Primitive>>;
type PrimitiveSet = Set<Primitive>;
declare abstract class Class {
  constructor(..._args: any[]);
}
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/versions.d.cts
declare const version: {
  readonly major: 4;
  readonly minor: 1;
  readonly patch: number;
};
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/schemas.d.cts
interface ParseContext<T$1 extends $ZodIssueBase = never> {
  /** Customize error messages. */
  readonly error?: $ZodErrorMap<T$1>;
  /** Include the `input` field in issue objects. Default `false`. */
  readonly reportInput?: boolean;
  /** Skip eval-based fast path. Default `false`. */
  readonly jitless?: boolean;
}
/** @internal */
interface ParseContextInternal<T$1 extends $ZodIssueBase = never> extends ParseContext<T$1> {
  readonly async?: boolean | undefined;
  readonly direction?: "forward" | "backward";
  readonly skipChecks?: boolean;
}
interface ParsePayload<T$1 = unknown> {
  value: T$1;
  issues: $ZodRawIssue[];
  /** A may to mark a whole payload as aborted. Used in codecs/pipes. */
  aborted?: boolean;
}
type CheckFn<T$1> = (input: ParsePayload<T$1>) => MaybeAsync<void>;
interface $ZodTypeDef {
  type: "string" | "number" | "int" | "boolean" | "bigint" | "symbol" | "null" | "undefined" | "void" | "never" | "any" | "unknown" | "date" | "object" | "record" | "file" | "array" | "tuple" | "union" | "intersection" | "map" | "set" | "enum" | "literal" | "nullable" | "optional" | "nonoptional" | "success" | "transform" | "default" | "prefault" | "catch" | "nan" | "pipe" | "readonly" | "template_literal" | "promise" | "lazy" | "function" | "custom";
  error?: $ZodErrorMap<never> | undefined;
  checks?: $ZodCheck<never>[];
}
interface _$ZodTypeInternals {
  /** The `@zod/core` version of this schema */
  version: typeof version;
  /** Schema definition. */
  def: $ZodTypeDef;
  /** @internal Randomly generated ID for this schema. */
  /** @internal List of deferred initializers. */
  deferred: AnyFunc[] | undefined;
  /** @internal Parses input and runs all checks (refinements). */
  run(payload: ParsePayload<any>, ctx: ParseContextInternal): MaybeAsync<ParsePayload>;
  /** @internal Parses input, doesn't run checks. */
  parse(payload: ParsePayload<any>, ctx: ParseContextInternal): MaybeAsync<ParsePayload>;
  /** @internal  Stores identifiers for the set of traits implemented by this schema. */
  traits: Set<string>;
  /** @internal Indicates that a schema output type should be considered optional inside objects.
   * @default Required
   */
  /** @internal */
  optin?: "optional" | undefined;
  /** @internal */
  optout?: "optional" | undefined;
  /** @internal The set of literal values that will pass validation. Must be an exhaustive set. Used to determine optionality in z.record().
   *
   * Defined on: enum, const, literal, null, undefined
   * Passthrough: optional, nullable, branded, default, catch, pipe
   * Todo: unions?
   */
  values?: PrimitiveSet | undefined;
  /** Default value bubbled up from  */
  /** @internal A set of literal discriminators used for the fast path in discriminated unions. */
  propValues?: PropValues | undefined;
  /** @internal This flag indicates that a schema validation can be represented with a regular expression. Used to determine allowable schemas in z.templateLiteral(). */
  pattern: RegExp | undefined;
  /** @internal The constructor function of this schema. */
  constr: new (def: any) => $ZodType;
  /** @internal A catchall object for bag metadata related to this schema. Commonly modified by checks using `onattach`. */
  bag: Record<string, unknown>;
  /** @internal The set of issues this schema might throw during type checking. */
  isst: $ZodIssueBase;
  /** An optional method used to override `toJSONSchema` logic. */
  toJSONSchema?: () => unknown;
  /** @internal The parent of this schema. Only set during certain clone operations. */
  parent?: $ZodType | undefined;
}
/** @internal */
interface $ZodTypeInternals<out O = unknown, out I = unknown> extends _$ZodTypeInternals {
  /** @internal The inferred output type */
  output: O;
  /** @internal The inferred input type */
  input: I;
}
type $ZodStandardSchema<T$1> = StandardSchemaV1$1.Props<input<T$1>, output<T$1>>;
type SomeType$1 = {
  _zod: _$ZodTypeInternals;
};
interface $ZodType<O = unknown, I = unknown, Internals extends $ZodTypeInternals<O, I> = $ZodTypeInternals<O, I>> {
  _zod: Internals;
  "~standard": $ZodStandardSchema<this>;
}
interface _$ZodType<T$1 extends $ZodTypeInternals = $ZodTypeInternals> extends $ZodType<T$1["output"], T$1["input"], T$1> {}
declare const $ZodType: $constructor<$ZodType>;
interface $ZodStringDef extends $ZodTypeDef {
  type: "string";
  coerce?: boolean;
  checks?: $ZodCheck<string>[];
}
interface $ZodStringInternals<Input> extends $ZodTypeInternals<string, Input> {
  def: $ZodStringDef;
  /** @deprecated Internal API, use with caution (not deprecated) */
  pattern: RegExp;
  /** @deprecated Internal API, use with caution (not deprecated) */
  isst: $ZodIssueInvalidType;
  bag: LoosePartial<{
    minimum: number;
    maximum: number;
    patterns: Set<RegExp>;
    format: string;
    contentEncoding: string;
  }>;
}
interface $ZodString<Input = unknown> extends _$ZodType<$ZodStringInternals<Input>> {}
declare const $ZodString: $constructor<$ZodString>;
interface $ZodNumberDef extends $ZodTypeDef {
  type: "number";
  coerce?: boolean;
}
interface $ZodNumberInternals<Input = unknown> extends $ZodTypeInternals<number, Input> {
  def: $ZodNumberDef;
  /** @deprecated Internal API, use with caution (not deprecated) */
  pattern: RegExp;
  /** @deprecated Internal API, use with caution (not deprecated) */
  isst: $ZodIssueInvalidType;
  bag: LoosePartial<{
    minimum: number;
    maximum: number;
    exclusiveMinimum: number;
    exclusiveMaximum: number;
    format: string;
    pattern: RegExp;
  }>;
}
interface $ZodNumber<Input = unknown> extends $ZodType {
  _zod: $ZodNumberInternals<Input>;
}
declare const $ZodNumber: $constructor<$ZodNumber>;
interface $ZodBooleanDef extends $ZodTypeDef {
  type: "boolean";
  coerce?: boolean;
  checks?: $ZodCheck<boolean>[];
}
interface $ZodBooleanInternals<T$1 = unknown> extends $ZodTypeInternals<boolean, T$1> {
  pattern: RegExp;
  def: $ZodBooleanDef;
  isst: $ZodIssueInvalidType;
}
interface $ZodBigIntDef extends $ZodTypeDef {
  type: "bigint";
  coerce?: boolean;
}
interface $ZodBigIntInternals<T$1 = unknown> extends $ZodTypeInternals<bigint, T$1> {
  pattern: RegExp;
  /** @internal Internal API, use with caution */
  def: $ZodBigIntDef;
  isst: $ZodIssueInvalidType;
  bag: LoosePartial<{
    minimum: bigint;
    maximum: bigint;
    format: string;
  }>;
}
interface $ZodBigInt<T$1 = unknown> extends $ZodType {
  _zod: $ZodBigIntInternals<T$1>;
}
declare const $ZodBigInt: $constructor<$ZodBigInt>;
interface $ZodUndefinedDef extends $ZodTypeDef {
  type: "undefined";
}
interface $ZodUndefinedInternals extends $ZodTypeInternals<undefined, undefined> {
  pattern: RegExp;
  def: $ZodUndefinedDef;
  values: PrimitiveSet;
  isst: $ZodIssueInvalidType;
}
interface $ZodNullDef extends $ZodTypeDef {
  type: "null";
}
interface $ZodNullInternals extends $ZodTypeInternals<null, null> {
  pattern: RegExp;
  def: $ZodNullDef;
  values: PrimitiveSet;
  isst: $ZodIssueInvalidType;
}
interface $ZodUnknownDef extends $ZodTypeDef {
  type: "unknown";
}
interface $ZodUnknownInternals extends $ZodTypeInternals<unknown, unknown> {
  def: $ZodUnknownDef;
  isst: never;
}
interface $ZodDateDef extends $ZodTypeDef {
  type: "date";
  coerce?: boolean;
}
interface $ZodDateInternals<T$1 = unknown> extends $ZodTypeInternals<Date, T$1> {
  def: $ZodDateDef;
  isst: $ZodIssueInvalidType;
  bag: LoosePartial<{
    minimum: Date;
    maximum: Date;
    format: string;
  }>;
}
type OptionalOutSchema = {
  _zod: {
    optout: "optional";
  };
};
type OptionalInSchema = {
  _zod: {
    optin: "optional";
  };
};
type $InferObjectOutput<T$1 extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T$1 ? IsAny<T$1[keyof T$1]> extends true ? Record<string, unknown> : Record<string, output<T$1[keyof T$1]>> : keyof (T$1 & Extra) extends never ? Record<string, never> : Prettify$1<{ -readonly [k in keyof T$1 as T$1[k] extends OptionalOutSchema ? never : k]: T$1[k]["_zod"]["output"] } & { -readonly [k in keyof T$1 as T$1[k] extends OptionalOutSchema ? k : never]?: T$1[k]["_zod"]["output"] } & Extra>;
type $InferObjectInput<T$1 extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T$1 ? IsAny<T$1[keyof T$1]> extends true ? Record<string, unknown> : Record<string, input<T$1[keyof T$1]>> : keyof (T$1 & Extra) extends never ? Record<string, never> : Prettify$1<{ -readonly [k in keyof T$1 as T$1[k] extends OptionalInSchema ? never : k]: T$1[k]["_zod"]["input"] } & { -readonly [k in keyof T$1 as T$1[k] extends OptionalInSchema ? k : never]?: T$1[k]["_zod"]["input"] } & Extra>;
type $ZodObjectConfig = {
  out: Record<string, unknown>;
  in: Record<string, unknown>;
};
type $strip = {
  out: {};
  in: {};
};
type $ZodShape = Readonly<{
  [k: string]: $ZodType;
}>;
interface $ZodObjectDef<Shape extends $ZodShape = $ZodShape> extends $ZodTypeDef {
  type: "object";
  shape: Shape;
  catchall?: $ZodType | undefined;
}
interface $ZodObjectInternals< /** @ts-ignore Cast variance */
out Shape extends $ZodShape = $ZodShape, out Config extends $ZodObjectConfig = $ZodObjectConfig> extends _$ZodTypeInternals {
  def: $ZodObjectDef<Shape>;
  config: Config;
  isst: $ZodIssueInvalidType | $ZodIssueUnrecognizedKeys;
  propValues: PropValues;
  output: $InferObjectOutput<Shape, Config["out"]>;
  input: $InferObjectInput<Shape, Config["in"]>;
  optin?: "optional" | undefined;
  optout?: "optional" | undefined;
}
type $ZodLooseShape = Record<string, any>;
interface $ZodObject< /** @ts-ignore Cast variance */
out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>, out Params extends $ZodObjectConfig = $ZodObjectConfig> extends $ZodType<any, any, $ZodObjectInternals<Shape, Params>> {
  "~standard": $ZodStandardSchema<this>;
}
declare const $ZodObject: $constructor<$ZodObject>;
type $InferUnionOutput<T$1 extends SomeType$1> = T$1 extends any ? output<T$1> : never;
type $InferUnionInput<T$1 extends SomeType$1> = T$1 extends any ? input<T$1> : never;
interface $ZodUnionDef<Options$3 extends readonly SomeType$1[] = readonly $ZodType[]> extends $ZodTypeDef {
  type: "union";
  options: Options$3;
}
type IsOptionalIn<T$1 extends SomeType$1> = T$1 extends OptionalInSchema ? true : false;
type IsOptionalOut<T$1 extends SomeType$1> = T$1 extends OptionalOutSchema ? true : false;
interface $ZodUnionInternals<T$1 extends readonly SomeType$1[] = readonly $ZodType[]> extends _$ZodTypeInternals {
  def: $ZodUnionDef<T$1>;
  isst: $ZodIssueInvalidUnion;
  pattern: T$1[number]["_zod"]["pattern"];
  values: T$1[number]["_zod"]["values"];
  output: $InferUnionOutput<T$1[number]>;
  input: $InferUnionInput<T$1[number]>;
  optin: IsOptionalIn<T$1[number]> extends false ? "optional" | undefined : "optional";
  optout: IsOptionalOut<T$1[number]> extends false ? "optional" | undefined : "optional";
}
type $ZodRecordKey = $ZodType<string | number | symbol, string | number | symbol>;
interface $ZodRecordDef<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType$1 = $ZodType> extends $ZodTypeDef {
  type: "record";
  keyType: Key;
  valueType: Value;
}
type $InferZodRecordOutput<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType$1 = $ZodType> = Key extends $partial ? Partial<Record<output<Key>, output<Value>>> : Record<output<Key>, output<Value>>;
type $InferZodRecordInput<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType$1 = $ZodType> = Key extends $partial ? Partial<Record<input<Key>, input<Value>>> : Record<input<Key>, input<Value>>;
interface $ZodRecordInternals<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType$1 = $ZodType> extends $ZodTypeInternals<$InferZodRecordOutput<Key, Value>, $InferZodRecordInput<Key, Value>> {
  def: $ZodRecordDef<Key, Value>;
  isst: $ZodIssueInvalidType | $ZodIssueInvalidKey<Record<PropertyKey, unknown>>;
  optin?: "optional" | undefined;
  optout?: "optional" | undefined;
}
type $partial = {
  "~~partial": true;
};
interface $ZodMapDef<Key extends SomeType$1 = $ZodType, Value extends SomeType$1 = $ZodType> extends $ZodTypeDef {
  type: "map";
  keyType: Key;
  valueType: Value;
}
interface $ZodMapInternals<Key extends SomeType$1 = $ZodType, Value extends SomeType$1 = $ZodType> extends $ZodTypeInternals<Map<output<Key>, output<Value>>, Map<input<Key>, input<Value>>> {
  def: $ZodMapDef<Key, Value>;
  isst: $ZodIssueInvalidType | $ZodIssueInvalidKey | $ZodIssueInvalidElement<unknown>;
  optin?: "optional" | undefined;
  optout?: "optional" | undefined;
}
interface $ZodSetDef<T$1 extends SomeType$1 = $ZodType> extends $ZodTypeDef {
  type: "set";
  valueType: T$1;
}
interface $ZodSetInternals<T$1 extends SomeType$1 = $ZodType> extends $ZodTypeInternals<Set<output<T$1>>, Set<input<T$1>>> {
  def: $ZodSetDef<T$1>;
  isst: $ZodIssueInvalidType;
  optin?: "optional" | undefined;
  optout?: "optional" | undefined;
}
interface $ZodLiteralDef<T$1 extends Literal$1> extends $ZodTypeDef {
  type: "literal";
  values: T$1[];
}
interface $ZodLiteralInternals<T$1 extends Literal$1 = Literal$1> extends $ZodTypeInternals<T$1, T$1> {
  def: $ZodLiteralDef<T$1>;
  values: Set<T$1>;
  pattern: RegExp;
  isst: $ZodIssueInvalidValue;
}
interface $ZodOptionalDef<T$1 extends SomeType$1 = $ZodType> extends $ZodTypeDef {
  type: "optional";
  innerType: T$1;
}
interface $ZodOptionalInternals<T$1 extends SomeType$1 = $ZodType> extends $ZodTypeInternals<output<T$1> | undefined, input<T$1> | undefined> {
  def: $ZodOptionalDef<T$1>;
  optin: "optional";
  optout: "optional";
  isst: never;
  values: T$1["_zod"]["values"];
  pattern: T$1["_zod"]["pattern"];
}
interface $ZodOptional<T$1 extends SomeType$1 = $ZodType> extends $ZodType {
  _zod: $ZodOptionalInternals<T$1>;
}
declare const $ZodOptional: $constructor<$ZodOptional>;
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/checks.d.cts
interface $ZodCheckDef {
  check: string;
  error?: $ZodErrorMap<never> | undefined;
  /** If true, no later checks will be executed if this check fails. Default `false`. */
  abort?: boolean | undefined;
  /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */
  when?: ((payload: ParsePayload) => boolean) | undefined;
}
interface $ZodCheckInternals<T$1> {
  def: $ZodCheckDef;
  /** The set of issues this check might throw. */
  issc?: $ZodIssueBase;
  check(payload: ParsePayload<T$1>): MaybeAsync<void>;
  onattach: ((schema: $ZodType) => void)[];
}
interface $ZodCheck<in T$1 = never> {
  _zod: $ZodCheckInternals<T$1>;
}
declare const $ZodCheck: $constructor<$ZodCheck<any>>;
type $ZodStringFormats = "email" | "url" | "emoji" | "uuid" | "guid" | "nanoid" | "cuid" | "cuid2" | "ulid" | "xid" | "ksuid" | "datetime" | "date" | "time" | "duration" | "ipv4" | "ipv6" | "cidrv4" | "cidrv6" | "base64" | "base64url" | "json_string" | "e164" | "lowercase" | "uppercase" | "regex" | "jwt" | "starts_with" | "ends_with" | "includes";
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/errors.d.cts
interface $ZodIssueBase {
  readonly code?: string;
  readonly input?: unknown;
  readonly path: PropertyKey[];
  readonly message: string;
}
interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {
  readonly code: "invalid_type";
  readonly expected: $ZodType["_zod"]["def"]["type"];
  readonly input?: Input;
}
interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {
  readonly code: "too_big";
  readonly origin: "number" | "int" | "bigint" | "date" | "string" | "array" | "set" | "file" | (string & {});
  readonly maximum: number | bigint;
  readonly inclusive?: boolean;
  readonly exact?: boolean;
  readonly input?: Input;
}
interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {
  readonly code: "too_small";
  readonly origin: "number" | "int" | "bigint" | "date" | "string" | "array" | "set" | "file" | (string & {});
  readonly minimum: number | bigint;
  /** True if the allowable range includes the minimum */
  readonly inclusive?: boolean;
  /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */
  readonly exact?: boolean;
  readonly input?: Input;
}
interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {
  readonly code: "invalid_format";
  readonly format: $ZodStringFormats | (string & {});
  readonly pattern?: string;
  readonly input?: string;
}
interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {
  readonly code: "not_multiple_of";
  readonly divisor: number;
  readonly input?: Input;
}
interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {
  readonly code: "unrecognized_keys";
  readonly keys: string[];
  readonly input?: Record<string, unknown>;
}
interface $ZodIssueInvalidUnion extends $ZodIssueBase {
  readonly code: "invalid_union";
  readonly errors: $ZodIssue[][];
  readonly input?: unknown;
  readonly discriminator?: string | undefined;
}
interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {
  readonly code: "invalid_key";
  readonly origin: "map" | "record";
  readonly issues: $ZodIssue[];
  readonly input?: Input;
}
interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {
  readonly code: "invalid_element";
  readonly origin: "map" | "set";
  readonly key: unknown;
  readonly issues: $ZodIssue[];
  readonly input?: Input;
}
interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {
  readonly code: "invalid_value";
  readonly values: Primitive[];
  readonly input?: Input;
}
interface $ZodIssueCustom extends $ZodIssueBase {
  readonly code: "custom";
  readonly params?: Record<string, any> | undefined;
  readonly input?: unknown;
}
type $ZodIssue = $ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;
type $ZodInternalIssue<T$1 extends $ZodIssueBase = $ZodIssue> = T$1 extends any ? RawIssue<T$1> : never;
type RawIssue<T$1 extends $ZodIssueBase> = T$1 extends any ? Flatten<MakePartial<T$1, "message" | "path"> & {
  /** The input data */
  readonly input: unknown;
  /** The schema or check that originated this issue. */
  readonly inst?: $ZodType | $ZodCheck;
  /** If `true`, Zod will continue executing checks/refinements after this issue. */
  readonly continue?: boolean | undefined;
} & Record<string, unknown>> : never;
type $ZodRawIssue<T$1 extends $ZodIssueBase = $ZodIssue> = $ZodInternalIssue<T$1>;
interface $ZodErrorMap<T$1 extends $ZodIssueBase = $ZodIssue> {
  (issue: $ZodRawIssue<T$1>): {
    message: string;
  } | string | undefined | null;
}
interface $ZodError<T$1 = unknown> extends Error {
  type: T$1;
  issues: $ZodIssue[];
  _zod: {
    output: T$1;
    def: $ZodIssue[];
  };
  stack?: string;
  name: string;
}
declare const $ZodError: $constructor<$ZodError>;
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/core.d.cts
type ZodTrait = {
  _zod: {
    def: any;
    [k: string]: any;
  };
};
interface $constructor<T$1 extends ZodTrait, D = T$1["_zod"]["def"]> {
  new (def: D): T$1;
  init(inst: T$1, def: D): asserts inst is T$1;
}
declare function $constructor<T$1 extends ZodTrait, D = T$1["_zod"]["def"]>(name: string, initializer: (inst: T$1, def: D) => void, params?: {
  Parent?: typeof Class;
}): $constructor<T$1, D>;
declare const $brand: unique symbol;
type $brand<T$1 extends string | number | symbol = string | number | symbol> = {
  [$brand]: { [k in T$1]: true };
};
type input<T$1> = T$1 extends {
  _zod: {
    input: any;
  };
} ? T$1["_zod"]["input"] : unknown;
type output<T$1> = T$1 extends {
  _zod: {
    output: any;
  };
} ? T$1["_zod"]["output"] : unknown;
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/registries.d.cts
declare const $output: unique symbol;
type $output = typeof $output;
declare const $input: unique symbol;
type $input = typeof $input;
type $replace<Meta$1, S extends $ZodType> = Meta$1 extends $output ? output<S> : Meta$1 extends $input ? input<S> : Meta$1 extends (infer M)[] ? $replace<M, S>[] : Meta$1 extends ((...args: infer P) => infer R) ? (...args: { [K in keyof P]: $replace<P[K], S> }) => $replace<R, S> : Meta$1 extends object ? { [K in keyof Meta$1]: $replace<Meta$1[K], S> } : Meta$1;
type MetadataType = object | undefined;
declare class $ZodRegistry<Meta$1 extends MetadataType = MetadataType, Schema$1 extends $ZodType = $ZodType> {
  _meta: Meta$1;
  _schema: Schema$1;
  _map: WeakMap<Schema$1, $replace<Meta$1, Schema$1>>;
  _idmap: Map<string, Schema$1>;
  add<S extends Schema$1>(schema: S, ..._meta: undefined extends Meta$1 ? [$replace<Meta$1, S>?] : [$replace<Meta$1, S>]): this;
  clear(): this;
  remove(schema: Schema$1): this;
  get<S extends Schema$1>(schema: S): $replace<Meta$1, S> | undefined;
  has(schema: Schema$1): boolean;
}
//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/mini/schemas.d.cts
type SomeType = SomeType$1;
interface ZodMiniType<out Output = unknown, out Input = unknown, out Internals extends $ZodTypeInternals<Output, Input> = $ZodTypeInternals<Output, Input>> extends $ZodType<Output, Input, Internals> {
  type: Internals["def"]["type"];
  check(...checks: (CheckFn<output<this>> | $ZodCheck<output<this>>)[]): this;
  clone(def?: Internals["def"], params?: {
    parent: boolean;
  }): this;
  register<R$1 extends $ZodRegistry>(registry: R$1, ...meta: this extends R$1["_schema"] ? undefined extends R$1["_meta"] ? [$replace<R$1["_meta"], this>?] : [$replace<R$1["_meta"], this>] : ["Incompatible schema"]): this;
  brand<T$1 extends PropertyKey = PropertyKey>(value?: T$1): PropertyKey extends T$1 ? this : this & Record<"_zod", Record<"output", output<this> & $brand<T$1>>>;
  def: Internals["def"];
  parse(data: unknown, params?: ParseContext<$ZodIssue>): output<this>;
  safeParse(data: unknown, params?: ParseContext<$ZodIssue>): SafeParseResult<output<this>>;
  parseAsync(data: unknown, params?: ParseContext<$ZodIssue>): Promise<output<this>>;
  safeParseAsync(data: unknown, params?: ParseContext<$ZodIssue>): Promise<SafeParseResult<output<this>>>;
}
interface _ZodMiniType<out Internals extends $ZodTypeInternals = $ZodTypeInternals> extends ZodMiniType<any, any, Internals> {}
declare const ZodMiniType: $constructor<ZodMiniType>;
interface _ZodMiniString<T$1 extends $ZodStringInternals<unknown> = $ZodStringInternals<unknown>> extends _ZodMiniType<T$1>, $ZodString<T$1["input"]> {
  _zod: T$1;
}
interface ZodMiniString<Input = unknown> extends _ZodMiniString<$ZodStringInternals<Input>>, $ZodString<Input> {}
declare const ZodMiniString: $constructor<ZodMiniString>;
interface _ZodMiniNumber<T$1 extends $ZodNumberInternals<unknown> = $ZodNumberInternals<unknown>> extends _ZodMiniType<T$1>, $ZodNumber<T$1["input"]> {
  _zod: T$1;
}
interface ZodMiniNumber<Input = unknown> extends _ZodMiniNumber<$ZodNumberInternals<Input>>, $ZodNumber<Input> {}
declare const ZodMiniNumber: $constructor<ZodMiniNumber>;
interface ZodMiniBoolean<T$1 = unknown> extends _ZodMiniType<$ZodBooleanInternals<T$1>> {}
declare const ZodMiniBoolean: $constructor<ZodMiniBoolean>;
interface ZodMiniBigInt<T$1 = unknown> extends _ZodMiniType<$ZodBigIntInternals<T$1>>, $ZodBigInt<T$1> {}
declare const ZodMiniBigInt: $constructor<ZodMiniBigInt>;
interface ZodMiniUndefined extends _ZodMiniType<$ZodUndefinedInternals> {}
declare const ZodMiniUndefined: $constructor<ZodMiniUndefined>;
interface ZodMiniNull extends _ZodMiniType<$ZodNullInternals> {}
declare const ZodMiniNull: $constructor<ZodMiniNull>;
interface ZodMiniUnknown extends _ZodMiniType<$ZodUnknownInternals> {}
declare const ZodMiniUnknown: $constructor<ZodMiniUnknown>;
interface ZodMiniDate<T$1 = unknown> extends _ZodMiniType<$ZodDateInternals<T$1>> {}
declare const ZodMiniDate: $constructor<ZodMiniDate>;
interface ZodMiniObject< /** @ts-ignore Cast variance */
out Shape extends $ZodShape = $ZodShape, out Config extends $ZodObjectConfig = $strip> extends ZodMiniType<any, any, $ZodObjectInternals<Shape, Config>>, $ZodObject<Shape, Config> {
  shape: Shape;
}
declare const ZodMiniObject: $constructor<ZodMiniObject>;
interface ZodMiniUnion<T$1 extends readonly SomeType[] = readonly $ZodType[]> extends _ZodMiniType<$ZodUnionInternals<T$1>> {}
declare const ZodMiniUnion: $constructor<ZodMiniUnion>;
interface ZodMiniRecord<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> extends _ZodMiniType<$ZodRecordInternals<Key, Value>> {}
declare const ZodMiniRecord: $constructor<ZodMiniRecord>;
interface ZodMiniMap<Key extends SomeType = $ZodType, Value extends SomeType = $ZodType> extends _ZodMiniType<$ZodMapInternals<Key, Value>> {}
declare const ZodMiniMap: $constructor<ZodMiniMap>;
interface ZodMiniSet<T$1 extends SomeType = $ZodType> extends _ZodMiniType<$ZodSetInternals<T$1>> {}
declare const ZodMiniSet: $constructor<ZodMiniSet>;
interface ZodMiniLiteral<T$1 extends Literal$1 = Literal$1> extends _ZodMiniType<$ZodLiteralInternals<T$1>> {}
declare const ZodMiniLiteral: $constructor<ZodMiniLiteral>;
interface ZodMiniOptional<T$1 extends SomeType = $ZodType> extends _ZodMiniType<$ZodOptionalInternals<T$1>>, $ZodOptional<T$1> {}
declare const ZodMiniOptional: $constructor<ZodMiniOptional>;
//#endregion
//#region src/import.d.ts
declare const importSchema: ZodMiniObject<{
  __cc_import: ZodMiniLiteral<true>;
  path: ZodMiniString<string>;
  name: ZodMiniOptional<ZodMiniString<string>>;
}, $strip>;
type Import<T$1> = output<typeof importSchema> & {
  __type?: T$1;
};
type GetTypeOfImport<T$1> = T$1 extends Import<infer U> ? U : never;
declare function createDefaultImport<T$1>(path: string): Import<T$1>;
declare function createNamedImport<T$1>(name: string, path: string): Import<T$1>;
//#endregion
//#region src/parser.d.ts
type ParseFn = (content: string) => Record<string, unknown> | Promise<Record<string, unknown>>;
type Parser = {
  hasContent: boolean;
  parse: ParseFn;
};
type PredefinedParsers = typeof parsers;
type PredefinedParser = keyof typeof parsers;
type ConfiguredParser = PredefinedParser | Parser;
declare function parseYaml(content: string): any;
declare function frontmatterParser(fileContent: string): {
  content: string;
};
declare function frontmatterOnlyParser(fileContent: string): {
  [key: string]: any;
};
declare const parsers: {
  frontmatter: {
    hasContent: true;
    parse: typeof frontmatterParser;
  };
  "frontmatter-only": {
    hasContent: false;
    parse: typeof frontmatterOnlyParser;
  };
  json: {
    hasContent: false;
    parse: (text: string, reviver?: (this: any, key: string, value: any) => any) => any;
  };
  yaml: {
    hasContent: false;
    parse: typeof parseYaml;
  };
};
type DefineParserResult<TArgument extends Parser | ParseFn> = TArgument extends Function ? {
  hasContent: false;
  parse: ParseFn;
} : TArgument extends infer Parser ? Parser : never;
declare function defineParser<TArgument extends Parser | ParseFn>(parser: TArgument): DefineParserResult<TArgument>;
//#endregion
//#region src/serializer.d.ts
declare const literalSchema: ZodMiniUnion<readonly [ZodMiniString<string>, ZodMiniNumber<number>, ZodMiniBoolean<boolean>, ZodMiniNull, ZodMiniUndefined, ZodMiniDate<Date>, ZodMiniMap<ZodMiniUnknown, ZodMiniUnknown>, ZodMiniSet<ZodMiniUnknown>, ZodMiniBigInt<bigint>, ZodMiniObject<{
  __cc_import: ZodMiniLiteral<true>;
  path: ZodMiniString<string>;
  name: ZodMiniOptional<ZodMiniString<string>>;
}, $strip>]>;
type Literal = output<typeof literalSchema>;
type SchemaType = Literal | {
  [key: string]: SchemaType;
} | ReadonlyArray<SchemaType>;
type NotSerializableError = `The return type of the transform function must be an object serializable object.
See https://www.content-collections.dev/docs/serialization for more information.

The following type is not valid:`;
declare const serializableSchema: ZodMiniRecord<ZodMiniString<string>, ZodMiniType<SchemaType, unknown, $ZodTypeInternals<SchemaType, unknown>>>;
type Serializable = output<typeof serializableSchema>;
//#endregion
//#region src/config.d.ts
type Meta = {
  filePath: string;
  fileName: string;
  directory: string;
  path: string;
  extension: string;
};
type WithContent = {
  content: string;
};
type AddContent<TOutput> = TOutput extends {
  content: any;
} ? TOutput : TOutput & WithContent;
type GetParser<TParser extends ConfiguredParser> = TParser extends PredefinedParser ? PredefinedParsers[TParser] : TParser;
type HasContent<TParser extends ConfiguredParser> = GetParser<TParser>["hasContent"];
type TSchemaProp = StandardSchemaV1;
type GetOutputShape<TShape extends TSchemaProp> = TShape extends StandardSchemaV1 ? StandardSchemaV1.InferOutput<TShape> : never;
type GetOutput<TParser extends ConfiguredParser, TShape extends TSchemaProp, TOutput = GetOutputShape<TShape>> = HasContent<TParser> extends true ? AddContent<TOutput> : TOutput;
type Schema<TParser extends ConfiguredParser, TShape extends TSchemaProp> = GetOutput<TParser, TShape> & {
  _meta: Meta;
};
type Prettify<T$1> = { [K in keyof T$1]: T$1[K] } & {};
type GetSchema<TCollection$1 extends AnyCollection> = TCollection$1 extends Collection<any, any, any, infer TSchema, any, any> ? Prettify<TSchema> : never;
declare const skippedSymbol: unique symbol;
type SkippedSignal = {
  [skippedSymbol]: true;
  reason?: string;
};
type Context<TSchema$1 = unknown> = {
  documents<TCollection$1 extends AnyCollection>(collection: TCollection$1): Array<GetSchema<TCollection$1>>;
  cache: CacheFn;
  collection: {
    name: string;
    directory: string;
    documents: () => Promise<Array<TSchema$1>>;
  };
  skip: (reason?: string) => SkippedSignal;
};
type CollectionRequest<TName extends string, TShape extends TSchemaProp, TParser, TSchema$1, TTransformResult, TDocument$1> = {
  name: TName;
  parser?: TParser;
  typeName?: string;
  schema: TShape;
  transform?: (data: TSchema$1, context: Context<TSchema$1>) => TTransformResult;
  directory: string;
  include: string | string[];
  exclude?: string | string[];
  onSuccess?: (documents: Array<TDocument$1>) => void | Promise<void>;
};
type Collection<TName extends string, TShape extends TSchemaProp, TParser extends ConfiguredParser, TSchema$1, TTransformResult, TDocument$1> = Omit<CollectionRequest<TName, TShape, TParser, TSchema$1, TTransformResult, TDocument$1>, "schema"> & {
  typeName: string;
  schema: StandardSchemaV1;
  parser: TParser;
};
type AnyCollection = Collection<any, TSchemaProp, ConfiguredParser, any, any, any>;
declare const InvalidReturnTypeSymbol: unique symbol;
type InvalidReturnType<TMessage extends string, TObject> = {
  [InvalidReturnTypeSymbol]: TMessage;
  object: TObject;
};
type ResolveImports<TTransformResult> = TTransformResult extends Import<any> ? GetTypeOfImport<TTransformResult> : TTransformResult extends Array<infer U> ? Array<ResolveImports<U>> : TTransformResult extends ((...args: any[]) => any) ? TTransformResult : TTransformResult extends object ? { [K in keyof TTransformResult]: ResolveImports<TTransformResult[K]> } : TTransformResult;
declare function defineCollection<TName extends string, TShape extends TSchemaProp, TParser extends ConfiguredParser = "frontmatter", TSchema$1 = Schema<TParser, TShape>, TTransformResult = never, TDocument$1 = ([TTransformResult] extends [never] ? Schema<TParser, TShape> : Exclude<Awaited<TTransformResult>, SkippedSignal>), TResult = (TDocument$1 extends Serializable ? Collection<TName, TShape, TParser, TSchema$1, TTransformResult, ResolveImports<TDocument$1>> : InvalidReturnType<NotSerializableError, TDocument$1>)>(collection: CollectionRequest<TName, TShape, TParser, TSchema$1, TTransformResult, TDocument$1>): TResult;
type Cache = "memory" | "file" | "none";
type Configuration<TCollections extends Array<AnyCollection>> = {
  collections: TCollections;
  cache?: Cache;
};
type AnyConfiguration = Configuration<Array<AnyCollection>>;
declare function defineConfig<TConfig extends AnyConfiguration>(config: TConfig): TConfig;
//#endregion
//#region src/types.d.ts
type Modification = "create" | "update" | "delete";
type Document = {
  _meta: Meta;
};
type CollectionFile = {
  data: {
    content?: string;
    [key: string]: unknown;
  };
  path: string;
};
type CollectionByName<TConfiguration extends AnyConfiguration> = { [TCollection in TConfiguration["collections"][number] as TCollection["name"]]: TCollection };
type GetDocument<TCollection$1 extends AnyCollection> = TCollection$1 extends Collection<any, any, any, any, any, infer TDocument> ? TDocument : never;
type GetTypeByName<TConfiguration extends AnyConfiguration, TName extends keyof CollectionByName<TConfiguration>, TCollection$1 = CollectionByName<TConfiguration>[TName]> = TCollection$1 extends AnyCollection ? GetDocument<TCollection$1> : never;
//#endregion
//#region src/collector.d.ts
type CollectorEvents = {
  "collector:read-error": {
    filePath: string;
    error: CollectError;
  };
  "collector:parse-error": {
    filePath: string;
    error: CollectError;
  };
};
type ErrorType$2 = "Parse" | "Read";
declare class CollectError extends Error {
  type: ErrorType$2;
  constructor(type: ErrorType$2, message: string);
}
//#endregion
//#region src/transformer.d.ts
type TransformerEvents = {
  "transformer:validation-error": {
    collection: AnyCollection;
    file: CollectionFile;
    error: TransformError;
  };
  "transformer:result-error": {
    collection: AnyCollection;
    document: any;
    error: TransformError;
  };
  "transformer:error": {
    collection: AnyCollection;
    error: TransformError;
  };
  "transformer:document-skipped": {
    collection: AnyCollection;
    filePath: string;
    reason?: string;
  };
};
type ErrorType$1 = "Validation" | "Configuration" | "Transform" | "Result";
declare class TransformError extends Error {
  type: ErrorType$1;
  constructor(type: ErrorType$1, message: string);
}
//#endregion
//#region src/watcher.d.ts
type WatcherEvents = {
  "watcher:subscribe-error": {
    paths: Array<string>;
    error: Error;
  };
  "watcher:subscribed": {
    paths: Array<string>;
  };
  "watcher:unsubscribed": {
    paths: Array<string>;
  };
};
type SyncFn = (modification: Modification, path: string) => Promise<unknown>;
type WatchableCollection = {
  directory: string;
};
type WatcherConfiguration = {
  inputPaths: Array<string>;
  collections: Array<WatchableCollection>;
};
declare function createWatcher(emitter: Emitter, baseDirectory: string, configuration: WatcherConfiguration, sync: SyncFn): Promise<{
  unsubscribe: () => Promise<void>;
}>;
type Watcher = Awaited<ReturnType<typeof createWatcher>>;
//#endregion
//#region src/events.d.ts
type EventMap = Record<string, object>;
type EventWithError = {
  error: Error;
};
type SystemEvent = {
  _event: string;
};
type ErrorEvent = EventWithError & SystemEvent;
type Events = BuilderEvents & CollectorEvents & TransformerEvents & WatcherEvents;
type SystemEvents = {
  _error: ErrorEvent;
  _all: SystemEvent;
};
type Keys<TEvents extends EventMap> = keyof TEvents & string;
type Listener<TEvent> = (event: TEvent) => void;
declare function createEmitter<TEvents extends EventMap>(): {
  on: {
    <TKey extends Keys<TEvents>>(key: TKey, listener: Listener<TEvents[TKey]>): void;
    <TKey extends Keys<SystemEvents>>(key: TKey, listener: Listener<SystemEvents[TKey]>): void;
  };
  emit: <TKey extends Keys<TEvents>>(key: TKey, event: TEvents[TKey]) => void;
};
type Emitter = ReturnType<typeof createEmitter<Events>>;
//#endregion
//#region src/configurationReader.d.ts
type ErrorType = "Read" | "Compile";
declare class ConfigurationError extends Error {
  type: ErrorType;
  constructor(type: ErrorType, message: string);
}
type InternalConfiguration = {
  collections: Array<AnyCollection>;
  path: string;
  inputPaths: Array<string>;
  checksum: string;
  generateTypes?: boolean;
};
type Options = {
  configName: string;
  cacheDir?: string;
};
//#endregion
//#region src/build.d.ts
type BuildEvents = {
  "builder:start": {
    startedAt: number;
  };
  "builder:end": {
    startedAt: number;
    endedAt: number;
    stats: {
      collections: number;
      documents: number;
    };
  };
};
//#endregion
//#region src/builder.d.ts
type BuilderEvents = BuildEvents & {
  "builder:created": {
    createdAt: number;
    configurationPath: string;
    outputDirectory: string;
  };
  "watcher:file-changed": {
    filePath: string;
    modification: Modification;
  };
  "watcher:config-changed": {
    filePath: string;
    modification: Modification;
  };
  "watcher:config-reload-error": {
    error: Error;
    configurationPath: string;
  };
};
type Options$1 = Options & {
  outputDir?: string;
};
declare class ConfigurationReloadError extends Error {
  constructor(message: string);
}
declare function createBuilder(configurationPath: string, options?: Options$1, emitter?: Emitter): Promise<{
  build: () => Promise<void>;
  sync: (modification: Modification, filePath: string) => Promise<boolean>;
  watch: () => Promise<{
    unsubscribe: () => Promise<void>;
  }>;
  on: {
    <TKey extends "builder:start" | "builder:end" | "builder:created" | "watcher:file-changed" | "watcher:config-changed" | "watcher:config-reload-error" | "collector:read-error" | "collector:parse-error" | "transformer:validation-error" | "transformer:result-error" | "transformer:error" | "transformer:document-skipped" | "watcher:subscribe-error" | "watcher:subscribed" | "watcher:unsubscribed">(key: TKey, listener: (event: Events[TKey]) => void): void;
    <TKey extends "_error" | "_all">(key: TKey, listener: (event: SystemEvents[TKey]) => void): void;
  };
}>;
declare function createInternalBuilder(initialConfiguration: InternalConfiguration, baseDirectory: string, options: Options$1, emitter: Emitter): Promise<{
  build: () => Promise<void>;
  sync: (modification: Modification, filePath: string) => Promise<boolean>;
  watch: () => Promise<{
    unsubscribe: () => Promise<void>;
  }>;
  on: {
    <TKey extends "builder:start" | "builder:end" | "builder:created" | "watcher:file-changed" | "watcher:config-changed" | "watcher:config-reload-error" | "collector:read-error" | "collector:parse-error" | "transformer:validation-error" | "transformer:result-error" | "transformer:error" | "transformer:document-skipped" | "watcher:subscribe-error" | "watcher:subscribed" | "watcher:unsubscribed">(key: TKey, listener: (event: Events[TKey]) => void): void;
    <TKey extends "_error" | "_all">(key: TKey, listener: (event: SystemEvents[TKey]) => void): void;
  };
}>;
type Builder = Awaited<ReturnType<typeof createBuilder>>;
//#endregion
//#region src/features.d.ts
declare const deprecations: {
  implicitContentProperty: string;
};
type Deprecation = keyof typeof deprecations;
declare function suppressDeprecatedWarnings(...suppresses: Array<Deprecation | "all">): void;
//#endregion
export { AnyCollection, AnyConfiguration, Builder, BuilderEvents, CollectError, Collection, CollectionRequest, Configuration, ConfigurationError, ConfigurationReloadError, Context, type Document, type GetTypeByName, Meta, type Modification, Schema, SkippedSignal, TransformError, type Watcher, createBuilder, createDefaultImport, createInternalBuilder, createNamedImport, defineCollection, defineConfig, defineParser, skippedSymbol, suppressDeprecatedWarnings };