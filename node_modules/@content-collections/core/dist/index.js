import path, { basename, dirname, extname, join, resolve } from "node:path";
import { createHash } from "node:crypto";
import { existsSync } from "node:fs";
import fs, { mkdir, readFile, unlink, writeFile } from "node:fs/promises";
import { readFile as readFile$1 } from "fs/promises";
import { glob } from "tinyglobby";
import matter from "gray-matter";
import { parse, stringify } from "yaml";
import camelcase from "camelcase";
import pluralize from "pluralize";
import picomatch from "picomatch";
import os from "node:os";
import pLimit from "p-limit";
import fs2 from "fs";
import path2 from "path";
import { build } from "esbuild";
import { createRequire } from "module";
import serializeJs from "serialize-javascript";
import { EventEmitter } from "node:events";
import chokidar from "chokidar";

//#region src/cache.ts
function createKey(config$1, input, key) {
	return createHash("sha256").update(config$1).update(JSON.stringify(input)).update(key).digest("hex");
}
async function createCacheDirectory(directory) {
	const cacheDirectory = path.join(directory, ".content-collections", "cache");
	if (!existsSync(cacheDirectory)) await mkdir(cacheDirectory, { recursive: true });
	return cacheDirectory;
}
function fileName(input) {
	return input.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
async function readMapping(mappingPath) {
	if (existsSync(mappingPath)) try {
		return JSON.parse(await readFile(mappingPath, "utf-8"));
	} catch (e) {
		console.error("Failed to parse the cache mapping. We will recreate the cache.");
	}
	return {};
}
async function createCacheManager(baseDirectory, configChecksum) {
	const cacheDirectory = await createCacheDirectory(baseDirectory);
	const mappingPath = join(cacheDirectory, "mapping.json");
	const mapping = await readMapping(mappingPath);
	async function flush() {
		await writeFile(mappingPath, JSON.stringify(mapping));
	}
	function cache(collection, file) {
		const directory = join(cacheDirectory, fileName(collection), fileName(file));
		let collectionMapping = mapping[collection];
		if (!collectionMapping) {
			collectionMapping = {};
			mapping[collection] = collectionMapping;
		}
		let fileMapping = collectionMapping[file];
		if (!fileMapping) {
			fileMapping = [];
			collectionMapping[file] = fileMapping;
		}
		let newFileMapping = [];
		const cacheFn = async (input, fn, options) => {
			const key = createKey(configChecksum, input, options?.key || "");
			newFileMapping.push(key);
			const filePath = join(directory, `${key}.cache`);
			if (fileMapping?.includes(key) || newFileMapping.includes(key)) {
				if (existsSync(filePath)) try {
					return JSON.parse(await readFile(filePath, "utf-8"));
				} catch (e) {
					console.error("Failed to parse the cache file. We will recompute the value.");
				}
			}
			const output = await fn(input);
			if (!existsSync(directory)) await mkdir(directory, { recursive: true });
			await writeFile(filePath, JSON.stringify(output));
			return output;
		};
		const tidyUp = async () => {
			const filesToDelete = fileMapping?.filter((key) => !newFileMapping.includes(key)) || [];
			for (const key of filesToDelete) {
				const filePath = join(directory, `${key}.cache`);
				if (existsSync(filePath)) await unlink(filePath);
			}
			if (collectionMapping) collectionMapping[file] = newFileMapping;
		};
		return {
			cacheFn,
			tidyUp
		};
	}
	return {
		cache,
		flush
	};
}

//#endregion
//#region src/parser.ts
function parseYaml(content) {
	return parse(content.trim());
}
function frontmatter(fileContent) {
	return matter(fileContent, { engines: { yaml: {
		parse: parseYaml,
		stringify
	} } });
}
function frontmatterParser(fileContent) {
	const { data, content } = frontmatter(fileContent);
	return {
		...data,
		content: content.trim()
	};
}
function frontmatterOnlyParser(fileContent) {
	const { data } = frontmatter(fileContent);
	return data;
}
const parsers = {
	frontmatter: {
		hasContent: true,
		parse: frontmatterParser
	},
	["frontmatter-only"]: {
		hasContent: false,
		parse: frontmatterOnlyParser
	},
	json: {
		hasContent: false,
		parse: JSON.parse
	},
	yaml: {
		hasContent: false,
		parse: parseYaml
	}
};
function getParser(configuredParser) {
	if (typeof configuredParser === "string") return parsers[configuredParser];
	return configuredParser;
}
function defineParser(parser) {
	if (typeof parser === "function") return {
		hasContent: false,
		parse: parser
	};
	return parser;
}
function isValidParser(parser) {
	if (typeof parser === "string") return parser in parsers;
	return "hasContent" in parser && typeof parser.parse === "function";
}

//#endregion
//#region src/utils.ts
function generateTypeName(name) {
	return camelcase(pluralize.singular(name), { pascalCase: true });
}
function isDefined(value) {
	return value !== void 0 && value !== null;
}
function orderByPath(a, b) {
	return a.path.localeCompare(b.path);
}
function removeChildPaths(paths) {
	return Array.from(new Set(paths.filter((path$1) => {
		return !paths.some((otherPath) => {
			if (path$1 === otherPath) return false;
			return path$1.startsWith(otherPath);
		});
	})));
}
function posixToNativePath(pathName) {
	if (path.sep !== path.posix.sep) return pathName.replaceAll(path.posix.sep, path.sep);
	return pathName;
}
function toError(error) {
	return error instanceof Error ? error : new Error(String(error));
}

//#endregion
//#region src/collector.ts
var CollectError = class extends Error {
	type;
	constructor(type, message) {
		super(message);
		this.type = type;
	}
};
function createCollector(emitter, baseDirectory = ".") {
	async function read(filePath) {
		try {
			return await readFile$1(filePath, "utf-8");
		} catch (error) {
			emitter.emit("collector:read-error", {
				filePath,
				error: new CollectError("Read", String(error))
			});
			return null;
		}
	}
	async function collectFile(collection, filePath) {
		const file = await read(path.join(baseDirectory, collection.directory, filePath));
		if (!file) return null;
		try {
			return {
				data: await getParser(collection.parser).parse(file),
				path: filePath
			};
		} catch (error) {
			emitter.emit("collector:parse-error", {
				filePath: path.join(collection.directory, filePath),
				error: new CollectError("Parse", String(error))
			});
			return null;
		}
	}
	function createIgnorePattern(collection) {
		if (collection.exclude) if (Array.isArray(collection.exclude)) return collection.exclude;
		else return [collection.exclude];
	}
	async function resolveCollection(collection) {
		const collectionDirectory = path.join(baseDirectory, collection.directory);
		const promises = (await glob(Array.isArray(collection.include) ? collection.include : [collection.include], {
			cwd: collectionDirectory,
			onlyFiles: true,
			absolute: false,
			ignore: createIgnorePattern(collection)
		})).map((filePath) => collectFile(collection, posixToNativePath(filePath)));
		const files = await Promise.all(promises);
		return {
			...collection,
			files: files.filter(isDefined).sort(orderByPath)
		};
	}
	async function collect(unresolvedCollections) {
		const promises = unresolvedCollections.map((collection) => resolveCollection(collection));
		return await Promise.all(promises);
	}
	return {
		collect,
		collectFile
	};
}

//#endregion
//#region src/synchronizer.ts
function createSynchronizer(readCollectionFile, collections, baseDirectory = ".") {
	function findCollections(filePath) {
		const resolvedFilePath = path.resolve(filePath);
		return collections.filter((collection) => {
			return resolvedFilePath.startsWith(path.resolve(baseDirectory, collection.directory));
		});
	}
	function createRelativePath(collectionPath, filePath) {
		const resolvedCollectionPath = path.resolve(baseDirectory, collectionPath);
		let relativePath = path.resolve(filePath).slice(resolvedCollectionPath.length);
		if (relativePath.startsWith(path.sep)) relativePath = relativePath.slice(path.sep.length);
		return relativePath;
	}
	function resolve$1(filePath) {
		return findCollections(filePath).map((collection) => {
			return {
				collection,
				relativePath: createRelativePath(collection.directory, filePath)
			};
		}).filter(({ collection, relativePath }) => {
			return picomatch.isMatch(relativePath, collection.include, {
				windows: process.platform === "win32",
				ignore: collection.exclude
			});
		});
	}
	function deleted(filePath) {
		const resolvedCollections = resolve$1(filePath);
		if (resolvedCollections.length === 0) return false;
		let changed$1 = false;
		for (const { collection, relativePath } of resolvedCollections) {
			const index = collection.files.findIndex((file) => file.path === relativePath);
			if (collection.files.splice(index, 1).length > 0) changed$1 = true;
		}
		return changed$1;
	}
	async function changed(filePath) {
		const resolvedCollections = resolve$1(filePath);
		if (resolvedCollections.length === 0) return false;
		let changed$1 = false;
		for (const { collection, relativePath } of resolvedCollections) {
			const index = collection.files.findIndex((file$1) => file$1.path === relativePath);
			const file = await readCollectionFile(collection, relativePath);
			if (file) {
				changed$1 = true;
				if (index === -1) {
					collection.files.push(file);
					collection.files.sort(orderByPath);
				} else collection.files[index] = file;
			}
		}
		return changed$1;
	}
	return {
		deleted,
		changed
	};
}

//#endregion
//#region ../../node_modules/.pnpm/load-tsconfig@0.2.5/node_modules/load-tsconfig/dist/index.js
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
var stripWithoutWhitespace = () => "";
var stripWithWhitespace = (string$2, start, end) => string$2.slice(start, end).replace(/\S/g, " ");
var isEscaped = (jsonString, quotePosition) => {
	let index = quotePosition - 1;
	let backslashCount = 0;
	while (jsonString[index] === "\\") {
		index -= 1;
		backslashCount += 1;
	}
	return Boolean(backslashCount % 2);
};
function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
	if (typeof jsonString !== "string") throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
	const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
	let isInsideString = false;
	let isInsideComment = false;
	let offset = 0;
	let buffer = "";
	let result = "";
	let commaIndex = -1;
	for (let index = 0; index < jsonString.length; index++) {
		const currentCharacter = jsonString[index];
		const nextCharacter = jsonString[index + 1];
		if (!isInsideComment && currentCharacter === "\"") {
			if (!isEscaped(jsonString, index)) isInsideString = !isInsideString;
		}
		if (isInsideString) continue;
		if (!isInsideComment && currentCharacter + nextCharacter === "//") {
			buffer += jsonString.slice(offset, index);
			offset = index;
			isInsideComment = singleComment;
			index++;
		} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
			index++;
			isInsideComment = false;
			buffer += strip(jsonString, offset, index);
			offset = index;
			continue;
		} else if (isInsideComment === singleComment && currentCharacter === "\n") {
			isInsideComment = false;
			buffer += strip(jsonString, offset, index);
			offset = index;
		} else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
			buffer += jsonString.slice(offset, index);
			offset = index;
			isInsideComment = multiComment;
			index++;
			continue;
		} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
			index++;
			isInsideComment = false;
			buffer += strip(jsonString, offset, index + 1);
			offset = index + 1;
			continue;
		} else if (trailingCommas && !isInsideComment) {
			if (commaIndex !== -1) {
				if (currentCharacter === "}" || currentCharacter === "]") {
					buffer += jsonString.slice(offset, index);
					result += strip(buffer, 0, 1) + buffer.slice(1);
					buffer = "";
					offset = index;
					commaIndex = -1;
				} else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
					buffer += jsonString.slice(offset, index);
					offset = index;
					commaIndex = -1;
				}
			} else if (currentCharacter === ",") {
				result += buffer + jsonString.slice(offset, index);
				buffer = "";
				offset = index;
				commaIndex = index;
			}
		}
	}
	return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
function jsoncParse(data) {
	try {
		return new Function("return " + stripJsonComments(data).trim())();
	} catch (_) {
		return {};
	}
}
var req = createRequire(import.meta.url);
var findUp = (name, startDir, stopDir = path2.parse(startDir).root) => {
	let dir = startDir;
	while (dir !== stopDir) {
		const file = path2.join(dir, name);
		if (fs2.existsSync(file)) return file;
		if (!file.endsWith(".json")) {
			const fileWithExt = file + ".json";
			if (fs2.existsSync(fileWithExt)) return fileWithExt;
		}
		dir = path2.dirname(dir);
	}
	return null;
};
var resolveTsConfigFromFile = (cwd, filename) => {
	if (path2.isAbsolute(filename)) return fs2.existsSync(filename) ? filename : null;
	return findUp(filename, cwd);
};
var resolveTsConfigFromExtends = (cwd, name) => {
	if (path2.isAbsolute(name)) return fs2.existsSync(name) ? name : null;
	if (name.startsWith(".")) return findUp(name, cwd);
	return req.resolve(name, { paths: [cwd] });
};
var loadTsConfigInternal = (dir = process.cwd(), name = "tsconfig.json", isExtends = false) => {
	var _a, _b;
	dir = path2.resolve(dir);
	const id = isExtends ? resolveTsConfigFromExtends(dir, name) : resolveTsConfigFromFile(dir, name);
	if (!id) return null;
	const data = jsoncParse(fs2.readFileSync(id, "utf-8"));
	const configDir = path2.dirname(id);
	if ((_a = data.compilerOptions) == null ? void 0 : _a.baseUrl) data.compilerOptions.baseUrl = path2.join(configDir, data.compilerOptions.baseUrl);
	let extendsFiles = [];
	if (data.extends) {
		const extendsList = Array.isArray(data.extends) ? data.extends : [data.extends];
		const extendsData = {};
		for (const name2 of extendsList) {
			const parentConfig = loadTsConfigInternal(configDir, name2, true);
			if (parentConfig) {
				Object.assign(extendsData, {
					...parentConfig == null ? void 0 : parentConfig.data,
					compilerOptions: {
						...extendsData.compilerOptions,
						...(_b = parentConfig == null ? void 0 : parentConfig.data) == null ? void 0 : _b.compilerOptions
					}
				});
				extendsFiles.push(...parentConfig.files);
			}
		}
		Object.assign(data, {
			...extendsData,
			...data,
			compilerOptions: {
				...extendsData.compilerOptions,
				...data.compilerOptions
			}
		});
	}
	delete data.extends;
	return {
		path: id,
		data,
		files: [...extendsFiles, id]
	};
};
var loadTsConfig = (dir, name) => loadTsConfigInternal(dir, name);

//#endregion
//#region ../../node_modules/.pnpm/bundle-require@5.0.0_esbuild@0.25.11/node_modules/bundle-require/dist/index.js
var tsconfigPathsToRegExp = (paths) => {
	return Object.keys(paths || {}).map((key) => {
		return /* @__PURE__ */ new RegExp(`^${key.replace(/\*/, ".*")}$`);
	});
};
var match = (id, patterns) => {
	if (!patterns) return false;
	return patterns.some((p) => {
		if (p instanceof RegExp) return p.test(id);
		return id === p || id.startsWith(p + "/");
	});
};

//#endregion
//#region src/esbuild.ts
function tsconfigResolvePaths(configPath) {
	let tsconfig = loadTsConfig(dirname(configPath));
	if (!tsconfig) tsconfig = loadTsConfig();
	return tsconfig?.data?.compilerOptions?.paths || {};
}
const NON_NODE_MODULE_RE = /^[A-Z]:[/\\]|^\.{0,2}\/|^\.{1,2}$/;
function isCoreImport(path$1, kind) {
	return path$1 === "@content-collections/core" && kind === "import-statement";
}
function createExternalsPlugin(configPath) {
	const resolvePatterns = tsconfigPathsToRegExp(tsconfigResolvePaths(configPath));
	return {
		name: "external-packages",
		setup: (build$2) => {
			build$2.onResolve({ filter: /.*/ }, ({ path: path$1, kind }) => {
				if (process.env.NODE_ENV === "test" && isCoreImport(path$1, kind)) return {
					path: join(__dirname, "index.ts"),
					external: true
				};
				if (match(path$1, resolvePatterns)) {
					if (kind === "dynamic-import") return {
						path: path$1,
						external: true
					};
					return;
				}
				if (!NON_NODE_MODULE_RE.test(path$1)) return {
					path: path$1,
					external: true
				};
			});
		}
	};
}
async function compile(configurationPath, outfile) {
	const result = await build({
		entryPoints: [configurationPath],
		packages: "external",
		bundle: true,
		platform: "node",
		format: "esm",
		plugins: [createExternalsPlugin(configurationPath)],
		outfile,
		metafile: true
	});
	return Object.keys(result.metafile.inputs);
}

//#endregion
//#region src/configurationReader.ts
var ConfigurationError = class extends Error {
	type;
	constructor(type, message) {
		super(message);
		this.type = type;
	}
};
const defaultConfigName = "content-collection-config.mjs";
function resolveCacheDir(config$1, options) {
	if (options.cacheDir) return options.cacheDir;
	return path.join(path.dirname(config$1), ".content-collections", "cache");
}
function createConfigurationReader() {
	return async (configurationPath, options = { configName: defaultConfigName }) => {
		if (!existsSync(configurationPath)) throw new ConfigurationError("Read", `configuration file ${configurationPath} does not exist`);
		const cacheDir = resolveCacheDir(configurationPath, options);
		await fs.mkdir(cacheDir, { recursive: true });
		const outfile = path.join(cacheDir, options.configName);
		try {
			const configurationPaths = await compile(configurationPath, outfile);
			const module = await import(`file://${path.resolve(outfile)}?x=${Date.now()}`);
			const hash = createHash("sha256");
			hash.update(await fs.readFile(outfile, "utf-8"));
			const checksum = hash.digest("hex");
			return {
				...module.default,
				path: configurationPath,
				inputPaths: configurationPaths.map((p) => path.resolve(p)),
				generateTypes: true,
				checksum
			};
		} catch (error) {
			throw new ConfigurationError("Compile", `configuration file ${configurationPath} is invalid: ${error}`);
		}
	};
}

//#endregion
//#region src/features.ts
const deprecations = { implicitContentProperty: `The implicit addition of a content property to schemas is deprecated.
Please add an explicit content property to your schema.
For more information, see:
https://content-collections.dev/docs/deprecations/implicit-content-property` };
const _suppressDeprecatedWarnings = [];
function suppressDeprecatedWarnings(...suppresses) {
	for (const deprecation of suppresses) if (deprecation === "all") {
		_suppressDeprecatedWarnings.push(...Object.keys(deprecations));
		return;
	} else _suppressDeprecatedWarnings.push(deprecation);
}
function deprecated(deprecation, logger = console.warn) {
	if (_suppressDeprecatedWarnings.includes(deprecation)) return;
	logger(`[CC DEPRECATED]: ${deprecations[deprecation]}`);
}
const retiredFeatures = { legacySchema: `The use of a function as a schema is retired.
Please use a StandardSchema compliant library directly.
For more information, see:
https://content-collections.dev/docs/deprecations/schema-as-function` };
var RetiredFeatureError = class RetiredFeatureError extends Error {
	feature;
	constructor(feature) {
		super(`This feature has been removed:\n${retiredFeatures[feature]}`);
		this.feature = feature;
		this.name = "RetiredFeatureError";
		Object.setPrototypeOf(this, RetiredFeatureError.prototype);
	}
};
function retired(feature) {
	throw new RetiredFeatureError(feature);
}

//#endregion
//#region src/config.ts
const skippedSymbol = Symbol("skipped");
function defineCollection(collection) {
	let typeName = collection.typeName;
	if (!typeName) typeName = generateTypeName(collection.name);
	let parser = collection.parser;
	if (!parser) parser = "frontmatter";
	else if (!isValidParser(parser)) throw new ConfigurationError("Read", `Parser ${parser} is not valid a parser`);
	let schema$1 = collection.schema;
	if (!schema$1["~standard"]) retired("legacySchema");
	return {
		...collection,
		typeName,
		parser,
		schema: schema$1
	};
}
function defineConfig(config$1) {
	return config$1;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/core.js
/** A special constant with type `never` */
const NEVER = Object.freeze({ status: "aborted" });
function $constructor(name, initializer$1, params) {
	function init(inst, def) {
		var _a;
		Object.defineProperty(inst, "_zod", {
			value: inst._zod ?? {},
			enumerable: false
		});
		(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
		inst._zod.traits.add(name);
		initializer$1(inst, def);
		for (const k in _.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
		inst._zod.constr = _;
		inst._zod.def = def;
	}
	const Parent = params?.Parent ?? Object;
	class Definition extends Parent {}
	Object.defineProperty(Definition, "name", { value: name });
	function _(def) {
		var _a;
		const inst = params?.Parent ? new Definition() : this;
		init(inst, def);
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		for (const fn of inst._zod.deferred) fn();
		return inst;
	}
	Object.defineProperty(_, "init", { value: init });
	Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
		if (params?.Parent && inst instanceof params.Parent) return true;
		return inst?._zod?.traits?.has(name);
	} });
	Object.defineProperty(_, "name", { value: name });
	return _;
}
const $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
	constructor() {
		super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	}
};
const globalConfig = {};
function config(newConfig) {
	if (newConfig) Object.assign(globalConfig, newConfig);
	return globalConfig;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/util.js
function jsonStringifyReplacer(_, value) {
	if (typeof value === "bigint") return value.toString();
	return value;
}
function cached(getter) {
	return { get value() {
		{
			const value = getter();
			Object.defineProperty(this, "value", { value });
			return value;
		}
		throw new Error("cached value already set");
	} };
}
function cleanRegex(source) {
	const start = source.startsWith("^") ? 1 : 0;
	const end = source.endsWith("$") ? source.length - 1 : source.length;
	return source.slice(start, end);
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object$1, key, getter) {
	let value = void 0;
	Object.defineProperty(object$1, key, {
		get() {
			if (value === EVALUATING) return;
			if (value === void 0) {
				value = EVALUATING;
				value = getter();
			}
			return value;
		},
		set(v) {
			Object.defineProperty(object$1, key, { value: v });
		},
		configurable: true
	});
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
	return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
	if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
	try {
		new Function("");
		return true;
	} catch (_) {
		return false;
	}
});
function isPlainObject(o) {
	if (isObject(o) === false) return false;
	const ctor = o.constructor;
	if (ctor === void 0) return true;
	const prot = ctor.prototype;
	if (isObject(prot) === false) return false;
	if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
	return true;
}
const propertyKeyTypes = new Set([
	"string",
	"number",
	"symbol"
]);
function escapeRegex(str) {
	return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
	const cl = new inst._zod.constr(def ?? inst._zod.def);
	if (!def || params?.parent) cl._zod.parent = inst;
	return cl;
}
function normalizeParams(_params) {
	const params = _params;
	if (!params) return {};
	if (typeof params === "string") return { error: () => params };
	if (params?.message !== void 0) {
		if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
		params.error = params.message;
	}
	delete params.message;
	if (typeof params.error === "string") return {
		...params,
		error: () => params.error
	};
	return params;
}
function optionalKeys(shape) {
	return Object.keys(shape).filter((k) => {
		return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
	});
}
const NUMBER_FORMAT_RANGES = {
	safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
	int32: [-2147483648, 2147483647],
	uint32: [0, 4294967295],
	float32: [-34028234663852886e22, 34028234663852886e22],
	float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function aborted(x, startIndex = 0) {
	if (x.aborted === true) return true;
	for (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;
	return false;
}
function prefixIssues(path$1, issues) {
	return issues.map((iss) => {
		var _a;
		(_a = iss).path ?? (_a.path = []);
		iss.path.unshift(path$1);
		return iss;
	});
}
function unwrapMessage(message) {
	return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config$1) {
	const full = {
		...iss,
		path: iss.path ?? []
	};
	if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
	delete full.inst;
	delete full.continue;
	if (!ctx?.reportInput) delete full.input;
	return full;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/errors.js
const initializer = (inst, def) => {
	inst.name = "$ZodError";
	Object.defineProperty(inst, "_zod", {
		value: inst._zod,
		enumerable: false
	});
	Object.defineProperty(inst, "issues", {
		value: def,
		enumerable: false
	});
	inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
	Object.defineProperty(inst, "toString", {
		value: () => inst.message,
		enumerable: false
	});
};
const $ZodError = $constructor("$ZodError", initializer);
const $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/parse.js
const _parse = (_Err) => (schema$1, value, _ctx, _params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	const result = schema$1._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	if (result.issues.length) {
		const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, _params?.callee);
		throw e;
	}
	return result.value;
};
const parse$1 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema$1, value, _ctx, params) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema$1._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	if (result.issues.length) {
		const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
		captureStackTrace(e, params?.callee);
		throw e;
	}
	return result.value;
};
const parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema$1, value, _ctx) => {
	const ctx = _ctx ? {
		..._ctx,
		async: false
	} : { async: false };
	const result = schema$1._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) throw new $ZodAsyncError();
	return result.issues.length ? {
		success: false,
		error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema$1, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	let result = schema$1._zod.run({
		value,
		issues: []
	}, ctx);
	if (result instanceof Promise) result = await result;
	return result.issues.length ? {
		success: false,
		error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	} : {
		success: true,
		data: result.value
	};
};
const safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema$1, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parse(_Err)(schema$1, value, ctx);
};
const encode = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema$1, value, _ctx) => {
	return _parse(_Err)(schema$1, value, _ctx);
};
const decode = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema$1, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _parseAsync(_Err)(schema$1, value, ctx);
};
const encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema$1, value, _ctx) => {
	return _parseAsync(_Err)(schema$1, value, _ctx);
};
const decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema$1, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParse(_Err)(schema$1, value, ctx);
};
const safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema$1, value, _ctx) => {
	return _safeParse(_Err)(schema$1, value, _ctx);
};
const safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema$1, value, _ctx) => {
	const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	return _safeParseAsync(_Err)(schema$1, value, ctx);
};
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema$1, value, _ctx) => {
	return _safeParseAsync(_Err)(schema$1, value, _ctx);
};
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/regexes.js
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
const string$1 = (params) => {
	const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
};
const bigint$1 = /^-?\d+n?$/;
const number$1 = /^-?\d+(?:\.\d+)?/;
const boolean$1 = /^(?:true|false)$/i;
const _null$2 = /^null$/i;
const _undefined$2 = /^undefined$/i;

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/versions.js
const version = {
	major: 4,
	minor: 1,
	patch: 11
};

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/schemas.js
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
	var _a;
	inst ?? (inst = {});
	inst._zod.def = def;
	inst._zod.bag = inst._zod.bag || {};
	inst._zod.version = version;
	const checks = [...inst._zod.def.checks ?? []];
	if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
	for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
	if (checks.length === 0) {
		(_a = inst._zod).deferred ?? (_a.deferred = []);
		inst._zod.deferred?.push(() => {
			inst._zod.run = inst._zod.parse;
		});
	} else {
		const runChecks = (payload, checks$1, ctx) => {
			let isAborted = aborted(payload);
			let asyncResult;
			for (const ch of checks$1) {
				if (ch._zod.def.when) {
					if (!ch._zod.def.when(payload)) continue;
				} else if (isAborted) continue;
				const currLen = payload.issues.length;
				const _ = ch._zod.check(payload);
				if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
				if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
					await _;
					if (payload.issues.length === currLen) return;
					if (!isAborted) isAborted = aborted(payload, currLen);
				});
				else {
					if (payload.issues.length === currLen) continue;
					if (!isAborted) isAborted = aborted(payload, currLen);
				}
			}
			if (asyncResult) return asyncResult.then(() => {
				return payload;
			});
			return payload;
		};
		const handleCanaryResult = (canary, payload, ctx) => {
			if (aborted(canary)) {
				canary.aborted = true;
				return canary;
			}
			const checkResult = runChecks(payload, checks, ctx);
			if (checkResult instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return checkResult.then((checkResult$1) => inst._zod.parse(checkResult$1, ctx));
			}
			return inst._zod.parse(checkResult, ctx);
		};
		inst._zod.run = (payload, ctx) => {
			if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
			if (ctx.direction === "backward") {
				const canary = inst._zod.parse({
					value: payload.value,
					issues: []
				}, {
					...ctx,
					skipChecks: true
				});
				if (canary instanceof Promise) return canary.then((canary$1) => {
					return handleCanaryResult(canary$1, payload, ctx);
				});
				return handleCanaryResult(canary, payload, ctx);
			}
			const result = inst._zod.parse(payload, ctx);
			if (result instanceof Promise) {
				if (ctx.async === false) throw new $ZodAsyncError();
				return result.then((result$1) => runChecks(result$1, checks, ctx));
			}
			return runChecks(result, checks, ctx);
		};
	}
	inst["~standard"] = {
		validate: (value) => {
			try {
				const r = safeParse(inst, value);
				return r.success ? { value: r.data } : { issues: r.error?.issues };
			} catch (_) {
				return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
			}
		},
		vendor: "zod",
		version: 1
	};
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
	inst._zod.parse = (payload, _) => {
		if (def.coerce) try {
			payload.value = String(payload.value);
		} catch (_$1) {}
		if (typeof payload.value === "string") return payload;
		payload.issues.push({
			expected: "string",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Number(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
		const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
		payload.issues.push({
			expected: "number",
			code: "invalid_type",
			input,
			inst,
			...received ? { received } : {}
		});
		return payload;
	};
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = boolean$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = Boolean(payload.value);
		} catch (_) {}
		const input = payload.value;
		if (typeof input === "boolean") return payload;
		payload.issues.push({
			expected: "boolean",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = bigint$1;
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = BigInt(payload.value);
		} catch (_) {}
		if (typeof payload.value === "bigint") return payload;
		payload.issues.push({
			expected: "bigint",
			code: "invalid_type",
			input: payload.value,
			inst
		});
		return payload;
	};
});
const $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _undefined$2;
	inst._zod.values = new Set([void 0]);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (typeof input === "undefined") return payload;
		payload.issues.push({
			expected: "undefined",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.pattern = _null$2;
	inst._zod.values = new Set([null]);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (input === null) return payload;
		payload.issues.push({
			expected: "null",
			code: "invalid_type",
			input,
			inst
		});
		return payload;
	};
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload) => payload;
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, _ctx) => {
		if (def.coerce) try {
			payload.value = new Date(payload.value);
		} catch (_err) {}
		const input = payload.value;
		const isDate = input instanceof Date;
		if (isDate && !Number.isNaN(input.getTime())) return payload;
		payload.issues.push({
			expected: "date",
			code: "invalid_type",
			input,
			...isDate ? { received: "Invalid Date" } : {},
			inst
		});
		return payload;
	};
});
function handleArrayResult(result, final, index) {
	if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
	final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!Array.isArray(input)) {
			payload.issues.push({
				expected: "array",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = Array(input.length);
		const proms = [];
		for (let i = 0; i < input.length; i++) {
			const item = input[i];
			const result = def.element._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i)));
			else handleArrayResult(result, payload, i);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handlePropertyResult(result, final, key, input) {
	if (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));
	if (result.value === void 0) {
		if (key in input) final.value[key] = void 0;
	} else final.value[key] = result.value;
}
function normalizeDef(def) {
	const keys = Object.keys(def.shape);
	for (const k of keys) if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
	const okeys = optionalKeys(def.shape);
	return {
		...def,
		keys,
		keySet: new Set(keys),
		numKeys: keys.length,
		optionalKeys: new Set(okeys)
	};
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
	const unrecognized = [];
	const keySet = def.keySet;
	const _catchall = def.catchall._zod;
	const t = _catchall.def.type;
	for (const key of Object.keys(input)) {
		if (keySet.has(key)) continue;
		if (t === "never") {
			unrecognized.push(key);
			continue;
		}
		const r = _catchall.run({
			value: input[key],
			issues: []
		}, ctx);
		if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));
		else handlePropertyResult(r, payload, key, input);
	}
	if (unrecognized.length) payload.issues.push({
		code: "unrecognized_keys",
		keys: unrecognized,
		input,
		inst
	});
	if (!proms.length) return payload;
	return Promise.all(proms).then(() => {
		return payload;
	});
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
	$ZodType.init(inst, def);
	if (!Object.getOwnPropertyDescriptor(def, "shape")?.get) {
		const sh = def.shape;
		Object.defineProperty(def, "shape", { get: () => {
			const newSh = { ...sh };
			Object.defineProperty(def, "shape", { value: newSh });
			return newSh;
		} });
	}
	const _normalized = cached(() => normalizeDef(def));
	defineLazy(inst._zod, "propValues", () => {
		const shape = def.shape;
		const propValues = {};
		for (const key in shape) {
			const field = shape[key]._zod;
			if (field.values) {
				propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
				for (const v of field.values) propValues[key].add(v);
			}
		}
		return propValues;
	});
	const isObject$1 = isObject;
	const catchall = def.catchall;
	let value;
	inst._zod.parse = (payload, ctx) => {
		value ?? (value = _normalized.value);
		const input = payload.value;
		if (!isObject$1(input)) {
			payload.issues.push({
				expected: "object",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		payload.value = {};
		const proms = [];
		const shape = value.shape;
		for (const key of value.keys) {
			const r = shape[key]._zod.run({
				value: input[key],
				issues: []
			}, ctx);
			if (r instanceof Promise) proms.push(r.then((r$1) => handlePropertyResult(r$1, payload, key, input)));
			else handlePropertyResult(r, payload, key, input);
		}
		if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
		return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	};
});
function handleUnionResults(results, final, inst, ctx) {
	for (const result of results) if (result.issues.length === 0) {
		final.value = result.value;
		return final;
	}
	const nonaborted = results.filter((r) => !aborted(r));
	if (nonaborted.length === 1) {
		final.value = nonaborted[0].value;
		return nonaborted[0];
	}
	final.issues.push({
		code: "invalid_union",
		input: final.value,
		inst,
		errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
	});
	return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
	defineLazy(inst._zod, "values", () => {
		if (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	});
	defineLazy(inst._zod, "pattern", () => {
		if (def.options.every((o) => o._zod.pattern)) {
			const patterns = def.options.map((o) => o._zod.pattern);
			return /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
		}
	});
	const single = def.options.length === 1;
	const first = def.options[0]._zod.run;
	inst._zod.parse = (payload, ctx) => {
		if (single) return first(payload, ctx);
		let async = false;
		const results = [];
		for (const option of def.options) {
			const result = option._zod.run({
				value: payload.value,
				issues: []
			}, ctx);
			if (result instanceof Promise) {
				results.push(result);
				async = true;
			} else {
				if (result.issues.length === 0) return result;
				results.push(result);
			}
		}
		if (!async) return handleUnionResults(results, payload, inst, ctx);
		return Promise.all(results).then((results$1) => {
			return handleUnionResults(results$1, payload, inst, ctx);
		});
	};
});
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!isPlainObject(input)) {
			payload.issues.push({
				expected: "record",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		if (def.keyType._zod.values) {
			const values = def.keyType._zod.values;
			payload.value = {};
			for (const key of values) if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
				const result = def.valueType._zod.run({
					value: input[key],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key, result$1.issues));
					payload.value[key] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
					payload.value[key] = result.value;
				}
			}
			let unrecognized;
			for (const key in input) if (!values.has(key)) {
				unrecognized = unrecognized ?? [];
				unrecognized.push(key);
			}
			if (unrecognized && unrecognized.length > 0) payload.issues.push({
				code: "unrecognized_keys",
				input,
				inst,
				keys: unrecognized
			});
		} else {
			payload.value = {};
			for (const key of Reflect.ownKeys(input)) {
				if (key === "__proto__") continue;
				const keyResult = def.keyType._zod.run({
					value: key,
					issues: []
				}, ctx);
				if (keyResult instanceof Promise) throw new Error("Async schemas not supported in object keys currently");
				if (keyResult.issues.length) {
					payload.issues.push({
						code: "invalid_key",
						origin: "record",
						issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
						input: key,
						path: [key],
						inst
					});
					payload.value[keyResult.value] = keyResult.value;
					continue;
				}
				const result = def.valueType._zod.run({
					value: input[key],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => {
					if (result$1.issues.length) payload.issues.push(...prefixIssues(key, result$1.issues));
					payload.value[keyResult.value] = result$1.value;
				}));
				else {
					if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
					payload.value[keyResult.value] = result.value;
				}
			}
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
const $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Map)) {
			payload.issues.push({
				expected: "map",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		}
		const proms = [];
		payload.value = /* @__PURE__ */ new Map();
		for (const [key, value] of input) {
			const keyResult = def.keyType._zod.run({
				value: key,
				issues: []
			}, ctx);
			const valueResult = def.valueType._zod.run({
				value,
				issues: []
			}, ctx);
			if (keyResult instanceof Promise || valueResult instanceof Promise) proms.push(Promise.all([keyResult, valueResult]).then(([keyResult$1, valueResult$1]) => {
				handleMapResult(keyResult$1, valueResult$1, payload, key, input, inst, ctx);
			}));
			else handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
	if (keyResult.issues.length) if (propertyKeyTypes.has(typeof key)) final.issues.push(...prefixIssues(key, keyResult.issues));
	else final.issues.push({
		code: "invalid_key",
		origin: "map",
		input,
		inst,
		issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
	});
	if (valueResult.issues.length) if (propertyKeyTypes.has(typeof key)) final.issues.push(...prefixIssues(key, valueResult.issues));
	else final.issues.push({
		origin: "map",
		code: "invalid_element",
		input,
		inst,
		key,
		issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
	});
	final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.parse = (payload, ctx) => {
		const input = payload.value;
		if (!(input instanceof Set)) {
			payload.issues.push({
				input,
				inst,
				expected: "set",
				code: "invalid_type"
			});
			return payload;
		}
		const proms = [];
		payload.value = /* @__PURE__ */ new Set();
		for (const item of input) {
			const result = def.valueType._zod.run({
				value: item,
				issues: []
			}, ctx);
			if (result instanceof Promise) proms.push(result.then((result$1) => handleSetResult(result$1, payload)));
			else handleSetResult(result, payload);
		}
		if (proms.length) return Promise.all(proms).then(() => payload);
		return payload;
	};
});
function handleSetResult(result, final) {
	if (result.issues.length) final.issues.push(...result.issues);
	final.value.add(result.value);
}
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
	$ZodType.init(inst, def);
	if (def.values.length === 0) throw new Error("Cannot create literal schema with no valid values");
	inst._zod.values = new Set(def.values);
	inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
	inst._zod.parse = (payload, _ctx) => {
		const input = payload.value;
		if (inst._zod.values.has(input)) return payload;
		payload.issues.push({
			code: "invalid_value",
			values: def.values,
			input,
			inst
		});
		return payload;
	};
});
function handleOptionalResult(result, input) {
	if (result.issues.length && input === void 0) return {
		issues: [],
		value: void 0
	};
	return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
	$ZodType.init(inst, def);
	inst._zod.optin = "optional";
	inst._zod.optout = "optional";
	defineLazy(inst._zod, "values", () => {
		return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
	});
	defineLazy(inst._zod, "pattern", () => {
		const pattern = def.innerType._zod.pattern;
		return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
	});
	inst._zod.parse = (payload, ctx) => {
		if (def.innerType._zod.optin === "optional") {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((r) => handleOptionalResult(r, payload.value));
			return handleOptionalResult(result, payload.value);
		}
		if (payload.value === void 0) return payload;
		return def.innerType._zod.run(payload, ctx);
	};
});
const $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
	$ZodType.init(inst, def);
	defineLazy(inst._zod, "innerType", () => def.getter());
	defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
	defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
	defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
	defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
	inst._zod.parse = (payload, ctx) => {
		return inst._zod.innerType._zod.run(payload, ctx);
	};
});

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/api.js
function _string(Class, params) {
	return new Class({
		type: "string",
		...normalizeParams(params)
	});
}
function _number(Class, params) {
	return new Class({
		type: "number",
		checks: [],
		...normalizeParams(params)
	});
}
function _boolean(Class, params) {
	return new Class({
		type: "boolean",
		...normalizeParams(params)
	});
}
function _bigint(Class, params) {
	return new Class({
		type: "bigint",
		...normalizeParams(params)
	});
}
function _undefined$1(Class, params) {
	return new Class({
		type: "undefined",
		...normalizeParams(params)
	});
}
function _null$1(Class, params) {
	return new Class({
		type: "null",
		...normalizeParams(params)
	});
}
function _unknown(Class) {
	return new Class({ type: "unknown" });
}
function _date(Class, params) {
	return new Class({
		type: "date",
		...normalizeParams(params)
	});
}

//#endregion
//#region ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/mini/schemas.js
const ZodMiniType = /* @__PURE__ */ $constructor("ZodMiniType", (inst, def) => {
	if (!inst._zod) throw new Error("Uninitialized schema in ZodMiniType.");
	$ZodType.init(inst, def);
	inst.def = def;
	inst.type = def.type;
	inst.parse = (data, params) => parse$1(inst, data, params, { callee: inst.parse });
	inst.safeParse = (data, params) => safeParse(inst, data, params);
	inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
	inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
	inst.check = (...checks) => {
		return inst.clone({
			...def,
			checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
				check: ch,
				def: { check: "custom" },
				onattach: []
			} } : ch)]
		});
	};
	inst.clone = (_def, params) => clone(inst, _def, params);
	inst.brand = () => inst;
	inst.register = ((reg, meta) => {
		reg.add(inst, meta);
		return inst;
	});
});
const ZodMiniString = /* @__PURE__ */ $constructor("ZodMiniString", (inst, def) => {
	$ZodString.init(inst, def);
	ZodMiniType.init(inst, def);
});
function string(params) {
	return _string(ZodMiniString, params);
}
const ZodMiniNumber = /* @__PURE__ */ $constructor("ZodMiniNumber", (inst, def) => {
	$ZodNumber.init(inst, def);
	ZodMiniType.init(inst, def);
});
function number(params) {
	return _number(ZodMiniNumber, params);
}
const ZodMiniBoolean = /* @__PURE__ */ $constructor("ZodMiniBoolean", (inst, def) => {
	$ZodBoolean.init(inst, def);
	ZodMiniType.init(inst, def);
});
function boolean(params) {
	return _boolean(ZodMiniBoolean, params);
}
const ZodMiniBigInt = /* @__PURE__ */ $constructor("ZodMiniBigInt", (inst, def) => {
	$ZodBigInt.init(inst, def);
	ZodMiniType.init(inst, def);
});
function bigint(params) {
	return _bigint(ZodMiniBigInt, params);
}
const ZodMiniUndefined = /* @__PURE__ */ $constructor("ZodMiniUndefined", (inst, def) => {
	$ZodUndefined.init(inst, def);
	ZodMiniType.init(inst, def);
});
function _undefined(params) {
	return _undefined$1(ZodMiniUndefined, params);
}
const ZodMiniNull = /* @__PURE__ */ $constructor("ZodMiniNull", (inst, def) => {
	$ZodNull.init(inst, def);
	ZodMiniType.init(inst, def);
});
function _null(params) {
	return _null$1(ZodMiniNull, params);
}
const ZodMiniUnknown = /* @__PURE__ */ $constructor("ZodMiniUnknown", (inst, def) => {
	$ZodUnknown.init(inst, def);
	ZodMiniType.init(inst, def);
});
function unknown() {
	return _unknown(ZodMiniUnknown);
}
const ZodMiniDate = /* @__PURE__ */ $constructor("ZodMiniDate", (inst, def) => {
	$ZodDate.init(inst, def);
	ZodMiniType.init(inst, def);
});
function date(params) {
	return _date(ZodMiniDate, params);
}
const ZodMiniArray = /* @__PURE__ */ $constructor("ZodMiniArray", (inst, def) => {
	$ZodArray.init(inst, def);
	ZodMiniType.init(inst, def);
});
function array(element, params) {
	return new ZodMiniArray({
		type: "array",
		element,
		...normalizeParams(params)
	});
}
const ZodMiniObject = /* @__PURE__ */ $constructor("ZodMiniObject", (inst, def) => {
	$ZodObject.init(inst, def);
	ZodMiniType.init(inst, def);
	defineLazy(inst, "shape", () => def.shape);
});
function object(shape, params) {
	return new ZodMiniObject({
		type: "object",
		shape: shape ?? {},
		...normalizeParams(params)
	});
}
const ZodMiniUnion = /* @__PURE__ */ $constructor("ZodMiniUnion", (inst, def) => {
	$ZodUnion.init(inst, def);
	ZodMiniType.init(inst, def);
});
function union(options, params) {
	return new ZodMiniUnion({
		type: "union",
		options,
		...normalizeParams(params)
	});
}
const ZodMiniRecord = /* @__PURE__ */ $constructor("ZodMiniRecord", (inst, def) => {
	$ZodRecord.init(inst, def);
	ZodMiniType.init(inst, def);
});
function record(keyType, valueType, params) {
	return new ZodMiniRecord({
		type: "record",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodMiniMap = /* @__PURE__ */ $constructor("ZodMiniMap", (inst, def) => {
	$ZodMap.init(inst, def);
	ZodMiniType.init(inst, def);
});
function map(keyType, valueType, params) {
	return new ZodMiniMap({
		type: "map",
		keyType,
		valueType,
		...normalizeParams(params)
	});
}
const ZodMiniSet = /* @__PURE__ */ $constructor("ZodMiniSet", (inst, def) => {
	$ZodSet.init(inst, def);
	ZodMiniType.init(inst, def);
});
function set(valueType, params) {
	return new ZodMiniSet({
		type: "set",
		valueType,
		...normalizeParams(params)
	});
}
const ZodMiniLiteral = /* @__PURE__ */ $constructor("ZodMiniLiteral", (inst, def) => {
	$ZodLiteral.init(inst, def);
	ZodMiniType.init(inst, def);
});
function literal(value, params) {
	return new ZodMiniLiteral({
		type: "literal",
		values: Array.isArray(value) ? value : [value],
		...normalizeParams(params)
	});
}
const ZodMiniOptional = /* @__PURE__ */ $constructor("ZodMiniOptional", (inst, def) => {
	$ZodOptional.init(inst, def);
	ZodMiniType.init(inst, def);
});
function optional(innerType) {
	return new ZodMiniOptional({
		type: "optional",
		innerType
	});
}
const ZodMiniLazy = /* @__PURE__ */ $constructor("ZodMiniLazy", (inst, def) => {
	$ZodLazy.init(inst, def);
	ZodMiniType.init(inst, def);
});
function _lazy(getter) {
	return new ZodMiniLazy({
		type: "lazy",
		getter
	});
}

//#endregion
//#region src/import.ts
const importSchema = object({
	__cc_import: literal(true),
	path: string(),
	name: optional(string())
});
function isImport(value) {
	return value && value.__cc_import;
}
function createDefaultImport(path$1) {
	return {
		__cc_import: true,
		path: path$1.replace(/\\/g, "/")
	};
}
function createNamedImport(name, path$1) {
	return {
		__cc_import: true,
		path: path$1.replace(/\\/g, "/"),
		name
	};
}

//#endregion
//#region src/serializer.ts
const literalSchema = union([
	string(),
	number(),
	boolean(),
	_null(),
	_undefined(),
	date(),
	map(unknown(), unknown()),
	set(unknown()),
	bigint(),
	importSchema
]);
const schema = _lazy(() => union([
	literalSchema,
	array(schema),
	record(string(), schema)
]));
const extension = "js";
const serializableSchema = record(string(), schema);
function createImport(imp, variableName) {
	return `import ${imp.name ? `{ ${imp.name} as ${variableName} }` : variableName} from "${imp.path}";\n`;
}
function serialize(value) {
	let serializedValue = "";
	let counter = 0;
	function handleImports(item) {
		if (item instanceof Object) Object.entries(item).forEach(([key, value$1]) => {
			if (isImport(value$1)) {
				counter++;
				const variableName = `__v_${counter}`;
				serializedValue += createImport(value$1, variableName);
				item[key] = variableName;
			} else if (value$1 instanceof Object) handleImports(value$1);
		});
	}
	value.forEach(handleImports);
	serializedValue += "\n";
	const js = serializeJs(value, {
		space: 2,
		unsafe: true,
		ignoreFunction: true
	}).replace(/"__v_(\d+)"/g, (_, index) => {
		return `__v_${index}`;
	});
	serializedValue += "export default " + js;
	return serializedValue;
}

//#endregion
//#region src/transformer.ts
var TransformError = class extends Error {
	type;
	constructor(type, message) {
		super(message);
		this.type = type;
	}
};
function isSkippedSignal(signal) {
	return signal[skippedSymbol] === true;
}
function createPath(path$1, ext) {
	let p = path$1.slice(0, -ext.length);
	if (p.endsWith("/index")) p = p.slice(0, -6);
	return p;
}
function isContentDefined(value) {
	return value !== null && typeof value === "object" && "content" in value;
}
function formatValidationErrorMessage(issues) {
	return issues.map((issue) => `- ${issue.path}: ${issue.message}`).join("\n");
}
function createTransformer(emitter, cacheManager) {
	const deprecatedWarnings = /* @__PURE__ */ new Set();
	function warnImplicitContentProperty(collection) {
		const key = `implicitContentProperty:${collection.name}`;
		if (deprecatedWarnings.has(key)) return;
		deprecatedWarnings.add(key);
		deprecated("implicitContentProperty");
	}
	async function parseFile(collection, file) {
		const { data, path: path$1 } = file;
		const parsedData = await collection.schema["~standard"].validate(data);
		if (parsedData.issues) {
			emitter.emit("transformer:validation-error", {
				collection,
				file,
				error: new TransformError("Validation", formatValidationErrorMessage(parsedData.issues))
			});
			return null;
		}
		let values = parsedData.value;
		if (getParser(collection.parser).hasContent && !isContentDefined(values)) {
			warnImplicitContentProperty(collection);
			if (typeof data.content !== "string") {
				emitter.emit("transformer:validation-error", {
					collection,
					file,
					error: new TransformError("Validation", `The content property is not a string`)
				});
				return null;
			}
			values = {
				...values,
				content: data.content
			};
		}
		const ext = extname(path$1);
		let extension$1 = ext;
		if (extension$1.startsWith(".")) extension$1 = extension$1.slice(1);
		return { document: {
			...values,
			_meta: {
				filePath: path$1,
				fileName: basename(path$1),
				directory: dirname(path$1),
				extension: extension$1,
				path: createPath(path$1, ext)
			}
		} };
	}
	async function parseCollection(collection) {
		const promises = collection.files.map((file) => parseFile(collection, file));
		return {
			...collection,
			documents: (await Promise.all(promises)).filter(isDefined)
		};
	}
	function createContext(collections, collection, cache) {
		return {
			documents: (collection$1) => {
				const resolved = collections.find((c) => c.name === collection$1.name);
				if (!resolved) throw new TransformError("Configuration", `Collection ${collection$1.name} not found, do you have registered it in your configuration?`);
				return resolved.documents.map((doc) => doc.document);
			},
			collection: {
				name: collection.name,
				directory: collection.directory,
				documents: async () => {
					return collection.documents.map((doc) => doc.document);
				}
			},
			cache: cache.cacheFn,
			skip: (reason) => ({
				[skippedSymbol]: true,
				reason
			})
		};
	}
	async function transformDocument(collections, collection, transform, doc) {
		const cache = cacheManager.cache(collection.name, doc.document._meta.path);
		const context = createContext(collections, collection, cache);
		try {
			const document = await transform(doc.document, context);
			await cache.tidyUp();
			if (isSkippedSignal(document)) emitter.emit("transformer:document-skipped", {
				collection,
				filePath: join(collection.directory, doc.document._meta.filePath),
				reason: document.reason
			});
			else return {
				...doc,
				document
			};
		} catch (error) {
			if (error instanceof TransformError) emitter.emit("transformer:error", {
				collection,
				error
			});
			else emitter.emit("transformer:error", {
				collection,
				error: new TransformError("Transform", String(error))
			});
		}
	}
	async function transformCollection(collections, collection) {
		const transform = collection.transform;
		if (transform) {
			const limit = pLimit(os.cpus().length);
			const docs = collection.documents.map((doc) => limit(() => transformDocument(collections, collection, transform, doc)));
			const transformed = await Promise.all(docs);
			await cacheManager.flush();
			return transformed.filter(isDefined);
		}
		return collection.documents;
	}
	async function validateDocuments(collection, documents) {
		const docs = [];
		for (const doc of documents) {
			let parsedData = await serializableSchema.safeParseAsync(doc.document);
			if (parsedData.success) docs.push(doc);
			else emitter.emit("transformer:result-error", {
				collection,
				document: doc.document,
				error: new TransformError("Result", parsedData.error.message)
			});
		}
		return docs;
	}
	return async (untransformedCollections) => {
		const promises = untransformedCollections.map((collection) => parseCollection(collection));
		const collections = await Promise.all(promises);
		for (const collection of collections) collection.documents = await validateDocuments(collection, await transformCollection(collections, collection));
		return collections;
	};
}

//#endregion
//#region src/writer.ts
function createArrayConstName(name) {
	return "all" + pluralize(name.charAt(0).toUpperCase() + name.slice(1));
}
async function createDataFile(directory, collection) {
	const dataPath = path.join(directory, `${createArrayConstName(collection.name)}.${extension}`);
	await fs.writeFile(dataPath, serialize(collection.documents.map((doc) => doc.document)));
}
function createDataFiles(directory, collections) {
	return Promise.all(collections.map((collection) => createDataFile(directory, collection)));
}
async function createJavaScriptFile(directory, configuration) {
	const collections = configuration.collections.map(({ name }) => createArrayConstName(name));
	let content = `// generated by content-collections at ${/* @__PURE__ */ new Date()}\n\n`;
	for (const name of collections) content += `import ${name} from "./${name}.${extension}";\n`;
	content += "\n";
	content += "export { " + collections.join(", ") + " };\n";
	await fs.writeFile(path.join(directory, "index.js"), content, "utf-8");
}
function createImportPath(directory, target) {
	let importPath = path.posix.join(...path.relative(directory, target).split(path.sep));
	if (!importPath.startsWith(".")) importPath = "./" + importPath;
	return importPath;
}
async function createTypeDefinitionFile(directory, configuration) {
	if (!configuration.generateTypes) return;
	let content = `import configuration from "${createImportPath(directory, configuration.path)}";
import { GetTypeByName } from "@content-collections/core";
`;
	const collections = configuration.collections;
	for (const collection of collections) {
		content += `\n`;
		content += `export type ${collection.typeName} = GetTypeByName<typeof configuration, "${collection.name}">;\n`;
		content += `export declare const ${createArrayConstName(collection.name)}: Array<${collection.typeName}>;\n`;
	}
	content += "\n";
	content += "export {};\n";
	await fs.writeFile(path.join(directory, "index.d.ts"), content, "utf-8");
}
async function createWriter(directory) {
	await fs.mkdir(directory, { recursive: true });
	return {
		createJavaScriptFile: (configuration) => createJavaScriptFile(directory, configuration),
		createTypeDefinitionFile: (configuration) => createTypeDefinitionFile(directory, configuration),
		createDataFiles: (collections) => createDataFiles(directory, collections)
	};
}

//#endregion
//#region src/build.ts
async function createBuildContext({ emitter, outputDirectory, baseDirectory, configuration }) {
	const collector = createCollector(emitter, baseDirectory);
	const [writer, resolved, cacheManager] = await Promise.all([
		createWriter(outputDirectory),
		collector.collect(configuration.collections),
		createCacheManager(baseDirectory, configuration.checksum)
	]);
	return {
		resolved,
		writer,
		synchronizer: createSynchronizer(collector.collectFile, resolved, baseDirectory),
		transform: createTransformer(emitter, cacheManager),
		emitter,
		cacheManager,
		configuration
	};
}
async function build$1({ emitter, transform, resolved, writer, configuration }) {
	const startedAt = Date.now();
	emitter.emit("builder:start", { startedAt });
	const collections = await transform(resolved);
	await Promise.all([
		writer.createDataFiles(collections),
		writer.createTypeDefinitionFile(configuration),
		writer.createJavaScriptFile(configuration)
	]);
	const pendingOnSuccess = collections.filter((collection) => Boolean(collection.onSuccess)).map((collection) => collection.onSuccess?.(collection.documents.map((doc) => doc.document)));
	await Promise.all(pendingOnSuccess.filter(isDefined));
	const stats = collections.reduce((acc, collection) => {
		acc.collections++;
		acc.documents += collection.documents.length;
		return acc;
	}, {
		collections: 0,
		documents: 0
	});
	emitter.emit("builder:end", {
		startedAt,
		endedAt: Date.now(),
		stats
	});
}

//#endregion
//#region src/events.ts
function isEventWithError(event) {
	return typeof event === "object" && event !== null && "error" in event;
}
function createEmitter() {
	const emitter = new EventEmitter();
	function on(key, listener) {
		emitter.on(key, listener);
	}
	function emit(key, event) {
		emitter.emit(key, event);
		if (isEventWithError(event)) emitter.emit("_error", {
			...event,
			_event: key
		});
		emitter.emit("_all", {
			...event,
			_event: key
		});
	}
	return {
		on,
		emit
	};
}

//#endregion
//#region src/watcher.ts
async function createWatcher(emitter, baseDirectory, configuration, sync) {
	const paths = removeChildPaths([...configuration.collections.map((collection) => path.join(baseDirectory, collection.directory)).map((p) => resolve(p)), ...configuration.inputPaths.map((p) => dirname(p))]);
	const watcher = chokidar.watch(paths, {
		ignored: [/(^|[\/\\])\../, /(^|[\/\\])node_modules([\/\\]|$)/],
		persistent: true,
		ignoreInitial: true
	});
	const handleEvent = async (modification, filePath) => {
		try {
			await sync(modification, filePath);
		} catch (error) {
			emitter.emit("watcher:subscribe-error", {
				paths,
				error: toError(error)
			});
		}
	};
	watcher.on("add", (filePath) => handleEvent("create", filePath));
	watcher.on("change", (filePath) => handleEvent("update", filePath));
	watcher.on("unlink", (filePath) => handleEvent("delete", filePath));
	watcher.on("error", (error) => {
		emitter.emit("watcher:subscribe-error", {
			paths,
			error: toError(error)
		});
	});
	await new Promise((resolve$1, reject) => {
		watcher.on("ready", () => {
			emitter.emit("watcher:subscribed", { paths });
			resolve$1();
		});
		watcher.on("error", reject);
	});
	return { unsubscribe: async () => {
		await watcher.close();
		emitter.emit("watcher:unsubscribed", { paths });
	} };
}

//#endregion
//#region src/builder.ts
function resolveOutputDir(baseDirectory, options) {
	if (options.outputDir) return options.outputDir;
	return path.join(baseDirectory, ".content-collections", "generated");
}
var ConfigurationReloadError = class extends Error {
	constructor(message) {
		super(message);
	}
};
async function createBuilder(configurationPath, options = { configName: defaultConfigName }, emitter = createEmitter()) {
	const readConfiguration = createConfigurationReader();
	const baseDirectory = path.dirname(configurationPath);
	return createInternalBuilder(await readConfiguration(configurationPath, options), baseDirectory, options, emitter);
}
async function createInternalBuilder(initialConfiguration, baseDirectory, options, emitter) {
	const readConfiguration = createConfigurationReader();
	const configurationPath = initialConfiguration.path;
	const outputDirectory = resolveOutputDir(baseDirectory, options);
	emitter.emit("builder:created", {
		createdAt: Date.now(),
		configurationPath,
		outputDirectory
	});
	let configuration = initialConfiguration;
	let watcher = null;
	let context = await createBuildContext({
		emitter,
		baseDirectory,
		outputDirectory,
		configuration
	});
	async function sync(modification, filePath) {
		if (configuration.inputPaths.includes(filePath)) {
			if (await onConfigurationChange()) {
				emitter.emit("watcher:config-changed", {
					filePath,
					modification
				});
				await build$1(context);
				return true;
			}
		} else if (await onFileChange(modification, filePath)) {
			emitter.emit("watcher:file-changed", {
				filePath,
				modification
			});
			await build$1(context);
			return true;
		}
		return false;
	}
	async function onConfigurationChange() {
		try {
			configuration = await readConfiguration(configurationPath, options);
		} catch (error) {
			emitter.emit("watcher:config-reload-error", {
				error: new ConfigurationReloadError(`Failed to reload configuration: ${error}`),
				configurationPath
			});
			return false;
		}
		if (watcher) await watcher.unsubscribe();
		context = await createBuildContext({
			emitter,
			baseDirectory,
			outputDirectory,
			configuration
		});
		if (watcher) watcher = await createWatcher(emitter, baseDirectory, configuration, sync);
		return true;
	}
	async function onFileChange(modification, filePath) {
		const { synchronizer } = context;
		if (modification === "delete") return synchronizer.deleted(filePath);
		else return synchronizer.changed(filePath);
	}
	async function watch() {
		watcher = await createWatcher(emitter, baseDirectory, configuration, sync);
		return { unsubscribe: async () => {
			if (watcher) await watcher.unsubscribe();
		} };
	}
	return {
		build: () => build$1(context),
		sync,
		watch,
		on: emitter.on
	};
}

//#endregion
export { CollectError, ConfigurationError, ConfigurationReloadError, TransformError, createBuilder, createDefaultImport, createInternalBuilder, createNamedImport, defineCollection, defineConfig, defineParser, skippedSymbol, suppressDeprecatedWarnings };