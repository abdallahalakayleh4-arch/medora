import { BaseSummarizeAdapter } from "@tanstack/ai/adapters";
import { createAnthropicClient, generateId, getAnthropicApiKeyFromEnv } from "../utils/client.js";
class AnthropicSummarizeAdapter extends BaseSummarizeAdapter {
  constructor(config, model) {
    super({}, model);
    this.kind = "summarize";
    this.name = "anthropic";
    this.client = createAnthropicClient(config);
  }
  async summarize(options) {
    const systemPrompt = this.buildSummarizationPrompt(options);
    const response = await this.client.messages.create({
      model: options.model,
      messages: [{ role: "user", content: options.text }],
      system: systemPrompt,
      max_tokens: options.maxLength || 500,
      temperature: 0.3,
      stream: false
    });
    const content = response.content.map((c) => c.type === "text" ? c.text : "").join("");
    return {
      id: response.id,
      model: response.model,
      summary: content,
      usage: {
        promptTokens: response.usage.input_tokens,
        completionTokens: response.usage.output_tokens,
        totalTokens: response.usage.input_tokens + response.usage.output_tokens
      }
    };
  }
  async *summarizeStream(options) {
    const systemPrompt = this.buildSummarizationPrompt(options);
    const id = generateId(this.name);
    const model = options.model;
    let accumulatedContent = "";
    let inputTokens = 0;
    let outputTokens = 0;
    const stream = await this.client.messages.create({
      model: options.model,
      messages: [{ role: "user", content: options.text }],
      system: systemPrompt,
      max_tokens: options.maxLength || 500,
      temperature: 0.3,
      stream: true
    });
    for await (const event of stream) {
      if (event.type === "message_start") {
        inputTokens = event.message.usage.input_tokens;
      } else if (event.type === "content_block_delta") {
        if (event.delta.type === "text_delta") {
          const delta = event.delta.text;
          accumulatedContent += delta;
          yield {
            type: "TEXT_MESSAGE_CONTENT",
            messageId: id,
            model,
            timestamp: Date.now(),
            delta,
            content: accumulatedContent
          };
        }
      } else if (event.type === "message_delta") {
        outputTokens = event.usage.output_tokens;
        yield {
          type: "RUN_FINISHED",
          runId: id,
          model,
          timestamp: Date.now(),
          finishReason: event.delta.stop_reason,
          usage: {
            promptTokens: inputTokens,
            completionTokens: outputTokens,
            totalTokens: inputTokens + outputTokens
          }
        };
      }
    }
  }
  buildSummarizationPrompt(options) {
    let prompt = "You are a professional summarizer. ";
    switch (options.style) {
      case "bullet-points":
        prompt += "Provide a summary in bullet point format. ";
        break;
      case "paragraph":
        prompt += "Provide a summary in paragraph format. ";
        break;
      case "concise":
        prompt += "Provide a very concise summary in 1-2 sentences. ";
        break;
      default:
        prompt += "Provide a clear and concise summary. ";
    }
    if (options.focus && options.focus.length > 0) {
      prompt += `Focus on the following aspects: ${options.focus.join(", ")}. `;
    }
    if (options.maxLength) {
      prompt += `Keep the summary under ${options.maxLength} tokens. `;
    }
    return prompt;
  }
}
function createAnthropicSummarize(model, apiKey, config) {
  return new AnthropicSummarizeAdapter({ apiKey, ...config }, model);
}
function anthropicSummarize(model, config) {
  const apiKey = getAnthropicApiKeyFromEnv();
  return createAnthropicSummarize(model, apiKey, config);
}
export {
  AnthropicSummarizeAdapter,
  anthropicSummarize,
  createAnthropicSummarize
};
//# sourceMappingURL=summarize.js.map
