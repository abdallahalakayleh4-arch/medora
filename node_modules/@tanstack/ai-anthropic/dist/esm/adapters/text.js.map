{"version":3,"file":"text.js","sources":["../../../src/adapters/text.ts"],"sourcesContent":["import { BaseTextAdapter } from '@tanstack/ai/adapters'\nimport { convertToolsToProviderFormat } from '../tools/tool-converter'\nimport { validateTextProviderOptions } from '../text/text-provider-options'\nimport {\n  createAnthropicClient,\n  generateId,\n  getAnthropicApiKeyFromEnv,\n} from '../utils'\nimport type {\n  ANTHROPIC_MODELS,\n  AnthropicChatModelProviderOptionsByName,\n  AnthropicModelInputModalitiesByName,\n} from '../model-meta'\nimport type {\n  StructuredOutputOptions,\n  StructuredOutputResult,\n} from '@tanstack/ai/adapters'\nimport type {\n  Base64ImageSource,\n  Base64PDFSource,\n  DocumentBlockParam,\n  ImageBlockParam,\n  MessageParam,\n  TextBlockParam,\n  URLImageSource,\n  URLPDFSource,\n} from '@anthropic-ai/sdk/resources/messages'\nimport type Anthropic_SDK from '@anthropic-ai/sdk'\nimport type {\n  ContentPart,\n  Modality,\n  ModelMessage,\n  StreamChunk,\n  TextOptions,\n} from '@tanstack/ai'\nimport type {\n  ExternalTextProviderOptions,\n  InternalTextProviderOptions,\n} from '../text/text-provider-options'\nimport type {\n  AnthropicDocumentMetadata,\n  AnthropicImageMetadata,\n  AnthropicMessageMetadataByModality,\n  AnthropicTextMetadata,\n} from '../message-types'\nimport type { AnthropicClientConfig } from '../utils'\n\n/**\n * Configuration for Anthropic text adapter\n */\nexport interface AnthropicTextConfig extends AnthropicClientConfig {}\n\n/**\n * Anthropic-specific provider options for text/chat\n */\nexport type AnthropicTextProviderOptions = ExternalTextProviderOptions\n\ntype AnthropicContentBlocks =\n  Extract<MessageParam['content'], Array<unknown>> extends Array<infer Block>\n    ? Array<Block>\n    : never\ntype AnthropicContentBlock =\n  AnthropicContentBlocks extends Array<infer Block> ? Block : never\n\n// ===========================\n// Type Resolution Helpers\n// ===========================\n\n/**\n * Resolve provider options for a specific model.\n * If the model has explicit options in the map, use those; otherwise use base options.\n */\ntype ResolveProviderOptions<TModel extends string> =\n  TModel extends keyof AnthropicChatModelProviderOptionsByName\n    ? AnthropicChatModelProviderOptionsByName[TModel]\n    : AnthropicTextProviderOptions\n\n/**\n * Resolve input modalities for a specific model.\n * If the model has explicit modalities in the map, use those; otherwise use default.\n */\ntype ResolveInputModalities<TModel extends string> =\n  TModel extends keyof AnthropicModelInputModalitiesByName\n    ? AnthropicModelInputModalitiesByName[TModel]\n    : readonly ['text', 'image', 'document']\n\n// ===========================\n// Adapter Implementation\n// ===========================\n\n/**\n * Anthropic Text (Chat) Adapter\n *\n * Tree-shakeable adapter for Anthropic chat/text completion functionality.\n * Import only what you need for smaller bundle sizes.\n */\nexport class AnthropicTextAdapter<\n  TModel extends (typeof ANTHROPIC_MODELS)[number],\n  TProviderOptions extends object = ResolveProviderOptions<TModel>,\n  TInputModalities extends ReadonlyArray<Modality> =\n    ResolveInputModalities<TModel>,\n> extends BaseTextAdapter<\n  TModel,\n  TProviderOptions,\n  TInputModalities,\n  AnthropicMessageMetadataByModality\n> {\n  readonly kind = 'text' as const\n  readonly name = 'anthropic' as const\n\n  private client: Anthropic_SDK\n\n  constructor(config: AnthropicTextConfig, model: TModel) {\n    super({}, model)\n    this.client = createAnthropicClient(config)\n  }\n\n  async *chatStream(\n    options: TextOptions<AnthropicTextProviderOptions>,\n  ): AsyncIterable<StreamChunk> {\n    try {\n      const requestParams = this.mapCommonOptionsToAnthropic(options)\n\n      const stream = await this.client.beta.messages.create(\n        { ...requestParams, stream: true },\n        {\n          signal: options.request?.signal,\n          headers: options.request?.headers,\n        },\n      )\n\n      yield* this.processAnthropicStream(stream, options.model, () =>\n        generateId(this.name),\n      )\n    } catch (error: unknown) {\n      const err = error as Error & { status?: number; code?: string }\n      yield {\n        type: 'RUN_ERROR',\n        model: options.model,\n        timestamp: Date.now(),\n        error: {\n          message: err.message || 'Unknown error occurred',\n          code: err.code || String(err.status),\n        },\n      }\n    }\n  }\n\n  /**\n   * Generate structured output using Anthropic's tool-based approach.\n   * Anthropic doesn't have native structured output, so we use a tool with the schema\n   * and force the model to call it.\n   * The outputSchema is already JSON Schema (converted in the ai layer).\n   */\n  async structuredOutput(\n    options: StructuredOutputOptions<AnthropicTextProviderOptions>,\n  ): Promise<StructuredOutputResult<unknown>> {\n    const { chatOptions, outputSchema } = options\n\n    const requestParams = this.mapCommonOptionsToAnthropic(chatOptions)\n\n    // Create a tool that will capture the structured output\n    // Anthropic's SDK requires input_schema with type: 'object' literal\n    const structuredOutputTool = {\n      name: 'structured_output',\n      description:\n        'Use this tool to provide your response in the required structured format.',\n      input_schema: {\n        type: 'object' as const,\n        properties: outputSchema.properties ?? {},\n        required: outputSchema.required ?? [],\n      },\n    }\n\n    try {\n      // Make non-streaming request with tool_choice forced to our structured output tool\n      const response = await this.client.messages.create(\n        {\n          ...requestParams,\n          stream: false,\n          tools: [structuredOutputTool],\n          tool_choice: { type: 'tool', name: 'structured_output' },\n        },\n        {\n          signal: chatOptions.request?.signal,\n          headers: chatOptions.request?.headers,\n        },\n      )\n\n      // Extract the tool use content from the response\n      let parsed: unknown = null\n      let rawText = ''\n\n      for (const block of response.content) {\n        if (block.type === 'tool_use' && block.name === 'structured_output') {\n          parsed = block.input\n          rawText = JSON.stringify(block.input)\n          break\n        }\n      }\n\n      if (parsed === null) {\n        // Fallback: try to extract text content and parse as JSON\n        rawText = response.content\n          .map((b) => {\n            if (b.type === 'text') {\n              return b.text\n            }\n            return ''\n          })\n          .join('')\n        try {\n          parsed = JSON.parse(rawText)\n        } catch {\n          throw new Error(\n            `Failed to extract structured output from response. Content: ${rawText.slice(0, 200)}${rawText.length > 200 ? '...' : ''}`,\n          )\n        }\n      }\n\n      return {\n        data: parsed,\n        rawText,\n      }\n    } catch (error: unknown) {\n      const err = error as Error\n      throw new Error(\n        `Structured output generation failed: ${err.message || 'Unknown error occurred'}`,\n      )\n    }\n  }\n\n  private mapCommonOptionsToAnthropic(\n    options: TextOptions<AnthropicTextProviderOptions>,\n  ) {\n    const modelOptions = options.modelOptions as\n      | InternalTextProviderOptions\n      | undefined\n\n    const formattedMessages = this.formatMessages(options.messages)\n    const tools = options.tools\n      ? convertToolsToProviderFormat(options.tools)\n      : undefined\n\n    const validProviderOptions: Partial<InternalTextProviderOptions> = {}\n    if (modelOptions) {\n      const validKeys: Array<keyof InternalTextProviderOptions> = [\n        'container',\n        'context_management',\n        'effort',\n        'mcp_servers',\n        'service_tier',\n        'stop_sequences',\n        'system',\n        'thinking',\n        'tool_choice',\n        'top_k',\n      ]\n      for (const key of validKeys) {\n        if (key in modelOptions) {\n          const value = modelOptions[key]\n          if (key === 'tool_choice' && typeof value === 'string') {\n            ;(validProviderOptions as Record<string, unknown>)[key] = {\n              type: value,\n            }\n          } else {\n            ;(validProviderOptions as Record<string, unknown>)[key] = value\n          }\n        }\n      }\n    }\n\n    const thinkingBudget =\n      validProviderOptions.thinking?.type === 'enabled'\n        ? validProviderOptions.thinking.budget_tokens\n        : undefined\n    const defaultMaxTokens = options.maxTokens || 1024\n    const maxTokens =\n      thinkingBudget && thinkingBudget >= defaultMaxTokens\n        ? thinkingBudget + 1\n        : defaultMaxTokens\n\n    const requestParams: InternalTextProviderOptions = {\n      model: options.model,\n      max_tokens: maxTokens,\n      temperature: options.temperature,\n      top_p: options.topP,\n      messages: formattedMessages,\n      system: options.systemPrompts?.join('\\n'),\n      tools: tools,\n      ...validProviderOptions,\n    }\n    validateTextProviderOptions(requestParams)\n    return requestParams\n  }\n\n  private convertContentPartToAnthropic(\n    part: ContentPart,\n  ): TextBlockParam | ImageBlockParam | DocumentBlockParam {\n    switch (part.type) {\n      case 'text': {\n        const metadata = part.metadata as AnthropicTextMetadata | undefined\n        return {\n          type: 'text',\n          text: part.content,\n          ...metadata,\n        }\n      }\n\n      case 'image': {\n        const metadata = part.metadata as AnthropicImageMetadata | undefined\n        const imageSource: Base64ImageSource | URLImageSource =\n          part.source.type === 'data'\n            ? {\n                type: 'base64',\n                data: part.source.value,\n                media_type: part.source.mimeType as\n                  | 'image/jpeg'\n                  | 'image/png'\n                  | 'image/gif'\n                  | 'image/webp',\n              }\n            : {\n                type: 'url',\n                url: part.source.value,\n              }\n        return {\n          type: 'image',\n          source: imageSource,\n          ...metadata,\n        }\n      }\n      case 'document': {\n        const metadata = part.metadata as AnthropicDocumentMetadata | undefined\n        const docSource: Base64PDFSource | URLPDFSource =\n          part.source.type === 'data'\n            ? {\n                type: 'base64',\n                data: part.source.value,\n                media_type: part.source.mimeType as 'application/pdf',\n              }\n            : {\n                type: 'url',\n                url: part.source.value,\n              }\n        return {\n          type: 'document',\n          source: docSource,\n          ...metadata,\n        }\n      }\n      case 'audio':\n      case 'video':\n        throw new Error(\n          `Anthropic does not support ${part.type} content directly`,\n        )\n      default: {\n        const _exhaustiveCheck: never = part\n        throw new Error(\n          `Unsupported content part type: ${(_exhaustiveCheck as ContentPart).type}`,\n        )\n      }\n    }\n  }\n\n  private formatMessages(\n    messages: Array<ModelMessage>,\n  ): InternalTextProviderOptions['messages'] {\n    const formattedMessages: InternalTextProviderOptions['messages'] = []\n\n    for (const message of messages) {\n      const role = message.role\n\n      if (role === 'tool' && message.toolCallId) {\n        formattedMessages.push({\n          role: 'user',\n          content: [\n            {\n              type: 'tool_result',\n              tool_use_id: message.toolCallId,\n              content:\n                typeof message.content === 'string' ? message.content : '',\n            },\n          ],\n        })\n        continue\n      }\n\n      if (role === 'assistant' && message.toolCalls?.length) {\n        const contentBlocks: AnthropicContentBlocks = []\n\n        if (message.content) {\n          const content =\n            typeof message.content === 'string' ? message.content : ''\n          const textBlock: AnthropicContentBlock = {\n            type: 'text',\n            text: content,\n          }\n          contentBlocks.push(textBlock)\n        }\n\n        for (const toolCall of message.toolCalls) {\n          let parsedInput: unknown = {}\n          try {\n            const parsed = toolCall.function.arguments\n              ? JSON.parse(toolCall.function.arguments)\n              : {}\n            parsedInput = parsed && typeof parsed === 'object' ? parsed : {}\n          } catch {\n            parsedInput = toolCall.function.arguments\n          }\n\n          const toolUseBlock: AnthropicContentBlock = {\n            type: 'tool_use',\n            id: toolCall.id,\n            name: toolCall.function.name,\n            input: parsedInput,\n          }\n          contentBlocks.push(toolUseBlock)\n        }\n\n        formattedMessages.push({\n          role: 'assistant',\n          content: contentBlocks,\n        })\n\n        continue\n      }\n\n      if (role === 'user' && Array.isArray(message.content)) {\n        const contentBlocks = message.content.map((part) =>\n          this.convertContentPartToAnthropic(part),\n        )\n        formattedMessages.push({\n          role: 'user',\n          content: contentBlocks,\n        })\n        continue\n      }\n\n      formattedMessages.push({\n        role: role === 'assistant' ? 'assistant' : 'user',\n        content:\n          typeof message.content === 'string'\n            ? message.content\n            : message.content\n              ? message.content.map((c) =>\n                  this.convertContentPartToAnthropic(c),\n                )\n              : '',\n      })\n    }\n\n    // Post-process: Anthropic requires strictly alternating user/assistant roles.\n    // Tool results are sent as role:'user' messages, which can create consecutive\n    // user messages when followed by a new user message. Merge them.\n    return this.mergeConsecutiveSameRoleMessages(formattedMessages)\n  }\n\n  /**\n   * Merge consecutive messages of the same role into a single message.\n   * Anthropic's API requires strictly alternating user/assistant roles.\n   * Tool results are wrapped as role:'user' messages, which can collide\n   * with actual user messages in multi-turn conversations.\n   *\n   * Also filters out empty assistant messages (e.g., from a previous failed request).\n   */\n  private mergeConsecutiveSameRoleMessages(\n    messages: InternalTextProviderOptions['messages'],\n  ): InternalTextProviderOptions['messages'] {\n    const merged: InternalTextProviderOptions['messages'] = []\n\n    for (const msg of messages) {\n      // Skip empty assistant messages (no content or empty string)\n      if (msg.role === 'assistant') {\n        const hasContent = Array.isArray(msg.content)\n          ? msg.content.length > 0\n          : typeof msg.content === 'string' && msg.content.length > 0\n        if (!hasContent) {\n          continue\n        }\n      }\n\n      const prev = merged[merged.length - 1]\n      if (prev && prev.role === msg.role) {\n        // Normalize both contents to arrays and concatenate\n        const prevBlocks = Array.isArray(prev.content)\n          ? prev.content\n          : typeof prev.content === 'string' && prev.content\n            ? [{ type: 'text' as const, text: prev.content }]\n            : []\n        const msgBlocks = Array.isArray(msg.content)\n          ? msg.content\n          : typeof msg.content === 'string' && msg.content\n            ? [{ type: 'text' as const, text: msg.content }]\n            : []\n        prev.content = [...prevBlocks, ...msgBlocks]\n      } else {\n        merged.push({ ...msg })\n      }\n    }\n\n    // De-duplicate tool_result blocks with the same tool_use_id.\n    // This can happen when the core layer generates tool results from both\n    // the tool-result part and the tool-call part's output field.\n    for (const msg of merged) {\n      if (Array.isArray(msg.content)) {\n        const seenToolResultIds = new Set<string>()\n        msg.content = msg.content.filter((block: any) => {\n          if (block.type === 'tool_result' && block.tool_use_id) {\n            if (seenToolResultIds.has(block.tool_use_id)) {\n              return false // Remove duplicate\n            }\n            seenToolResultIds.add(block.tool_use_id)\n          }\n          return true\n        })\n      }\n    }\n\n    return merged\n  }\n\n  private async *processAnthropicStream(\n    stream: AsyncIterable<Anthropic_SDK.Beta.BetaRawMessageStreamEvent>,\n    model: string,\n    genId: () => string,\n  ): AsyncIterable<StreamChunk> {\n    let accumulatedContent = ''\n    let accumulatedThinking = ''\n    const timestamp = Date.now()\n    const toolCallsMap = new Map<\n      number,\n      { id: string; name: string; input: string; started: boolean }\n    >()\n    let currentToolIndex = -1\n\n    // AG-UI lifecycle tracking\n    const runId = genId()\n    const messageId = genId()\n    let stepId: string | null = null\n    let hasEmittedRunStarted = false\n    let hasEmittedTextMessageStart = false\n    let hasEmittedRunFinished = false\n    // Track current content block type for proper content_block_stop handling\n    let currentBlockType: string | null = null\n\n    try {\n      for await (const event of stream) {\n        // Emit RUN_STARTED on first event\n        if (!hasEmittedRunStarted) {\n          hasEmittedRunStarted = true\n          yield {\n            type: 'RUN_STARTED',\n            runId,\n            model,\n            timestamp,\n          }\n        }\n\n        if (event.type === 'content_block_start') {\n          currentBlockType = event.content_block.type\n          if (event.content_block.type === 'tool_use') {\n            currentToolIndex++\n            toolCallsMap.set(currentToolIndex, {\n              id: event.content_block.id,\n              name: event.content_block.name,\n              input: '',\n              started: false,\n            })\n          } else if (event.content_block.type === 'thinking') {\n            accumulatedThinking = ''\n            // Emit STEP_STARTED for thinking\n            stepId = genId()\n            yield {\n              type: 'STEP_STARTED',\n              stepId,\n              model,\n              timestamp,\n              stepType: 'thinking',\n            }\n          }\n        } else if (event.type === 'content_block_delta') {\n          if (event.delta.type === 'text_delta') {\n            // Emit TEXT_MESSAGE_START on first text content\n            if (!hasEmittedTextMessageStart) {\n              hasEmittedTextMessageStart = true\n              yield {\n                type: 'TEXT_MESSAGE_START',\n                messageId,\n                model,\n                timestamp,\n                role: 'assistant',\n              }\n            }\n\n            const delta = event.delta.text\n            accumulatedContent += delta\n            yield {\n              type: 'TEXT_MESSAGE_CONTENT',\n              messageId,\n              model,\n              timestamp,\n              delta,\n              content: accumulatedContent,\n            }\n          } else if (event.delta.type === 'thinking_delta') {\n            const delta = event.delta.thinking\n            accumulatedThinking += delta\n            yield {\n              type: 'STEP_FINISHED',\n              stepId: stepId || genId(),\n              model,\n              timestamp,\n              delta,\n              content: accumulatedThinking,\n            }\n          } else if (event.delta.type === 'input_json_delta') {\n            const existing = toolCallsMap.get(currentToolIndex)\n            if (existing) {\n              // Emit TOOL_CALL_START on first args delta\n              if (!existing.started) {\n                existing.started = true\n                yield {\n                  type: 'TOOL_CALL_START',\n                  toolCallId: existing.id,\n                  toolName: existing.name,\n                  model,\n                  timestamp,\n                  index: currentToolIndex,\n                }\n              }\n\n              existing.input += event.delta.partial_json\n\n              yield {\n                type: 'TOOL_CALL_ARGS',\n                toolCallId: existing.id,\n                model,\n                timestamp,\n                delta: event.delta.partial_json,\n                args: existing.input,\n              }\n            }\n          }\n        } else if (event.type === 'content_block_stop') {\n          if (currentBlockType === 'tool_use') {\n            const existing = toolCallsMap.get(currentToolIndex)\n            if (existing) {\n              // If tool call wasn't started yet (no args), start it now\n              if (!existing.started) {\n                existing.started = true\n                yield {\n                  type: 'TOOL_CALL_START',\n                  toolCallId: existing.id,\n                  toolName: existing.name,\n                  model,\n                  timestamp,\n                  index: currentToolIndex,\n                }\n              }\n\n              // Emit TOOL_CALL_END\n              let parsedInput: unknown = {}\n              try {\n                const parsed = existing.input ? JSON.parse(existing.input) : {}\n                parsedInput = parsed && typeof parsed === 'object' ? parsed : {}\n              } catch {\n                parsedInput = {}\n              }\n\n              yield {\n                type: 'TOOL_CALL_END',\n                toolCallId: existing.id,\n                toolName: existing.name,\n                model,\n                timestamp,\n                input: parsedInput,\n              }\n\n              // Reset so a new TEXT_MESSAGE_START is emitted if text follows tool calls\n              hasEmittedTextMessageStart = false\n            }\n          } else {\n            // Emit TEXT_MESSAGE_END only for text blocks (not tool_use blocks)\n            if (hasEmittedTextMessageStart && accumulatedContent) {\n              yield {\n                type: 'TEXT_MESSAGE_END',\n                messageId,\n                model,\n                timestamp,\n              }\n            }\n          }\n          currentBlockType = null\n        } else if (event.type === 'message_stop') {\n          // Only emit RUN_FINISHED from message_stop if message_delta didn't already emit one.\n          // message_delta carries the real stop_reason (tool_use, end_turn, etc.),\n          // while message_stop is just a completion signal.\n          if (!hasEmittedRunFinished) {\n            yield {\n              type: 'RUN_FINISHED',\n              runId,\n              model,\n              timestamp,\n              finishReason: 'stop',\n            }\n          }\n        } else if (event.type === 'message_delta') {\n          if (event.delta.stop_reason) {\n            hasEmittedRunFinished = true\n            switch (event.delta.stop_reason) {\n              case 'tool_use': {\n                yield {\n                  type: 'RUN_FINISHED',\n                  runId,\n                  model,\n                  timestamp,\n                  finishReason: 'tool_calls',\n                  usage: {\n                    promptTokens: event.usage.input_tokens || 0,\n                    completionTokens: event.usage.output_tokens || 0,\n                    totalTokens:\n                      (event.usage.input_tokens || 0) +\n                      (event.usage.output_tokens || 0),\n                  },\n                }\n                break\n              }\n              case 'max_tokens': {\n                yield {\n                  type: 'RUN_ERROR',\n                  runId,\n                  model,\n                  timestamp,\n                  error: {\n                    message:\n                      'The response was cut off because the maximum token limit was reached.',\n                    code: 'max_tokens',\n                  },\n                }\n                break\n              }\n              default: {\n                yield {\n                  type: 'RUN_FINISHED',\n                  runId,\n                  model,\n                  timestamp,\n                  finishReason: 'stop',\n                  usage: {\n                    promptTokens: event.usage.input_tokens || 0,\n                    completionTokens: event.usage.output_tokens || 0,\n                    totalTokens:\n                      (event.usage.input_tokens || 0) +\n                      (event.usage.output_tokens || 0),\n                  },\n                }\n              }\n            }\n          }\n        }\n      }\n    } catch (error: unknown) {\n      const err = error as Error & { status?: number; code?: string }\n\n      yield {\n        type: 'RUN_ERROR',\n        runId,\n        model,\n        timestamp,\n        error: {\n          message: err.message || 'Unknown error occurred',\n          code: err.code || String(err.status),\n        },\n      }\n    }\n  }\n}\n\n/**\n * Creates an Anthropic chat adapter with explicit API key.\n * Type resolution happens here at the call site.\n */\nexport function createAnthropicChat<\n  TModel extends (typeof ANTHROPIC_MODELS)[number],\n>(\n  model: TModel,\n  apiKey: string,\n  config?: Omit<AnthropicTextConfig, 'apiKey'>,\n): AnthropicTextAdapter<\n  TModel,\n  ResolveProviderOptions<TModel>,\n  ResolveInputModalities<TModel>\n> {\n  return new AnthropicTextAdapter({ apiKey, ...config }, model)\n}\n\n/**\n * Creates an Anthropic text adapter with automatic API key detection.\n * Type resolution happens here at the call site.\n */\nexport function anthropicText<TModel extends (typeof ANTHROPIC_MODELS)[number]>(\n  model: TModel,\n  config?: Omit<AnthropicTextConfig, 'apiKey'>,\n): AnthropicTextAdapter<\n  TModel,\n  ResolveProviderOptions<TModel>,\n  ResolveInputModalities<TModel>\n> {\n  const apiKey = getAnthropicApiKeyFromEnv()\n  return createAnthropicChat(model, apiKey, config)\n}\n"],"names":[],"mappings":"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"}