{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["import { fileURLToPath, pathToFileURL } from 'node:url'\n\nimport { logDiff } from '@tanstack/router-utils'\nimport { compileDirectives } from './compilers'\nimport type {\n  CompileDirectivesOpts,\n  DirectiveFn,\n  GenerateFunctionIdFn,\n} from './compilers'\nimport type { Plugin } from 'vite'\n\nconst debug =\n  process.env.TSR_VITE_DEBUG &&\n  ['true', 'directives-functions-plugin'].includes(process.env.TSR_VITE_DEBUG)\n\nexport type {\n  DirectiveFn,\n  CompileDirectivesOpts,\n  ReplacerFn,\n  GenerateFunctionIdFn,\n} from './compilers'\n\nexport type DirectiveFunctionsViteEnvOptions = Pick<\n  CompileDirectivesOpts,\n  'getRuntimeCode' | 'replacer'\n>\nexport type DirectiveFunctionsViteOptions = DirectiveFunctionsViteEnvOptions & {\n  directive: string\n  onDirectiveFnsById?: (directiveFnsById: Record<string, DirectiveFn>) => void\n  generateFunctionId: GenerateFunctionIdFn\n}\n\nconst createDirectiveRx = (directive: string) =>\n  new RegExp(`\"${directive}\"|'${directive}'`, 'gm')\n\nexport type DirectiveFunctionsVitePluginEnvOptions = {\n  directive: string\n  callers: Array<\n    DirectiveFunctionsViteEnvOptions & {\n      envName: string\n      envConsumer?: 'client' | 'server'\n    }\n  >\n  provider: DirectiveFunctionsViteEnvOptions & { envName: string }\n  onDirectiveFnsById?: (directiveFnsById: Record<string, DirectiveFn>) => void\n  generateFunctionId: GenerateFunctionIdFn\n  /**\n   * Returns the currently known directive functions from previous builds.\n   * Used by server callers to look up canonical extracted filenames,\n   * ensuring they import from the same extracted file as the client.\n   */\n  getKnownDirectiveFns?: () => Record<string, DirectiveFn>\n}\n\nfunction buildDirectiveSplitParam(directive: string) {\n  return `tsr-directive-${directive.replace(/[^a-zA-Z0-9]/g, '-')}`\n}\n\nexport function TanStackDirectiveFunctionsPluginEnv(\n  opts: DirectiveFunctionsVitePluginEnvOptions,\n): Plugin {\n  let root: string = process.cwd()\n\n  const directiveRx = createDirectiveRx(opts.directive)\n\n  const appliedEnvironments = new Set([\n    ...opts.callers.map((c) => c.envName),\n    opts.provider.envName,\n  ])\n\n  const directiveSplitParam = buildDirectiveSplitParam(opts.directive)\n\n  return {\n    name: 'tanstack-start-directive-vite-plugin',\n    enforce: 'pre',\n    buildStart() {\n      root = this.environment.config.root\n    },\n    applyToEnvironment(env) {\n      return appliedEnvironments.has(env.name)\n    },\n    transform: {\n      filter: {\n        code: directiveRx,\n      },\n      handler(code, id) {\n        const url = pathToFileURL(id)\n        url.searchParams.delete('v')\n        id = fileURLToPath(url).replace(/\\\\/g, '/')\n\n        const isDirectiveSplitParam = id.includes(directiveSplitParam)\n\n        let envOptions: DirectiveFunctionsViteEnvOptions & {\n          envName: string\n          envConsumer?: 'client' | 'server'\n        }\n        // Use provider options ONLY for extracted function files (files with directive split param)\n        // For all other files, use caller options even if we're in the provider environment\n        // This ensures route files reference extracted functions instead of duplicating implementations\n        if (isDirectiveSplitParam) {\n          envOptions = opts.provider\n          if (debug)\n            console.info(\n              `Compiling Directives for provider in environment ${envOptions.envName}: `,\n              id,\n            )\n        } else {\n          // For non-extracted files, use caller options based on current environment\n          const callerOptions = opts.callers.find(\n            (e) => e.envName === this.environment.name,\n          )\n          // If no caller is found for this environment (e.g., separate provider environment only processes extracted files),\n          // fall back to provider options\n          if (callerOptions) {\n            envOptions = callerOptions\n            if (debug)\n              console.info(\n                `Compiling Directives for caller in environment ${envOptions.envName}: `,\n                id,\n              )\n          } else {\n            envOptions = opts.provider\n            if (debug)\n              console.info(\n                `Compiling Directives for provider (fallback) in environment ${opts.provider.envName}: `,\n                id,\n              )\n          }\n        }\n        // Get known directive functions for looking up canonical extracted filenames\n        // This ensures SSR callers import from the same extracted file as the client\n        const knownDirectiveFns = opts.getKnownDirectiveFns?.()\n\n        // Determine if this is a client environment\n        const isClientEnvironment = envOptions.envConsumer === 'client'\n\n        const { compiledResult, directiveFnsById } = compileDirectives({\n          directive: opts.directive,\n          getRuntimeCode: envOptions.getRuntimeCode,\n          generateFunctionId: opts.generateFunctionId,\n          replacer: envOptions.replacer,\n          code,\n          root,\n          filename: id,\n          directiveSplitParam,\n          isDirectiveSplitParam,\n          knownDirectiveFns,\n          isClientEnvironment,\n        })\n        // when we process a file with a directive split param, we have already encountered the directives in that file\n        // (otherwise we wouldn't have gotten here)\n        if (!isDirectiveSplitParam) {\n          opts.onDirectiveFnsById?.(directiveFnsById)\n        }\n\n        if (debug) {\n          logDiff(code, compiledResult.code)\n          console.log('Output:\\n', compiledResult.code + '\\n\\n')\n        }\n\n        return compiledResult\n      },\n    },\n  }\n}\n"],"names":[],"mappings":";;;AAWA,MAAM,QACJ,QAAQ,IAAI,kBACZ,CAAC,QAAQ,6BAA6B,EAAE,SAAS,QAAQ,IAAI,cAAc;AAmB7E,MAAM,oBAAoB,CAAC,cACzB,IAAI,OAAO,IAAI,SAAS,MAAM,SAAS,KAAK,IAAI;AAqBlD,SAAS,yBAAyB,WAAmB;AACnD,SAAO,iBAAiB,UAAU,QAAQ,iBAAiB,GAAG,CAAC;AACjE;AAEO,SAAS,oCACd,MACQ;AACR,MAAI,OAAe,QAAQ,IAAA;AAE3B,QAAM,cAAc,kBAAkB,KAAK,SAAS;AAEpD,QAAM,0CAA0B,IAAI;AAAA,IAClC,GAAG,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO;AAAA,IACpC,KAAK,SAAS;AAAA,EAAA,CACf;AAED,QAAM,sBAAsB,yBAAyB,KAAK,SAAS;AAEnE,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,IACT,aAAa;AACX,aAAO,KAAK,YAAY,OAAO;AAAA,IACjC;AAAA,IACA,mBAAmB,KAAK;AACtB,aAAO,oBAAoB,IAAI,IAAI,IAAI;AAAA,IACzC;AAAA,IACA,WAAW;AAAA,MACT,QAAQ;AAAA,QACN,MAAM;AAAA,MAAA;AAAA,MAER,QAAQ,MAAM,IAAI;AAChB,cAAM,MAAM,cAAc,EAAE;AAC5B,YAAI,aAAa,OAAO,GAAG;AAC3B,aAAK,cAAc,GAAG,EAAE,QAAQ,OAAO,GAAG;AAE1C,cAAM,wBAAwB,GAAG,SAAS,mBAAmB;AAE7D,YAAI;AAOJ,YAAI,uBAAuB;AACzB,uBAAa,KAAK;AAClB,cAAI;AACF,oBAAQ;AAAA,cACN,oDAAoD,WAAW,OAAO;AAAA,cACtE;AAAA,YAAA;AAAA,QAEN,OAAO;AAEL,gBAAM,gBAAgB,KAAK,QAAQ;AAAA,YACjC,CAAC,MAAM,EAAE,YAAY,KAAK,YAAY;AAAA,UAAA;AAIxC,cAAI,eAAe;AACjB,yBAAa;AACb,gBAAI;AACF,sBAAQ;AAAA,gBACN,kDAAkD,WAAW,OAAO;AAAA,gBACpE;AAAA,cAAA;AAAA,UAEN,OAAO;AACL,yBAAa,KAAK;AAClB,gBAAI;AACF,sBAAQ;AAAA,gBACN,+DAA+D,KAAK,SAAS,OAAO;AAAA,gBACpF;AAAA,cAAA;AAAA,UAEN;AAAA,QACF;AAGA,cAAM,oBAAoB,KAAK,uBAAA;AAG/B,cAAM,sBAAsB,WAAW,gBAAgB;AAEvD,cAAM,EAAE,gBAAgB,iBAAA,IAAqB,kBAAkB;AAAA,UAC7D,WAAW,KAAK;AAAA,UAChB,gBAAgB,WAAW;AAAA,UAC3B,oBAAoB,KAAK;AAAA,UACzB,UAAU,WAAW;AAAA,UACrB;AAAA,UACA;AAAA,UACA,UAAU;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QAAA,CACD;AAGD,YAAI,CAAC,uBAAuB;AAC1B,eAAK,qBAAqB,gBAAgB;AAAA,QAC5C;AAEA,YAAI,OAAO;AACT,kBAAQ,MAAM,eAAe,IAAI;AACjC,kBAAQ,IAAI,aAAa,eAAe,OAAO,MAAM;AAAA,QACvD;AAEA,eAAO;AAAA,MACT;AAAA,IAAA;AAAA,EACF;AAEJ;"}