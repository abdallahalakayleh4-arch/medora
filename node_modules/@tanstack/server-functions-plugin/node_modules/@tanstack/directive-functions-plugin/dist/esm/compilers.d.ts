import { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils';
import * as babel from '@babel/core';
export interface DirectiveFn {
    nodePath: SupportedFunctionPath;
    functionName: string;
    functionId: string;
    extractedFilename: string;
    filename: string;
    chunkName: string;
    /**
     * True when this function was discovered by the client build.
     * Used to restrict HTTP access to only client-referenced functions.
     */
    isClientReferenced?: boolean;
}
export type SupportedFunctionPath = babel.NodePath<babel.types.FunctionDeclaration> | babel.NodePath<babel.types.FunctionExpression> | babel.NodePath<babel.types.ArrowFunctionExpression>;
export type GenerateFunctionIdFn = (opts: {
    filename: string;
    functionName: string;
    extractedFilename: string;
}) => string;
export type ReplacerFn = (opts: {
    fn: string;
    extractedFilename: string;
    filename: string;
    functionId: string;
    functionName: string;
    isSourceFn: boolean;
    /**
     * True when this function was already discovered by a previous build (e.g., client).
     * For SSR callers, this means the function is in the manifest and doesn't need
     * an importer - the manifest lookup will find it.
     */
    isClientReferenced: boolean;
}) => string;
export type CompileDirectivesOpts = ParseAstOptions & {
    directive: string;
    getRuntimeCode?: (opts: {
        directiveFnsById: Record<string, DirectiveFn>;
    }) => string;
    generateFunctionId: GenerateFunctionIdFn;
    replacer: ReplacerFn;
    filename: string;
    root: string;
    isDirectiveSplitParam: boolean;
    directiveSplitParam: string;
    /**
     * Previously discovered directive functions from other builds (e.g., client build).
     * When provided, the compiler will use the canonical extractedFilename from this
     * registry instead of computing it locally. This ensures SSR callers import from
     * the same extracted file as the client.
     */
    knownDirectiveFns?: Record<string, DirectiveFn>;
    /**
     * Whether the current environment is a client environment.
     * Functions discovered in client environments are always client-referenced.
     */
    isClientEnvironment?: boolean;
};
export declare function compileDirectives(opts: CompileDirectivesOpts): {
    compiledResult: GeneratorResult;
    directiveFnsById: Record<string, DirectiveFn>;
};
export declare function findDirectives(ast: babel.types.File, opts: ParseAstOptions & {
    directive: string;
    replacer?: ReplacerFn;
    generateFunctionId: GenerateFunctionIdFn;
    directiveSplitParam: string;
    filename: string;
    root: string;
    isDirectiveSplitParam: boolean;
    knownDirectiveFns?: Record<string, DirectiveFn>;
    isClientEnvironment?: boolean;
}): Record<string, DirectiveFn>;
