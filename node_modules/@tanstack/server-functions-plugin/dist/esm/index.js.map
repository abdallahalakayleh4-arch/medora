{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["/// <reference types=\"vite/client\" />\nimport crypto from 'node:crypto'\nimport assert from 'node:assert'\nimport { TanStackDirectiveFunctionsPluginEnv } from '@tanstack/directive-functions-plugin'\nimport type { Plugin } from 'vite'\nimport type {\n  DirectiveFn,\n  GenerateFunctionIdFn,\n  ReplacerFn,\n} from '@tanstack/directive-functions-plugin'\n\nexport type GenerateFunctionIdFnOptional = (\n  opts: Omit<Parameters<GenerateFunctionIdFn>[0], 'extractedFilename'>,\n) => string | undefined\n\nexport type TanStackServerFnPluginOpts = {\n  /**\n   * This virtual import ID will be used in the server build to import the manifest\n   * and its modules.\n   */\n  manifestVirtualImportId: string\n  generateFunctionId?: GenerateFunctionIdFnOptional\n  callers: Array<\n    ServerFnPluginEnvOpts & {\n      envConsumer: 'client' | 'server'\n      /**\n       * Custom getServerFnById implementation for server callers.\n       * Required for server callers that need to load modules from a different\n       * environment.\n       */\n      getServerFnById?: string\n    }\n  >\n  provider: ServerFnPluginEnvOpts\n  directive: string\n}\n\nexport type ServerFnPluginEnvOpts = {\n  getRuntimeCode: () => string\n  replacer: ReplacerFn\n  envName: string\n}\n\nconst debug =\n  process.env.TSR_VITE_DEBUG &&\n  ['true', 'server-functions-plugin'].includes(process.env.TSR_VITE_DEBUG)\n\nconst validateServerFnIdVirtualModule = `virtual:tanstack-start-validate-server-fn-id`\n\nfunction parseIdQuery(id: string): {\n  filename: string\n  query: {\n    [k: string]: string\n  }\n} {\n  if (!id.includes('?')) return { filename: id, query: {} }\n  const [filename, rawQuery] = id.split(`?`, 2) as [string, string]\n  const query = Object.fromEntries(new URLSearchParams(rawQuery))\n  return { filename, query }\n}\n\nexport function TanStackServerFnPlugin(\n  opts: TanStackServerFnPluginOpts,\n): Array<Plugin> {\n  const directiveFnsById: Record<string, DirectiveFn> = {}\n\n  const onDirectiveFnsById = (d: Record<string, DirectiveFn>) => {\n    if (debug) {\n      console.info(`onDirectiveFnsById received: `, d)\n    }\n    Object.assign(directiveFnsById, d)\n    if (debug) {\n      console.info(`directiveFnsById after update: `, directiveFnsById)\n    }\n  }\n\n  const entryIdToFunctionId = new Map<string, string>()\n  const functionIds = new Set<string>()\n\n  function withTrailingSlash(path: string): string {\n    if (path[path.length - 1] !== '/') {\n      return `${path}/`\n    }\n    return path\n  }\n\n  let root = process.cwd()\n  let command: 'build' | 'serve' = 'build'\n\n  const generateFunctionId: GenerateFunctionIdFn = ({\n    extractedFilename,\n    functionName,\n    filename,\n  }) => {\n    if (command === 'serve') {\n      const rootWithTrailingSlash = withTrailingSlash(root)\n      let file = extractedFilename\n      if (extractedFilename.startsWith(rootWithTrailingSlash)) {\n        file = extractedFilename.slice(rootWithTrailingSlash.length)\n      }\n      file = `/@id/${file}`\n\n      const serverFn: {\n        file: string\n        export: string\n      } = {\n        file,\n        export: functionName,\n      }\n      const base64 = Buffer.from(JSON.stringify(serverFn), 'utf8').toString(\n        'base64url',\n      )\n      return base64\n    }\n\n    // production build allows to override the function ID generation\n    const entryId = `${filename}--${functionName}`\n    let functionId = entryIdToFunctionId.get(entryId)\n    if (functionId === undefined) {\n      if (opts.generateFunctionId) {\n        functionId = opts.generateFunctionId({\n          functionName,\n          filename,\n        })\n      }\n      if (!functionId) {\n        functionId = crypto.createHash('sha256').update(entryId).digest('hex')\n      }\n      // Deduplicate in case the generated id conflicts with an existing id\n      if (functionIds.has(functionId)) {\n        let deduplicatedId\n        let iteration = 0\n        do {\n          deduplicatedId = `${functionId}_${++iteration}`\n        } while (functionIds.has(deduplicatedId))\n        functionId = deduplicatedId\n      }\n      entryIdToFunctionId.set(entryId, functionId)\n      functionIds.add(functionId)\n    }\n    return functionId\n  }\n\n  const resolvedManifestVirtualImportId = resolveViteId(\n    opts.manifestVirtualImportId,\n  )\n\n  const appliedEnvironments = new Set([\n    ...opts.callers\n      .filter((c) => c.envConsumer === 'server')\n      .map((c) => c.envName),\n    opts.provider.envName,\n  ])\n\n  const serverCallerEnvironments = new Map(\n    opts.callers\n      .filter((c) => c.envConsumer === 'server')\n      .map((c) => [c.envName, c]),\n  )\n\n  // SSR is the provider when the provider environment is also a server caller environment\n  // In this case, server-only-referenced functions won't be in the manifest (they're handled via direct imports)\n  // When SSR is NOT the provider, server-only-referenced functions ARE in the manifest and need isClientReferenced check\n  const ssrIsProvider = serverCallerEnvironments.has(opts.provider.envName)\n\n  return [\n    // The client plugin is used to compile the client directives\n    // and save them so we can create a manifest\n    TanStackDirectiveFunctionsPluginEnv({\n      directive: opts.directive,\n      onDirectiveFnsById,\n      generateFunctionId,\n      provider: opts.provider,\n      callers: opts.callers,\n      // Provide access to known directive functions so SSR callers can use\n      // canonical extracted filenames from the client build\n      getKnownDirectiveFns: () => directiveFnsById,\n    }),\n    {\n      name: 'tanstack-start-server-fn-vite-plugin-validate-serverfn-id',\n      apply: 'serve',\n      load: {\n        filter: {\n          id: new RegExp(resolveViteId(validateServerFnIdVirtualModule)),\n        },\n        handler(id) {\n          const parsed = parseIdQuery(id)\n          assert(parsed)\n          assert(parsed.query.id)\n          if (directiveFnsById[parsed.query.id]) {\n            return `export {}`\n          }\n          this.error(`Invalid server function ID: ${parsed.query.id}`)\n        },\n      },\n    },\n    {\n      // On the server, we need to be able to read the server-function manifest from the client build.\n      // This is likely used in the handler for server functions, so we can find the server function\n      // by its ID, import it, and call it.\n      name: 'tanstack-start-server-fn-vite-plugin-manifest-server',\n      enforce: 'pre',\n      applyToEnvironment: (env) => {\n        return appliedEnvironments.has(env.name)\n      },\n      configResolved(config) {\n        root = config.root\n        command = config.command\n      },\n      resolveId: {\n        filter: { id: new RegExp(opts.manifestVirtualImportId) },\n        handler() {\n          return resolvedManifestVirtualImportId\n        },\n      },\n      load: {\n        filter: { id: new RegExp(resolvedManifestVirtualImportId) },\n        handler() {\n          // a different server side environment is used for e.g. SSR and server functions\n          if (this.environment.name !== opts.provider.envName) {\n            const getServerFnById = serverCallerEnvironments.get(\n              this.environment.name,\n            )?.getServerFnById\n            if (!getServerFnById) {\n              throw new Error(\n                `No getServerFnById implementation found for environment ${this.environment.name}`,\n              )\n            }\n\n            return getServerFnById\n          }\n\n          if (this.environment.mode !== 'build') {\n            const mod = `\n            export async function getServerFnById(id) {\n              const validateIdImport = ${JSON.stringify(validateServerFnIdVirtualModule)} + '?id=' + id\n              await import(/* @vite-ignore */ '/@id/__x00__' + validateIdImport)\n              const decoded = Buffer.from(id, 'base64url').toString('utf8')\n              const devServerFn = JSON.parse(decoded)\n              const mod = await import(/* @vite-ignore */ devServerFn.file)\n              return mod[devServerFn.export]\n            }\n            `\n            return mod\n          }\n\n          // When SSR is the provider, server-only-referenced functions aren't in the manifest,\n          // so no isClientReferenced check is needed.\n          // When SSR is NOT the provider (custom provider env), server-only-referenced\n          // functions ARE in the manifest and need the isClientReferenced check to\n          // block direct client HTTP requests to server-only-referenced functions.\n          const includeClientReferencedCheck = !ssrIsProvider\n          return generateManifestModule(\n            directiveFnsById,\n            includeClientReferencedCheck,\n          )\n        },\n      },\n    },\n  ]\n}\n\n/**\n * Generates the manifest module code for server functions.\n * @param directiveFnsById - Map of function IDs to their directive function info\n * @param includeClientReferencedCheck - Whether to include isClientReferenced flag and runtime check.\n *   This is needed when SSR is NOT the provider, so server-only-referenced functions in the manifest\n *   can be blocked from client HTTP requests.\n */\nfunction generateManifestModule(\n  directiveFnsById: Record<string, DirectiveFn>,\n  includeClientReferencedCheck: boolean,\n): string {\n  const manifestEntries = Object.entries(directiveFnsById)\n    .map(([id, fn]) => {\n      const baseEntry = `'${id}': {\n                  functionName: '${fn.functionName}',\n        importer: () => import(${JSON.stringify(fn.extractedFilename)})${\n          includeClientReferencedCheck\n            ? `,\n        isClientReferenced: ${fn.isClientReferenced ?? true}`\n            : ''\n        }\n      }`\n      return baseEntry\n    })\n    .join(',')\n\n  const getServerFnByIdParams = includeClientReferencedCheck ? 'id, opts' : 'id'\n  const clientReferencedCheck = includeClientReferencedCheck\n    ? `\n      // If called from client, only allow client-referenced functions\n      if (opts?.fromClient && !serverFnInfo.isClientReferenced) {\n        throw new Error('Server function not accessible from client: ' + id)\n      }\n`\n    : ''\n\n  return `\n    const manifest = {${manifestEntries}}\n\n    export async function getServerFnById(${getServerFnByIdParams}) {\n              const serverFnInfo = manifest[id]\n              if (!serverFnInfo) {\n                throw new Error('Server function info not found for ' + id)\n              }\n${clientReferencedCheck}\n              const fnModule = await serverFnInfo.importer()\n\n              if (!fnModule) {\n                console.info('serverFnInfo', serverFnInfo)\n                throw new Error('Server function module not resolved for ' + id)\n              }\n\n              const action = fnModule[serverFnInfo.functionName]\n\n              if (!action) {\n                  console.info('serverFnInfo', serverFnInfo)\n                  console.info('fnModule', fnModule)\n\n                throw new Error(\n                  \\`Server function module export not resolved for serverFn ID: \\${id}\\`,\n                )\n              }\n              return action\n            }\n          `\n}\n\nfunction resolveViteId(id: string) {\n  return `\\0${id}`\n}\n"],"names":[],"mappings":"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"}