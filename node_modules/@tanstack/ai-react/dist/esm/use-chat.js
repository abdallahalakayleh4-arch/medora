import { ChatClient } from "@tanstack/ai-client";
import { useId, useState, useRef, useEffect, useMemo, useCallback } from "react";
function useChat(options) {
  const hookId = useId();
  const clientId = options.id || hookId;
  const [messages, setMessages] = useState(
    options.initialMessages || []
  );
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(void 0);
  const [status, setStatus] = useState("ready");
  const messagesRef = useRef(
    options.initialMessages || []
  );
  const isFirstMountRef = useRef(true);
  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);
  const optionsRef = useRef(options);
  optionsRef.current = options;
  const client = useMemo(() => {
    const messagesToUse = isFirstMountRef.current ? options.initialMessages || [] : messagesRef.current;
    isFirstMountRef.current = false;
    return new ChatClient({
      connection: optionsRef.current.connection,
      id: clientId,
      initialMessages: messagesToUse,
      body: optionsRef.current.body,
      onResponse: optionsRef.current.onResponse,
      onChunk: optionsRef.current.onChunk,
      onFinish: (message) => {
        optionsRef.current.onFinish?.(message);
      },
      onError: (error2) => {
        optionsRef.current.onError?.(error2);
      },
      tools: optionsRef.current.tools,
      streamProcessor: options.streamProcessor,
      onMessagesChange: (newMessages) => {
        setMessages(newMessages);
      },
      onLoadingChange: (newIsLoading) => {
        setIsLoading(newIsLoading);
      },
      onErrorChange: (newError) => {
        setError(newError);
      },
      onStatusChange: (status2) => {
        setStatus(status2);
      }
    });
  }, [clientId]);
  useEffect(() => {
    client.updateOptions({ body: options.body });
  }, [client, options.body]);
  useEffect(() => {
    if (options.initialMessages && options.initialMessages.length > 0) {
      if (messages.length === 0) {
        client.setMessagesManually(options.initialMessages);
      }
    }
  }, []);
  useEffect(() => {
    return () => {
      client.stop();
    };
  }, [client]);
  const sendMessage = useCallback(
    async (content) => {
      await client.sendMessage(content);
    },
    [client]
  );
  const append = useCallback(
    async (message) => {
      await client.append(message);
    },
    [client]
  );
  const reload = useCallback(async () => {
    await client.reload();
  }, [client]);
  const stop = useCallback(() => {
    client.stop();
  }, [client]);
  const clear = useCallback(() => {
    client.clear();
  }, [client]);
  const setMessagesManually = useCallback(
    (newMessages) => {
      client.setMessagesManually(newMessages);
    },
    [client]
  );
  const addToolResult = useCallback(
    async (result) => {
      await client.addToolResult(result);
    },
    [client]
  );
  const addToolApprovalResponse = useCallback(
    async (response) => {
      await client.addToolApprovalResponse(response);
    },
    [client]
  );
  return {
    messages,
    sendMessage,
    append,
    reload,
    stop,
    isLoading,
    error,
    status,
    setMessages: setMessagesManually,
    clear,
    addToolResult,
    addToolApprovalResponse
  };
}
export {
  useChat
};
//# sourceMappingURL=use-chat.js.map
