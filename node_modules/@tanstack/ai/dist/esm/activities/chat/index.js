import { aiEventClient } from "../../event-client.js";
import { streamToText } from "../../stream-to-response.js";
import { ToolCallManager, executeToolCalls } from "./tools/tool-calls.js";
import { convertSchemaToJsonSchema, isStandardSchema, parseWithStandardSchema } from "./tools/schema-converter.js";
import { maxIterations } from "./agent-loop-strategies.js";
import { convertMessagesToModelMessages } from "./messages.js";
const kind = "text";
function createChatOptions(options) {
  return options;
}
class TextEngine {
  constructor(config) {
    this.iterationCount = 0;
    this.lastFinishReason = null;
    this.streamStartTime = 0;
    this.totalChunkCount = 0;
    this.currentMessageId = null;
    this.accumulatedContent = "";
    this.finishedEvent = null;
    this.shouldEmitStreamEnd = true;
    this.earlyTermination = false;
    this.toolPhase = "continue";
    this.cyclePhase = "processText";
    this.adapter = config.adapter;
    this.params = config.params;
    this.systemPrompts = config.params.systemPrompts || [];
    this.tools = config.params.tools || [];
    this.loopStrategy = config.params.agentLoopStrategy || maxIterations(5);
    this.toolCallManager = new ToolCallManager(this.tools);
    this.initialMessageCount = config.params.messages.length;
    const { approvals, clientToolResults } = this.extractClientStateFromOriginalMessages(
      config.params.messages
    );
    this.initialApprovals = approvals;
    this.initialClientToolResults = clientToolResults;
    this.messages = convertMessagesToModelMessages(
      config.params.messages
    );
    this.requestId = this.createId("chat");
    this.streamId = this.createId("stream");
    this.effectiveRequest = config.params.abortController ? { signal: config.params.abortController.signal } : void 0;
    this.effectiveSignal = config.params.abortController?.signal;
  }
  /** Get the accumulated content after the chat loop completes */
  getAccumulatedContent() {
    return this.accumulatedContent;
  }
  /** Get the final messages array after the chat loop completes */
  getMessages() {
    return this.messages;
  }
  async *run() {
    this.beforeRun();
    try {
      const pendingPhase = yield* this.checkForPendingToolCalls();
      if (pendingPhase === "wait") {
        return;
      }
      do {
        if (this.earlyTermination || this.isAborted()) {
          return;
        }
        this.beginCycle();
        if (this.cyclePhase === "processText") {
          yield* this.streamModelResponse();
        } else {
          yield* this.processToolCalls();
        }
        this.endCycle();
      } while (this.shouldContinue());
    } finally {
      this.afterRun();
    }
  }
  beforeRun() {
    this.streamStartTime = Date.now();
    const { tools, temperature, topP, maxTokens, metadata } = this.params;
    const options = {};
    if (temperature !== void 0) options.temperature = temperature;
    if (topP !== void 0) options.topP = topP;
    if (maxTokens !== void 0) options.maxTokens = maxTokens;
    if (metadata !== void 0) options.metadata = metadata;
    this.eventOptions = Object.keys(options).length > 0 ? options : void 0;
    this.eventToolNames = tools?.map((t) => t.name);
    aiEventClient.emit("text:request:started", {
      ...this.buildTextEventContext(),
      timestamp: Date.now()
    });
    const messagesToEmit = this.params.conversationId ? this.messages.slice(-1).filter((m) => m.role === "user") : this.messages;
    messagesToEmit.forEach((message, index) => {
      const messageIndex = this.params.conversationId ? this.messages.length - 1 : index;
      const messageId = this.createId("msg");
      const baseContext = this.buildTextEventContext();
      const content = this.getContentString(message.content);
      aiEventClient.emit("text:message:created", {
        ...baseContext,
        messageId,
        role: message.role,
        content,
        toolCalls: message.toolCalls,
        messageIndex,
        timestamp: Date.now()
      });
      if (message.role === "user") {
        aiEventClient.emit("text:message:user", {
          ...baseContext,
          messageId,
          role: "user",
          content,
          messageIndex,
          timestamp: Date.now()
        });
      }
    });
  }
  afterRun() {
    if (!this.shouldEmitStreamEnd) {
      return;
    }
    const now = Date.now();
    aiEventClient.emit("text:request:completed", {
      ...this.buildTextEventContext(),
      content: this.accumulatedContent,
      messageId: this.currentMessageId || void 0,
      finishReason: this.lastFinishReason || void 0,
      usage: this.finishedEvent?.usage,
      duration: now - this.streamStartTime,
      timestamp: now
    });
  }
  beginCycle() {
    if (this.cyclePhase === "processText") {
      this.beginIteration();
    }
  }
  endCycle() {
    if (this.cyclePhase === "processText") {
      this.cyclePhase = "executeToolCalls";
      return;
    }
    this.cyclePhase = "processText";
    this.iterationCount++;
  }
  beginIteration() {
    this.currentMessageId = this.createId("msg");
    this.accumulatedContent = "";
    this.finishedEvent = null;
    const baseContext = this.buildTextEventContext();
    aiEventClient.emit("text:message:created", {
      ...baseContext,
      messageId: this.currentMessageId,
      role: "assistant",
      content: "",
      timestamp: Date.now()
    });
  }
  async *streamModelResponse() {
    const { temperature, topP, maxTokens, metadata, modelOptions } = this.params;
    const tools = this.params.tools;
    const toolsWithJsonSchemas = tools?.map((tool) => ({
      ...tool,
      inputSchema: tool.inputSchema ? convertSchemaToJsonSchema(tool.inputSchema) : void 0,
      outputSchema: tool.outputSchema ? convertSchemaToJsonSchema(tool.outputSchema) : void 0
    }));
    for await (const chunk of this.adapter.chatStream({
      model: this.params.model,
      messages: this.messages,
      tools: toolsWithJsonSchemas,
      temperature,
      topP,
      maxTokens,
      metadata,
      request: this.effectiveRequest,
      modelOptions,
      systemPrompts: this.systemPrompts
    })) {
      if (this.isAborted()) {
        break;
      }
      this.totalChunkCount++;
      yield chunk;
      this.handleStreamChunk(chunk);
      if (this.earlyTermination) {
        break;
      }
    }
  }
  handleStreamChunk(chunk) {
    switch (chunk.type) {
      // AG-UI Events
      case "TEXT_MESSAGE_CONTENT":
        this.handleTextMessageContentEvent(chunk);
        break;
      case "TOOL_CALL_START":
        this.handleToolCallStartEvent(chunk);
        break;
      case "TOOL_CALL_ARGS":
        this.handleToolCallArgsEvent(chunk);
        break;
      case "TOOL_CALL_END":
        this.handleToolCallEndEvent(chunk);
        break;
      case "RUN_FINISHED":
        this.handleRunFinishedEvent(chunk);
        break;
      case "RUN_ERROR":
        this.handleRunErrorEvent(chunk);
        break;
      case "STEP_FINISHED":
        this.handleStepFinishedEvent(chunk);
        break;
    }
  }
  // ===========================
  // AG-UI Event Handlers
  // ===========================
  handleTextMessageContentEvent(chunk) {
    if (chunk.content) {
      this.accumulatedContent = chunk.content;
    } else {
      this.accumulatedContent += chunk.delta;
    }
    aiEventClient.emit("text:chunk:content", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      content: this.accumulatedContent,
      delta: chunk.delta,
      timestamp: Date.now()
    });
  }
  handleToolCallStartEvent(chunk) {
    this.toolCallManager.addToolCallStartEvent(chunk);
    aiEventClient.emit("text:chunk:tool-call", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      toolCallId: chunk.toolCallId,
      toolName: chunk.toolName,
      index: chunk.index ?? 0,
      arguments: "",
      timestamp: Date.now()
    });
  }
  handleToolCallArgsEvent(chunk) {
    this.toolCallManager.addToolCallArgsEvent(chunk);
    aiEventClient.emit("text:chunk:tool-call", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      toolCallId: chunk.toolCallId,
      toolName: "",
      index: 0,
      arguments: chunk.delta,
      timestamp: Date.now()
    });
  }
  handleToolCallEndEvent(chunk) {
    this.toolCallManager.completeToolCall(chunk);
    aiEventClient.emit("text:chunk:tool-result", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      toolCallId: chunk.toolCallId,
      result: chunk.result || "",
      timestamp: Date.now()
    });
  }
  handleRunFinishedEvent(chunk) {
    aiEventClient.emit("text:chunk:done", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      finishReason: chunk.finishReason,
      usage: chunk.usage,
      timestamp: Date.now()
    });
    if (chunk.usage) {
      aiEventClient.emit("text:usage", {
        ...this.buildTextEventContext(),
        messageId: this.currentMessageId || void 0,
        usage: chunk.usage,
        timestamp: Date.now()
      });
    }
    this.finishedEvent = chunk;
    this.lastFinishReason = chunk.finishReason;
  }
  handleRunErrorEvent(chunk) {
    aiEventClient.emit("text:chunk:error", {
      ...this.buildTextEventContext(),
      messageId: this.currentMessageId || void 0,
      error: chunk.error.message,
      timestamp: Date.now()
    });
    this.earlyTermination = true;
    this.shouldEmitStreamEnd = false;
  }
  handleStepFinishedEvent(chunk) {
    if (chunk.content || chunk.delta) {
      aiEventClient.emit("text:chunk:thinking", {
        ...this.buildTextEventContext(),
        messageId: this.currentMessageId || void 0,
        content: chunk.content || "",
        delta: chunk.delta,
        timestamp: Date.now()
      });
    }
  }
  async *checkForPendingToolCalls() {
    const pendingToolCalls = this.getPendingToolCallsFromMessages();
    if (pendingToolCalls.length === 0) {
      return "continue";
    }
    const finishEvent = this.createSyntheticFinishedEvent();
    const { approvals, clientToolResults } = this.collectClientState();
    const executionResult = await executeToolCalls(
      pendingToolCalls,
      this.tools,
      approvals,
      clientToolResults
    );
    if (executionResult.needsApproval.length > 0 || executionResult.needsClientExecution.length > 0) {
      for (const chunk of this.emitApprovalRequests(
        executionResult.needsApproval,
        finishEvent
      )) {
        yield chunk;
      }
      for (const chunk of this.emitClientToolInputs(
        executionResult.needsClientExecution,
        finishEvent
      )) {
        yield chunk;
      }
      this.shouldEmitStreamEnd = false;
      return "wait";
    }
    const toolResultChunks = this.emitToolResults(
      executionResult.results,
      finishEvent
    );
    for (const chunk of toolResultChunks) {
      yield chunk;
    }
    return "continue";
  }
  async *processToolCalls() {
    if (!this.shouldExecuteToolPhase()) {
      this.setToolPhase("stop");
      return;
    }
    const toolCalls = this.toolCallManager.getToolCalls();
    const finishEvent = this.finishedEvent;
    if (!finishEvent || toolCalls.length === 0) {
      this.setToolPhase("stop");
      return;
    }
    this.addAssistantToolCallMessage(toolCalls);
    const { approvals, clientToolResults } = this.collectClientState();
    const executionResult = await executeToolCalls(
      toolCalls,
      this.tools,
      approvals,
      clientToolResults
    );
    if (executionResult.needsApproval.length > 0 || executionResult.needsClientExecution.length > 0) {
      for (const chunk of this.emitApprovalRequests(
        executionResult.needsApproval,
        finishEvent
      )) {
        yield chunk;
      }
      for (const chunk of this.emitClientToolInputs(
        executionResult.needsClientExecution,
        finishEvent
      )) {
        yield chunk;
      }
      this.setToolPhase("wait");
      return;
    }
    const toolResultChunks = this.emitToolResults(
      executionResult.results,
      finishEvent
    );
    for (const chunk of toolResultChunks) {
      yield chunk;
    }
    this.toolCallManager.clear();
    this.setToolPhase("continue");
  }
  shouldExecuteToolPhase() {
    return this.finishedEvent?.finishReason === "tool_calls" && this.tools.length > 0 && this.toolCallManager.hasToolCalls();
  }
  addAssistantToolCallMessage(toolCalls) {
    const messageId = this.currentMessageId ?? this.createId("msg");
    this.messages = [
      ...this.messages,
      {
        role: "assistant",
        content: this.accumulatedContent || null,
        toolCalls
      }
    ];
    aiEventClient.emit("text:message:created", {
      ...this.buildTextEventContext(),
      messageId,
      role: "assistant",
      content: this.accumulatedContent || "",
      toolCalls,
      timestamp: Date.now()
    });
  }
  /**
   * Extract client state (approvals and client tool results) from original messages.
   * This is called in the constructor BEFORE converting to ModelMessage format,
   * because the parts array (which contains approval state) is lost during conversion.
   */
  extractClientStateFromOriginalMessages(originalMessages) {
    const approvals = /* @__PURE__ */ new Map();
    const clientToolResults = /* @__PURE__ */ new Map();
    for (const message of originalMessages) {
      if (message.role === "assistant" && message.parts) {
        for (const part of message.parts) {
          if (part.type === "tool-call") {
            if (part.output !== void 0 && !part.approval) {
              clientToolResults.set(part.id, part.output);
            }
            if (part.approval?.id && part.approval?.approved !== void 0 && part.state === "approval-responded") {
              approvals.set(part.approval.id, part.approval.approved);
            }
          }
        }
      }
    }
    return { approvals, clientToolResults };
  }
  collectClientState() {
    const approvals = new Map(this.initialApprovals);
    const clientToolResults = new Map(this.initialClientToolResults);
    for (const message of this.messages) {
      if (message.role === "tool" && message.toolCallId) {
        let output;
        try {
          output = JSON.parse(message.content);
        } catch {
          output = message.content;
        }
        if (output && typeof output === "object" && output.pendingExecution === true) {
          continue;
        }
        clientToolResults.set(message.toolCallId, output);
      }
    }
    return { approvals, clientToolResults };
  }
  emitApprovalRequests(approvals, finishEvent) {
    const chunks = [];
    for (const approval of approvals) {
      aiEventClient.emit("tools:approval:requested", {
        ...this.buildTextEventContext(),
        messageId: this.currentMessageId || void 0,
        toolCallId: approval.toolCallId,
        toolName: approval.toolName,
        input: approval.input,
        approvalId: approval.approvalId,
        timestamp: Date.now()
      });
      chunks.push({
        type: "CUSTOM",
        timestamp: Date.now(),
        model: finishEvent.model,
        name: "approval-requested",
        data: {
          toolCallId: approval.toolCallId,
          toolName: approval.toolName,
          input: approval.input,
          approval: {
            id: approval.approvalId,
            needsApproval: true
          }
        }
      });
    }
    return chunks;
  }
  emitClientToolInputs(clientRequests, finishEvent) {
    const chunks = [];
    for (const clientTool of clientRequests) {
      aiEventClient.emit("tools:input:available", {
        ...this.buildTextEventContext(),
        messageId: this.currentMessageId || void 0,
        toolCallId: clientTool.toolCallId,
        toolName: clientTool.toolName,
        input: clientTool.input,
        timestamp: Date.now()
      });
      chunks.push({
        type: "CUSTOM",
        timestamp: Date.now(),
        model: finishEvent.model,
        name: "tool-input-available",
        data: {
          toolCallId: clientTool.toolCallId,
          toolName: clientTool.toolName,
          input: clientTool.input
        }
      });
    }
    return chunks;
  }
  emitToolResults(results, finishEvent) {
    const chunks = [];
    for (const result of results) {
      aiEventClient.emit("tools:call:completed", {
        ...this.buildTextEventContext(),
        messageId: this.currentMessageId || void 0,
        toolCallId: result.toolCallId,
        toolName: result.toolName,
        result: result.result,
        duration: result.duration ?? 0,
        timestamp: Date.now()
      });
      const content = JSON.stringify(result.result);
      chunks.push({
        type: "TOOL_CALL_END",
        timestamp: Date.now(),
        model: finishEvent.model,
        toolCallId: result.toolCallId,
        toolName: result.toolName,
        result: content
      });
      this.messages = [
        ...this.messages,
        {
          role: "tool",
          content,
          toolCallId: result.toolCallId
        }
      ];
      aiEventClient.emit("text:message:created", {
        ...this.buildTextEventContext(),
        messageId: this.createId("msg"),
        role: "tool",
        content,
        timestamp: Date.now()
      });
    }
    return chunks;
  }
  getPendingToolCallsFromMessages() {
    const completedToolIds = /* @__PURE__ */ new Set();
    for (const message of this.messages) {
      if (message.role === "tool" && message.toolCallId) {
        let hasPendingExecution = false;
        if (typeof message.content === "string") {
          try {
            const parsed = JSON.parse(message.content);
            if (parsed.pendingExecution === true) {
              hasPendingExecution = true;
            }
          } catch {
          }
        }
        if (!hasPendingExecution) {
          completedToolIds.add(message.toolCallId);
        }
      }
    }
    const pending = [];
    for (const message of this.messages) {
      if (message.role === "assistant" && message.toolCalls) {
        for (const toolCall of message.toolCalls) {
          if (!completedToolIds.has(toolCall.id)) {
            pending.push(toolCall);
          }
        }
      }
    }
    return pending;
  }
  createSyntheticFinishedEvent() {
    return {
      type: "RUN_FINISHED",
      runId: this.createId("pending"),
      model: this.params.model,
      timestamp: Date.now(),
      finishReason: "tool_calls"
    };
  }
  shouldContinue() {
    if (this.cyclePhase === "executeToolCalls") {
      return true;
    }
    return this.loopStrategy({
      iterationCount: this.iterationCount,
      messages: this.messages,
      finishReason: this.lastFinishReason
    }) && this.toolPhase === "continue";
  }
  isAborted() {
    return !!this.effectiveSignal?.aborted;
  }
  buildTextEventContext() {
    return {
      requestId: this.requestId,
      streamId: this.streamId,
      provider: this.adapter.name,
      model: this.params.model,
      clientId: this.params.conversationId,
      source: "server",
      systemPrompts: this.systemPrompts.length > 0 ? this.systemPrompts : void 0,
      toolNames: this.eventToolNames,
      options: this.eventOptions,
      modelOptions: this.params.modelOptions,
      messageCount: this.initialMessageCount,
      hasTools: this.tools.length > 0,
      streaming: true
    };
  }
  getContentString(content) {
    if (typeof content === "string") return content;
    const text = content?.map((part) => part.type === "text" ? part.content : "").join("") || "";
    return text;
  }
  setToolPhase(phase) {
    this.toolPhase = phase;
    if (phase === "wait") {
      this.shouldEmitStreamEnd = false;
    }
  }
  createId(prefix) {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }
}
function chat(options) {
  const { outputSchema, stream } = options;
  if (outputSchema) {
    return runAgenticStructuredOutput(
      options
    );
  }
  if (stream === false) {
    return runNonStreamingText(
      options
    );
  }
  return runStreamingText(
    options
  );
}
async function* runStreamingText(options) {
  const { adapter, ...textOptions } = options;
  const model = adapter.model;
  const engine = new TextEngine({
    adapter,
    params: { ...textOptions, model }
  });
  for await (const chunk of engine.run()) {
    yield chunk;
  }
}
function runNonStreamingText(options) {
  const stream = runStreamingText(
    options
  );
  return streamToText(stream);
}
async function runAgenticStructuredOutput(options) {
  const { adapter, outputSchema, ...textOptions } = options;
  const model = adapter.model;
  if (!outputSchema) {
    throw new Error("outputSchema is required for structured output");
  }
  const engine = new TextEngine({
    adapter,
    params: { ...textOptions, model }
  });
  for await (const _chunk of engine.run()) {
  }
  const finalMessages = engine.getMessages();
  const {
    tools: _tools,
    agentLoopStrategy: _als,
    ...structuredTextOptions
  } = textOptions;
  const jsonSchema = convertSchemaToJsonSchema(outputSchema);
  if (!jsonSchema) {
    throw new Error("Failed to convert output schema to JSON Schema");
  }
  const result = await adapter.structuredOutput({
    chatOptions: {
      ...structuredTextOptions,
      model,
      messages: finalMessages
    },
    outputSchema: jsonSchema
  });
  if (isStandardSchema(outputSchema)) {
    return parseWithStandardSchema(
      outputSchema,
      result.data
    );
  }
  return result.data;
}
export {
  chat,
  createChatOptions,
  kind
};
//# sourceMappingURL=index.js.map
