{"version":3,"file":"processor.js","sources":["../../../../../src/activities/chat/stream/processor.ts"],"sourcesContent":["/**\n * Unified Stream Processor\n *\n * Core stream processing engine that manages the full UIMessage[] conversation.\n * Single source of truth for message state.\n *\n * Handles:\n * - Full conversation management (UIMessage[])\n * - Text content accumulation with configurable chunking strategies\n * - Parallel tool calls with lifecycle state tracking\n * - Tool results and approval flows\n * - Thinking/reasoning content\n * - Recording/replay for testing\n * - Event-driven architecture for UI updates\n *\n * @see docs/chat-architecture.md — Canonical reference for AG-UI chunk ordering,\n *   adapter contract, single-shot flows, and expected UIMessage output.\n */\nimport { generateMessageId, uiMessageToModelMessages } from '../messages.js'\nimport { defaultJSONParser } from './json-parser'\nimport {\n  updateTextPart,\n  updateThinkingPart,\n  updateToolCallApproval,\n  updateToolCallApprovalResponse,\n  updateToolCallPart,\n  updateToolCallWithOutput,\n  updateToolResultPart,\n} from './message-updaters'\nimport { ImmediateStrategy } from './strategies'\nimport type {\n  ChunkRecording,\n  ChunkStrategy,\n  InternalToolCallState,\n  ProcessorResult,\n  ProcessorState,\n  ToolCallState,\n  ToolResultState,\n} from './types'\nimport type {\n  ContentPart,\n  MessagePart,\n  ModelMessage,\n  StreamChunk,\n  ToolCall,\n  ToolCallPart,\n  ToolResultPart,\n  UIMessage,\n} from '../../../types'\n\n/**\n * Events emitted by the StreamProcessor\n */\nexport interface StreamProcessorEvents {\n  // State events - full array on any change\n  onMessagesChange?: (messages: Array<UIMessage>) => void\n\n  // Lifecycle events\n  onStreamStart?: () => void\n  onStreamEnd?: (message: UIMessage) => void\n  onError?: (error: Error) => void\n\n  // Interaction events - client must handle these\n  onToolCall?: (args: {\n    toolCallId: string\n    toolName: string\n    input: any\n  }) => void\n  onApprovalRequest?: (args: {\n    toolCallId: string\n    toolName: string\n    input: any\n    approvalId: string\n  }) => void\n\n  // Granular events for UI optimization (character-by-character, state tracking)\n  onTextUpdate?: (messageId: string, content: string) => void\n  onToolCallStateChange?: (\n    messageId: string,\n    toolCallId: string,\n    state: ToolCallState,\n    args: string,\n  ) => void\n  onThinkingUpdate?: (messageId: string, content: string) => void\n}\n\n/**\n * Options for StreamProcessor\n */\nexport interface StreamProcessorOptions {\n  chunkStrategy?: ChunkStrategy\n  /** Event-driven handlers */\n  events?: StreamProcessorEvents\n  jsonParser?: {\n    parse: (jsonString: string) => any\n  }\n  /** Enable recording for replay testing */\n  recording?: boolean\n  /** Initial messages to populate the processor */\n  initialMessages?: Array<UIMessage>\n}\n\n/**\n * StreamProcessor - State machine for processing AI response streams\n *\n * Manages the full UIMessage[] conversation and emits events on changes.\n * Trusts the adapter contract: adapters emit clean AG-UI events in the\n * correct order.\n *\n * State tracking:\n * - Full message array\n * - Current assistant message being streamed\n * - Text content accumulation (reset on TEXT_MESSAGE_START)\n * - Multiple parallel tool calls\n * - Tool call completion via TOOL_CALL_END events\n *\n * @see docs/chat-architecture.md#streamprocessor-internal-state — State field reference\n * @see docs/chat-architecture.md#adapter-contract — What this class expects from adapters\n */\nexport class StreamProcessor {\n  private chunkStrategy: ChunkStrategy\n  private events: StreamProcessorEvents\n  private jsonParser: { parse: (jsonString: string) => any }\n  private recordingEnabled: boolean\n\n  // Message state\n  private messages: Array<UIMessage> = []\n  private currentAssistantMessageId: string | null = null\n\n  // Stream state for current assistant message\n  // Total accumulated text across all segments (for the final result)\n  private totalTextContent = ''\n  // Current segment's text content (for onTextUpdate callbacks)\n  private currentSegmentText = ''\n  private lastEmittedText = ''\n  private thinkingContent = ''\n  private toolCalls: Map<string, InternalToolCallState> = new Map()\n  private toolCallOrder: Array<string> = []\n  private finishReason: string | null = null\n  private hasError = false\n  private isDone = false\n\n  // Recording\n  private recording: ChunkRecording | null = null\n  private recordingStartTime = 0\n\n  constructor(options: StreamProcessorOptions = {}) {\n    this.chunkStrategy = options.chunkStrategy || new ImmediateStrategy()\n    this.events = options.events || {}\n    this.jsonParser = options.jsonParser || defaultJSONParser\n    this.recordingEnabled = options.recording ?? false\n\n    // Initialize with provided messages\n    if (options.initialMessages) {\n      this.messages = [...options.initialMessages]\n    }\n  }\n\n  // ============================================\n  // Message Management Methods\n  // ============================================\n\n  /**\n   * Set the messages array (e.g., from persisted state)\n   */\n  setMessages(messages: Array<UIMessage>): void {\n    this.messages = [...messages]\n    this.emitMessagesChange()\n  }\n\n  /**\n   * Add a user message to the conversation.\n   * Supports both simple string content and multimodal content arrays.\n   *\n   * @param content - The message content (string or array of content parts)\n   * @param id - Optional custom message ID (generated if not provided)\n   * @returns The created UIMessage\n   *\n   * @example\n   * ```ts\n   * // Simple text message\n   * processor.addUserMessage('Hello!')\n   *\n   * // Multimodal message with image\n   * processor.addUserMessage([\n   *   { type: 'text', content: 'What is in this image?' },\n   *   { type: 'image', source: { type: 'url', value: 'https://example.com/photo.jpg' } }\n   * ])\n   *\n   * // With custom ID\n   * processor.addUserMessage('Hello!', 'custom-id-123')\n   * ```\n   */\n  addUserMessage(content: string | Array<ContentPart>, id?: string): UIMessage {\n    // Convert content to message parts\n    const parts: Array<MessagePart> =\n      typeof content === 'string'\n        ? [{ type: 'text', content }]\n        : content.map((part) => {\n            // ContentPart types (text, image, audio, video, document) are compatible with MessagePart\n            return part as MessagePart\n          })\n\n    const userMessage: UIMessage = {\n      id: id ?? generateMessageId(),\n      role: 'user',\n      parts,\n      createdAt: new Date(),\n    }\n\n    this.messages = [...this.messages, userMessage]\n    this.emitMessagesChange()\n\n    return userMessage\n  }\n\n  /**\n   * Prepare for a new assistant message stream.\n   * Does NOT create the message immediately -- the message is created lazily\n   * when the first content-bearing chunk arrives via ensureAssistantMessage().\n   * This prevents empty assistant messages from flickering in the UI when\n   * auto-continuation produces no content.\n   */\n  prepareAssistantMessage(): void {\n    // Reset stream state for new message\n    this.resetStreamState()\n    // Clear the current assistant message ID so ensureAssistantMessage()\n    // will create a fresh message on the first content chunk\n    this.currentAssistantMessageId = null\n  }\n\n  /**\n   * @deprecated Use prepareAssistantMessage() instead. This eagerly creates\n   * an assistant message which can cause empty message flicker.\n   */\n  startAssistantMessage(): string {\n    this.prepareAssistantMessage()\n    return this.ensureAssistantMessage()\n  }\n\n  /**\n   * Get the current assistant message ID (if one has been created).\n   * Returns null if prepareAssistantMessage() was called but no content\n   * has arrived yet.\n   */\n  getCurrentAssistantMessageId(): string | null {\n    return this.currentAssistantMessageId\n  }\n\n  /**\n   * Lazily create the assistant message if it hasn't been created yet.\n   * Called by content handlers on the first content-bearing chunk.\n   * Returns the message ID.\n   *\n   * Content-bearing chunks that trigger this:\n   * TEXT_MESSAGE_CONTENT, TOOL_CALL_START, STEP_FINISHED, RUN_ERROR.\n   *\n   * @see docs/chat-architecture.md#streamprocessor-internal-state — Lazy creation pattern\n   */\n  private ensureAssistantMessage(): string {\n    if (this.currentAssistantMessageId) {\n      return this.currentAssistantMessageId\n    }\n\n    const assistantMessage: UIMessage = {\n      id: generateMessageId(),\n      role: 'assistant',\n      parts: [],\n      createdAt: new Date(),\n    }\n\n    this.currentAssistantMessageId = assistantMessage.id\n    this.messages = [...this.messages, assistantMessage]\n\n    // Emit events\n    this.events.onStreamStart?.()\n    this.emitMessagesChange()\n\n    return assistantMessage.id\n  }\n\n  /**\n   * Add a tool result (called by client after handling onToolCall)\n   */\n  addToolResult(toolCallId: string, output: any, error?: string): void {\n    // Find the message containing this tool call\n    const messageWithToolCall = this.messages.find((msg) =>\n      msg.parts.some(\n        (p): p is ToolCallPart => p.type === 'tool-call' && p.id === toolCallId,\n      ),\n    )\n\n    if (!messageWithToolCall) {\n      console.warn(\n        `[StreamProcessor] Could not find message with tool call ${toolCallId}`,\n      )\n      return\n    }\n\n    // Step 1: Update the tool-call part's output field (for UI rendering)\n    let updatedMessages = updateToolCallWithOutput(\n      this.messages,\n      toolCallId,\n      output,\n      error ? 'input-complete' : undefined,\n      error,\n    )\n\n    // Step 2: Create a tool-result part (for LLM conversation history)\n    const content = typeof output === 'string' ? output : JSON.stringify(output)\n    const toolResultState: ToolResultState = error ? 'error' : 'complete'\n\n    updatedMessages = updateToolResultPart(\n      updatedMessages,\n      messageWithToolCall.id,\n      toolCallId,\n      content,\n      toolResultState,\n      error,\n    )\n\n    this.messages = updatedMessages\n    this.emitMessagesChange()\n  }\n\n  /**\n   * Add an approval response (called by client after handling onApprovalRequest)\n   */\n  addToolApprovalResponse(approvalId: string, approved: boolean): void {\n    this.messages = updateToolCallApprovalResponse(\n      this.messages,\n      approvalId,\n      approved,\n    )\n    this.emitMessagesChange()\n  }\n\n  /**\n   * Get the conversation as ModelMessages (for sending to LLM)\n   */\n  toModelMessages(): Array<ModelMessage> {\n    const modelMessages: Array<ModelMessage> = []\n    for (const msg of this.messages) {\n      modelMessages.push(...uiMessageToModelMessages(msg))\n    }\n    return modelMessages\n  }\n\n  /**\n   * Get current messages\n   */\n  getMessages(): Array<UIMessage> {\n    return this.messages\n  }\n\n  /**\n   * Check if all tool calls in the last assistant message are complete\n   * Useful for auto-continue logic\n   */\n  areAllToolsComplete(): boolean {\n    const lastAssistant = this.messages.findLast(\n      (m: UIMessage) => m.role === 'assistant',\n    )\n\n    if (!lastAssistant) return true\n\n    const toolParts = lastAssistant.parts.filter(\n      (p): p is ToolCallPart => p.type === 'tool-call',\n    )\n\n    if (toolParts.length === 0) return true\n\n    // Get tool result parts to check for server tool completion\n    const toolResultIds = new Set(\n      lastAssistant.parts\n        .filter((p): p is ToolResultPart => p.type === 'tool-result')\n        .map((p) => p.toolCallId),\n    )\n\n    // All tool calls must be in a terminal state\n    // A tool call is complete if:\n    // 1. It was approved/denied (approval-responded state)\n    // 2. It has an output field set (client tool completed via addToolResult)\n    // 3. It has a corresponding tool-result part (server tool completed)\n    return toolParts.every(\n      (part) =>\n        part.state === 'approval-responded' ||\n        (part.output !== undefined && !part.approval) ||\n        toolResultIds.has(part.id),\n    )\n  }\n\n  /**\n   * Remove messages after a certain index (for reload/retry)\n   */\n  removeMessagesAfter(index: number): void {\n    this.messages = this.messages.slice(0, index + 1)\n    this.emitMessagesChange()\n  }\n\n  /**\n   * Clear all messages\n   */\n  clearMessages(): void {\n    this.messages = []\n    this.currentAssistantMessageId = null\n    this.emitMessagesChange()\n  }\n\n  // ============================================\n  // Stream Processing Methods\n  // ============================================\n\n  /**\n   * Process a stream and emit events through handlers\n   */\n  async process(stream: AsyncIterable<any>): Promise<ProcessorResult> {\n    // Reset stream state (but keep messages)\n    this.resetStreamState()\n\n    // Start recording if enabled\n    if (this.recordingEnabled) {\n      this.startRecording()\n    }\n\n    // Process each chunk\n    for await (const chunk of stream) {\n      this.processChunk(chunk)\n    }\n\n    // Stream ended - finalize everything\n    this.finalizeStream()\n\n    // Finalize recording\n    if (this.recording) {\n      this.recording.result = this.getResult()\n    }\n\n    return this.getResult()\n  }\n\n  /**\n   * Process a single chunk from the stream.\n   *\n   * Central dispatch for all AG-UI events. Each event type maps to a specific\n   * handler. Events not listed in the switch are intentionally ignored\n   * (RUN_STARTED, TEXT_MESSAGE_END, STEP_STARTED, STATE_SNAPSHOT, STATE_DELTA).\n   *\n   * @see docs/chat-architecture.md#adapter-contract — Expected event types and ordering\n   */\n  processChunk(chunk: StreamChunk): void {\n    // Record chunk if enabled\n    if (this.recording) {\n      this.recording.chunks.push({\n        chunk,\n        timestamp: Date.now(),\n        index: this.recording.chunks.length,\n      })\n    }\n\n    switch (chunk.type) {\n      // AG-UI Events\n      case 'TEXT_MESSAGE_START':\n        this.handleTextMessageStartEvent()\n        break\n\n      case 'TEXT_MESSAGE_CONTENT':\n        this.handleTextMessageContentEvent(chunk)\n        break\n\n      case 'TOOL_CALL_START':\n        this.handleToolCallStartEvent(chunk)\n        break\n\n      case 'TOOL_CALL_ARGS':\n        this.handleToolCallArgsEvent(chunk)\n        break\n\n      case 'TOOL_CALL_END':\n        this.handleToolCallEndEvent(chunk)\n        break\n\n      case 'RUN_FINISHED':\n        this.handleRunFinishedEvent(chunk)\n        break\n\n      case 'RUN_ERROR':\n        this.handleRunErrorEvent(chunk)\n        break\n\n      case 'STEP_FINISHED':\n        this.handleStepFinishedEvent(chunk)\n        break\n\n      case 'CUSTOM':\n        this.handleCustomEvent(chunk)\n        break\n\n      default:\n        // RUN_STARTED, TEXT_MESSAGE_END, STEP_STARTED,\n        // STATE_SNAPSHOT, STATE_DELTA - no special handling needed\n        break\n    }\n  }\n\n  /**\n   * Handle TEXT_MESSAGE_START event — marks the beginning of a new text segment.\n   * Resets segment accumulation so text after tool calls starts fresh.\n   *\n   * This is the key mechanism for multi-segment text (text before and after tool\n   * calls becoming separate TextParts). Without this reset, all text would merge\n   * into a single TextPart and tool-call interleaving would be lost.\n   *\n   * @see docs/chat-architecture.md#single-shot-text-response — Step-by-step text processing\n   * @see docs/chat-architecture.md#text-then-tool-interleaving-single-shot — Multi-segment text\n   */\n  private handleTextMessageStartEvent(): void {\n    // Emit any pending text from a previous segment before resetting\n    if (this.currentSegmentText !== this.lastEmittedText) {\n      this.emitTextUpdate()\n    }\n    this.currentSegmentText = ''\n    this.lastEmittedText = ''\n  }\n\n  /**\n   * Handle TEXT_MESSAGE_CONTENT event.\n   *\n   * Accumulates delta into both currentSegmentText (for UI emission) and\n   * totalTextContent (for ProcessorResult). Lazily creates the assistant\n   * UIMessage on first content. Uses updateTextPart() which replaces the\n   * last TextPart or creates a new one depending on part ordering.\n   *\n   * @see docs/chat-architecture.md#single-shot-text-response — Text accumulation step-by-step\n   * @see docs/chat-architecture.md#uimessage-part-ordering-invariants — Replace vs. push logic\n   */\n  private handleTextMessageContentEvent(\n    chunk: Extract<StreamChunk, { type: 'TEXT_MESSAGE_CONTENT' }>,\n  ): void {\n    this.ensureAssistantMessage()\n\n    this.currentSegmentText += chunk.delta\n    this.totalTextContent += chunk.delta\n\n    const shouldEmit = this.chunkStrategy.shouldEmit(\n      chunk.delta,\n      this.currentSegmentText,\n    )\n    if (shouldEmit && this.currentSegmentText !== this.lastEmittedText) {\n      this.emitTextUpdate()\n    }\n  }\n\n  /**\n   * Handle TOOL_CALL_START event.\n   *\n   * Creates a new InternalToolCallState entry in the toolCalls Map and appends\n   * a ToolCallPart to the UIMessage. Duplicate toolCallId is a no-op.\n   *\n   * CRITICAL: This MUST be received before any TOOL_CALL_ARGS for the same\n   * toolCallId. Args for unknown IDs are silently dropped.\n   *\n   * @see docs/chat-architecture.md#single-shot-tool-call-response — Tool call state transitions\n   * @see docs/chat-architecture.md#parallel-tool-calls-single-shot — Parallel tracking by ID\n   * @see docs/chat-architecture.md#adapter-contract — Ordering requirements\n   */\n  private handleToolCallStartEvent(\n    chunk: Extract<StreamChunk, { type: 'TOOL_CALL_START' }>,\n  ): void {\n    this.ensureAssistantMessage()\n\n    const toolCallId = chunk.toolCallId\n    const existingToolCall = this.toolCalls.get(toolCallId)\n\n    if (!existingToolCall) {\n      // New tool call starting\n      const initialState: ToolCallState = 'awaiting-input'\n\n      const newToolCall: InternalToolCallState = {\n        id: chunk.toolCallId,\n        name: chunk.toolName,\n        arguments: '',\n        state: initialState,\n        parsedArguments: undefined,\n        index: chunk.index ?? this.toolCalls.size,\n      }\n\n      this.toolCalls.set(toolCallId, newToolCall)\n      this.toolCallOrder.push(toolCallId)\n\n      // Update UIMessage\n      if (this.currentAssistantMessageId) {\n        this.messages = updateToolCallPart(\n          this.messages,\n          this.currentAssistantMessageId,\n          {\n            id: chunk.toolCallId,\n            name: chunk.toolName,\n            arguments: '',\n            state: initialState,\n          },\n        )\n        this.emitMessagesChange()\n\n        // Emit granular event\n        this.events.onToolCallStateChange?.(\n          this.currentAssistantMessageId,\n          chunk.toolCallId,\n          initialState,\n          '',\n        )\n      }\n    }\n  }\n\n  /**\n   * Handle TOOL_CALL_ARGS event.\n   *\n   * Appends the delta to the tool call's accumulated arguments string.\n   * Transitions state from awaiting-input → input-streaming on first non-empty delta.\n   * Attempts partial JSON parse on each update for UI preview.\n   *\n   * If toolCallId is not found in the Map (no preceding TOOL_CALL_START),\n   * this event is silently dropped.\n   *\n   * @see docs/chat-architecture.md#single-shot-tool-call-response — Step-by-step tool call processing\n   */\n  private handleToolCallArgsEvent(\n    chunk: Extract<StreamChunk, { type: 'TOOL_CALL_ARGS' }>,\n  ): void {\n    const toolCallId = chunk.toolCallId\n    const existingToolCall = this.toolCalls.get(toolCallId)\n\n    if (existingToolCall) {\n      const wasAwaitingInput = existingToolCall.state === 'awaiting-input'\n\n      // Accumulate arguments from delta\n      existingToolCall.arguments += chunk.delta || ''\n\n      // Update state\n      if (wasAwaitingInput && chunk.delta) {\n        existingToolCall.state = 'input-streaming'\n      }\n\n      // Try to parse the updated arguments\n      existingToolCall.parsedArguments = this.jsonParser.parse(\n        existingToolCall.arguments,\n      )\n\n      // Update UIMessage\n      if (this.currentAssistantMessageId) {\n        this.messages = updateToolCallPart(\n          this.messages,\n          this.currentAssistantMessageId,\n          {\n            id: existingToolCall.id,\n            name: existingToolCall.name,\n            arguments: existingToolCall.arguments,\n            state: existingToolCall.state,\n          },\n        )\n        this.emitMessagesChange()\n\n        // Emit granular event\n        this.events.onToolCallStateChange?.(\n          this.currentAssistantMessageId,\n          existingToolCall.id,\n          existingToolCall.state,\n          existingToolCall.arguments,\n        )\n      }\n    }\n  }\n\n  /**\n   * Handle TOOL_CALL_END event — authoritative signal that a tool call's input is finalized.\n   *\n   * This event has a DUAL ROLE:\n   * - Without `result`: Signals arguments are done (from adapter). Transitions to input-complete.\n   * - With `result`: Signals tool was executed and result is available (from TextEngine).\n   *   Creates both output on the tool-call part AND a tool-result part.\n   *\n   * If `input` is provided, it overrides the accumulated string parse as the\n   * canonical parsed arguments.\n   *\n   * @see docs/chat-architecture.md#tool-results-and-the-tool_call_end-dual-role — Full explanation\n   * @see docs/chat-architecture.md#single-shot-tool-call-response — End-to-end flow\n   */\n  private handleToolCallEndEvent(\n    chunk: Extract<StreamChunk, { type: 'TOOL_CALL_END' }>,\n  ): void {\n    // Transition the tool call to input-complete (the authoritative completion signal)\n    const existingToolCall = this.toolCalls.get(chunk.toolCallId)\n    if (existingToolCall && existingToolCall.state !== 'input-complete') {\n      const index = this.toolCallOrder.indexOf(chunk.toolCallId)\n      this.completeToolCall(index, existingToolCall)\n      // If TOOL_CALL_END provides parsed input, use it as the canonical parsed\n      // arguments (overrides the accumulated string parse from completeToolCall)\n      if (chunk.input !== undefined) {\n        existingToolCall.parsedArguments = chunk.input\n      }\n    }\n\n    // Update UIMessage if we have a current assistant message and a result\n    if (this.currentAssistantMessageId && chunk.result) {\n      const state: ToolResultState = 'complete'\n\n      // Step 1: Update the tool-call part's output field (for UI consistency\n      // with client tools — see GitHub issue #176)\n      let output: unknown\n      try {\n        output = JSON.parse(chunk.result)\n      } catch {\n        output = chunk.result\n      }\n      this.messages = updateToolCallWithOutput(\n        this.messages,\n        chunk.toolCallId,\n        output,\n      )\n\n      // Step 2: Create/update the tool-result part (for LLM conversation history)\n      this.messages = updateToolResultPart(\n        this.messages,\n        this.currentAssistantMessageId,\n        chunk.toolCallId,\n        chunk.result,\n        state,\n      )\n      this.emitMessagesChange()\n    }\n  }\n\n  /**\n   * Handle RUN_FINISHED event.\n   *\n   * Records the finishReason and calls completeAllToolCalls() as a safety net\n   * to force-complete any tool calls that didn't receive an explicit TOOL_CALL_END.\n   * This handles cases like aborted streams or adapter bugs.\n   *\n   * @see docs/chat-architecture.md#single-shot-tool-call-response — finishReason semantics\n   * @see docs/chat-architecture.md#adapter-contract — Why RUN_FINISHED is mandatory\n   */\n  private handleRunFinishedEvent(\n    chunk: Extract<StreamChunk, { type: 'RUN_FINISHED' }>,\n  ): void {\n    this.finishReason = chunk.finishReason\n    this.isDone = true\n    this.completeAllToolCalls()\n  }\n\n  /**\n   * Handle RUN_ERROR event\n   */\n  private handleRunErrorEvent(\n    chunk: Extract<StreamChunk, { type: 'RUN_ERROR' }>,\n  ): void {\n    this.hasError = true\n    this.ensureAssistantMessage()\n    // Emit error event\n    this.events.onError?.(new Error(chunk.error.message || 'An error occurred'))\n  }\n\n  /**\n   * Handle STEP_FINISHED event (for thinking/reasoning content).\n   *\n   * Accumulates delta into thinkingContent and updates a single ThinkingPart\n   * in the UIMessage (replaced in-place, not appended).\n   *\n   * @see docs/chat-architecture.md#thinkingreasoning-content — Thinking flow\n   */\n  private handleStepFinishedEvent(\n    chunk: Extract<StreamChunk, { type: 'STEP_FINISHED' }>,\n  ): void {\n    this.ensureAssistantMessage()\n\n    this.thinkingContent += chunk.delta\n\n    // Update UIMessage\n    if (this.currentAssistantMessageId) {\n      this.messages = updateThinkingPart(\n        this.messages,\n        this.currentAssistantMessageId,\n        this.thinkingContent,\n      )\n      this.emitMessagesChange()\n\n      // Emit granular event\n      this.events.onThinkingUpdate?.(\n        this.currentAssistantMessageId,\n        this.thinkingContent,\n      )\n    }\n  }\n\n  /**\n   * Handle CUSTOM event.\n   *\n   * Handles special custom events emitted by the TextEngine (not adapters):\n   * - 'tool-input-available': Client tool needs execution. Fires onToolCall.\n   * - 'approval-requested': Tool needs user approval. Updates tool-call part\n   *   state and fires onApprovalRequest.\n   *\n   * @see docs/chat-architecture.md#client-tools-and-approval-flows — Full flow details\n   */\n  private handleCustomEvent(\n    chunk: Extract<StreamChunk, { type: 'CUSTOM' }>,\n  ): void {\n    // Handle client tool input availability - trigger client-side execution\n    if (chunk.name === 'tool-input-available' && chunk.data) {\n      const { toolCallId, toolName, input } = chunk.data as {\n        toolCallId: string\n        toolName: string\n        input: any\n      }\n\n      // Emit onToolCall event for the client to execute the tool\n      this.events.onToolCall?.({\n        toolCallId,\n        toolName,\n        input,\n      })\n    }\n\n    // Handle approval requests\n    if (chunk.name === 'approval-requested' && chunk.data) {\n      const { toolCallId, toolName, input, approval } = chunk.data as {\n        toolCallId: string\n        toolName: string\n        input: any\n        approval: { id: string; needsApproval: boolean }\n      }\n\n      // Update the tool call part with approval state\n      if (this.currentAssistantMessageId) {\n        this.messages = updateToolCallApproval(\n          this.messages,\n          this.currentAssistantMessageId,\n          toolCallId,\n          approval.id,\n        )\n        this.emitMessagesChange()\n      }\n\n      // Emit approval request event\n      this.events.onApprovalRequest?.({\n        toolCallId,\n        toolName,\n        input,\n        approvalId: approval.id,\n      })\n    }\n  }\n\n  /**\n   * Complete all tool calls — safety net for stream termination.\n   *\n   * Called by RUN_FINISHED and finalizeStream(). Force-transitions any tool call\n   * not yet in input-complete state. Handles cases where TOOL_CALL_END was\n   * missed (adapter bug, network error, aborted stream).\n   *\n   * @see docs/chat-architecture.md#single-shot-tool-call-response — Safety net behavior\n   */\n  private completeAllToolCalls(): void {\n    this.toolCalls.forEach((toolCall, id) => {\n      if (toolCall.state !== 'input-complete') {\n        const index = this.toolCallOrder.indexOf(id)\n        this.completeToolCall(index, toolCall)\n      }\n    })\n  }\n\n  /**\n   * Mark a tool call as complete and emit event\n   */\n  private completeToolCall(\n    _index: number,\n    toolCall: InternalToolCallState,\n  ): void {\n    toolCall.state = 'input-complete'\n\n    // Try final parse\n    toolCall.parsedArguments = this.jsonParser.parse(toolCall.arguments)\n\n    // Update UIMessage\n    if (this.currentAssistantMessageId) {\n      this.messages = updateToolCallPart(\n        this.messages,\n        this.currentAssistantMessageId,\n        {\n          id: toolCall.id,\n          name: toolCall.name,\n          arguments: toolCall.arguments,\n          state: 'input-complete',\n        },\n      )\n      this.emitMessagesChange()\n\n      // Emit granular event\n      this.events.onToolCallStateChange?.(\n        this.currentAssistantMessageId,\n        toolCall.id,\n        'input-complete',\n        toolCall.arguments,\n      )\n    }\n  }\n\n  /**\n   * Emit pending text update.\n   *\n   * Calls updateTextPart() which has critical append-vs-replace logic:\n   * - If last UIMessage part is TextPart → replaces its content (same segment).\n   * - If last part is anything else → pushes new TextPart (new segment after tools).\n   *\n   * @see docs/chat-architecture.md#uimessage-part-ordering-invariants — Replace vs. push logic\n   */\n  private emitTextUpdate(): void {\n    this.lastEmittedText = this.currentSegmentText\n\n    // Update UIMessage\n    if (this.currentAssistantMessageId) {\n      this.messages = updateTextPart(\n        this.messages,\n        this.currentAssistantMessageId,\n        this.currentSegmentText,\n      )\n      this.emitMessagesChange()\n\n      // Emit granular event\n      this.events.onTextUpdate?.(\n        this.currentAssistantMessageId,\n        this.currentSegmentText,\n      )\n    }\n  }\n\n  /**\n   * Emit messages change event\n   */\n  private emitMessagesChange(): void {\n    this.events.onMessagesChange?.([...this.messages])\n  }\n\n  /**\n   * Finalize the stream — complete all pending operations.\n   *\n   * Called when the async iterable ends (stream closed). Acts as the final\n   * safety net: completes any remaining tool calls, flushes un-emitted text,\n   * and fires onStreamEnd.\n   *\n   * @see docs/chat-architecture.md#single-shot-text-response — Finalization step\n   */\n  finalizeStream(): void {\n    // Safety net: complete any remaining tool calls (e.g. on network errors / aborted streams)\n    this.completeAllToolCalls()\n\n    // Emit any pending text if not already emitted\n    if (this.currentSegmentText !== this.lastEmittedText) {\n      this.emitTextUpdate()\n    }\n\n    // Remove the assistant message if it only contains whitespace text\n    // (no tool calls, no meaningful content). This handles models like Gemini\n    // that sometimes return just \"\\n\" during auto-continuation.\n    // Preserve the message on errors so the UI can show error state.\n    if (this.currentAssistantMessageId && !this.hasError) {\n      const assistantMessage = this.messages.find(\n        (m) => m.id === this.currentAssistantMessageId,\n      )\n      if (assistantMessage && this.isWhitespaceOnlyMessage(assistantMessage)) {\n        this.messages = this.messages.filter(\n          (m) => m.id !== this.currentAssistantMessageId,\n        )\n        this.emitMessagesChange()\n        this.currentAssistantMessageId = null\n        return\n      }\n    }\n\n    // Emit stream end event (only if a message was actually created)\n    if (this.currentAssistantMessageId) {\n      const assistantMessage = this.messages.find(\n        (m) => m.id === this.currentAssistantMessageId,\n      )\n      if (assistantMessage) {\n        this.events.onStreamEnd?.(assistantMessage)\n      }\n    }\n  }\n\n  /**\n   * Get completed tool calls in API format\n   */\n  private getCompletedToolCalls(): Array<ToolCall> {\n    return Array.from(this.toolCalls.values())\n      .filter((tc) => tc.state === 'input-complete')\n      .map((tc) => ({\n        id: tc.id,\n        type: 'function' as const,\n        function: {\n          name: tc.name,\n          arguments: tc.arguments,\n        },\n      }))\n  }\n\n  /**\n   * Get current result\n   */\n  private getResult(): ProcessorResult {\n    const toolCalls = this.getCompletedToolCalls()\n    return {\n      content: this.totalTextContent,\n      thinking: this.thinkingContent || undefined,\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n      finishReason: this.finishReason,\n    }\n  }\n\n  /**\n   * Get current processor state\n   */\n  getState(): ProcessorState {\n    return {\n      content: this.totalTextContent,\n      thinking: this.thinkingContent,\n      toolCalls: new Map(this.toolCalls),\n      toolCallOrder: [...this.toolCallOrder],\n      finishReason: this.finishReason,\n      done: this.isDone,\n    }\n  }\n\n  /**\n   * Start recording chunks\n   */\n  startRecording(): void {\n    this.recordingEnabled = true\n    this.recordingStartTime = Date.now()\n    this.recording = {\n      version: '1.0',\n      timestamp: this.recordingStartTime,\n      chunks: [],\n    }\n  }\n\n  /**\n   * Get the current recording\n   */\n  getRecording(): ChunkRecording | null {\n    return this.recording\n  }\n\n  /**\n   * Reset stream state (but keep messages)\n   */\n  private resetStreamState(): void {\n    this.totalTextContent = ''\n    this.currentSegmentText = ''\n    this.lastEmittedText = ''\n    this.thinkingContent = ''\n    this.toolCalls.clear()\n    this.toolCallOrder = []\n    this.finishReason = null\n    this.hasError = false\n    this.isDone = false\n    this.chunkStrategy.reset?.()\n  }\n\n  /**\n   * Full reset (including messages)\n   */\n  reset(): void {\n    this.resetStreamState()\n    this.messages = []\n    this.currentAssistantMessageId = null\n  }\n\n  /**\n   * Check if a message contains only whitespace text and no other meaningful parts\n   * (no tool calls, tool results, thinking, etc.)\n   */\n  private isWhitespaceOnlyMessage(message: UIMessage): boolean {\n    if (message.parts.length === 0) return false\n    return message.parts.every(\n      (part) => part.type === 'text' && part.content.trim() === '',\n    )\n  }\n\n  /**\n   * Replay a recording through the processor\n   */\n  static async replay(\n    recording: ChunkRecording,\n    options?: StreamProcessorOptions,\n  ): Promise<ProcessorResult> {\n    const processor = new StreamProcessor(options)\n    return processor.process(createReplayStream(recording))\n  }\n}\n\n/**\n * Create an async iterable from a recording\n */\nexport function createReplayStream(\n  recording: ChunkRecording,\n): AsyncIterable<StreamChunk> {\n  return {\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async *[Symbol.asyncIterator]() {\n      for (const { chunk } of recording.chunks) {\n        yield chunk\n      }\n    },\n  }\n}\n"],"names":[],"mappings":"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"}