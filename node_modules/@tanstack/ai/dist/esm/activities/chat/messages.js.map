{"version":3,"file":"messages.js","sources":["../../../../src/activities/chat/messages.ts"],"sourcesContent":["import type {\n  ContentPart,\n  MessagePart,\n  ModelMessage,\n  TextPart,\n  ToolCallPart,\n  UIMessage,\n} from '../../types'\n// ===========================\n// Message Converters\n// ===========================\n\n/**\n * Check if a MessagePart is a content part (text, image, audio, video, document)\n * that maps directly to a ModelMessage ContentPart.\n */\nfunction isContentPart(part: MessagePart): part is ContentPart {\n  return (\n    part.type === 'text' ||\n    part.type === 'image' ||\n    part.type === 'audio' ||\n    part.type === 'video' ||\n    part.type === 'document'\n  )\n}\n\n/**\n * Collapse an array of ContentParts into the most compact ModelMessage content:\n * - Empty array → null\n * - All text parts → joined string (or null if empty)\n * - Mixed content → ContentPart array as-is\n */\nfunction collapseContentParts(\n  parts: Array<ContentPart>,\n): string | null | Array<ContentPart> {\n  if (parts.length === 0) return null\n\n  const allText = parts.every((p) => p.type === 'text')\n  if (allText) {\n    const joined = parts.map((p) => p.content).join('')\n    return joined || null\n  }\n\n  return parts\n}\n\n/**\n * Extract text content from ModelMessage content (string, null, or ContentPart array).\n * Used when only the text portion is needed (e.g., tool result content).\n */\nfunction getTextContent(content: string | null | Array<ContentPart>): string {\n  if (content === null) return ''\n  if (typeof content === 'string') return content\n  return content\n    .filter((part): part is TextPart => part.type === 'text')\n    .map((part) => part.content)\n    .join('')\n}\n\n/**\n * Convert UIMessages or ModelMessages to ModelMessages\n */\nexport function convertMessagesToModelMessages(\n  messages: Array<UIMessage | ModelMessage>,\n): Array<ModelMessage> {\n  const modelMessages: Array<ModelMessage> = []\n  for (const msg of messages) {\n    if ('parts' in msg) {\n      // UIMessage - convert to ModelMessages\n      modelMessages.push(...uiMessageToModelMessages(msg))\n    } else {\n      // Already ModelMessage\n      modelMessages.push(msg)\n    }\n  }\n  return modelMessages\n}\n\n/**\n * Convert a UIMessage to ModelMessage(s)\n *\n * Walks the parts array IN ORDER to preserve the interleaving of text,\n * tool calls, and tool results. This is critical for multi-round tool\n * flows where the model generates text, calls a tool, gets the result,\n * then generates more text and calls another tool.\n *\n * The output preserves the sequential structure:\n *   text1 → toolCall1 → toolResult1 → text2 → toolCall2 → toolResult2\n * becomes:\n *   assistant: {content: \"text1\", toolCalls: [toolCall1]}\n *   tool: toolResult1\n *   assistant: {content: \"text2\", toolCalls: [toolCall2]}\n *   tool: toolResult2\n *\n * @param uiMessage - The UIMessage to convert\n * @returns An array of ModelMessages preserving part ordering\n */\nexport function uiMessageToModelMessages(\n  uiMessage: UIMessage,\n): Array<ModelMessage> {\n  // Skip system messages - they're handled via systemPrompts, not ModelMessages\n  if (uiMessage.role === 'system') {\n    return []\n  }\n\n  // For non-assistant messages (user), use the simpler path since they\n  // don't have tool calls or tool results to interleave\n  if (uiMessage.role !== 'assistant') {\n    return [buildUserOrToolMessage(uiMessage)]\n  }\n\n  // For assistant messages, walk parts in order to preserve interleaving\n  return buildAssistantMessages(uiMessage)\n}\n\n/**\n * Build a single ModelMessage for user messages (simple path).\n * Preserves ordering of text and multimodal content parts.\n */\nfunction buildUserOrToolMessage(uiMessage: UIMessage): ModelMessage {\n  const contentParts: Array<ContentPart> = []\n  for (const part of uiMessage.parts) {\n    if (isContentPart(part)) {\n      contentParts.push(part)\n    }\n  }\n\n  return {\n    role: uiMessage.role as 'user' | 'assistant' | 'tool',\n    content: collapseContentParts(contentParts),\n  }\n}\n\n// Accumulator for building an assistant segment (content + tool calls)\ninterface AssistantSegment {\n  contentParts: Array<ContentPart>\n  toolCalls: Array<{\n    id: string\n    type: 'function'\n    function: { name: string; arguments: string }\n  }>\n}\n\nfunction createSegment(): AssistantSegment {\n  return { contentParts: [], toolCalls: [] }\n}\n\nfunction isToolCallIncluded(part: ToolCallPart): boolean {\n  return (\n    part.state === 'input-complete' ||\n    part.state === 'approval-responded' ||\n    part.output !== undefined\n  )\n}\n\n/**\n * Build ModelMessages for an assistant UIMessage, preserving the\n * sequential interleaving of text, tool calls, and tool results.\n *\n * Walks parts in order. Text and tool-call parts accumulate into the\n * current \"segment\". When a tool-result part is encountered, the\n * current segment is flushed as an assistant message, then the tool\n * result is emitted as a tool message.\n */\nfunction buildAssistantMessages(uiMessage: UIMessage): Array<ModelMessage> {\n  const messageList: Array<ModelMessage> = []\n  let current = createSegment()\n\n  // Track emitted tool result IDs to avoid duplicates.\n  // A tool call can have BOTH an explicit tool-result part AND an output\n  // field on the tool-call part. We only want one per tool call ID.\n  const emittedToolResultIds = new Set<string>()\n\n  function flushSegment(): void {\n    const content = collapseContentParts(current.contentParts)\n    const hasContent = content !== null\n    const hasToolCalls = current.toolCalls.length > 0\n\n    if (hasContent || hasToolCalls) {\n      messageList.push({\n        role: 'assistant',\n        content,\n        ...(hasToolCalls && { toolCalls: current.toolCalls }),\n      })\n    }\n    current = createSegment()\n  }\n\n  for (const part of uiMessage.parts) {\n    switch (part.type) {\n      case 'text':\n      case 'image':\n      case 'audio':\n      case 'video':\n      case 'document':\n        current.contentParts.push(part)\n        break\n\n      case 'tool-call':\n        if (isToolCallIncluded(part)) {\n          current.toolCalls.push({\n            id: part.id,\n            type: 'function' as const,\n            function: {\n              name: part.name,\n              arguments: part.arguments,\n            },\n          })\n        }\n        break\n\n      case 'tool-result':\n        // Flush the current assistant segment before emitting the tool result\n        flushSegment()\n\n        // Emit the tool result\n        if (\n          (part.state === 'complete' || part.state === 'error') &&\n          !emittedToolResultIds.has(part.toolCallId)\n        ) {\n          messageList.push({\n            role: 'tool',\n            content: part.content,\n            toolCallId: part.toolCallId,\n          })\n          emittedToolResultIds.add(part.toolCallId)\n        }\n        break\n\n      // thinking parts are skipped - they're UI-only\n      default:\n        break\n    }\n  }\n\n  // Flush any remaining accumulated content\n  flushSegment()\n\n  // Emit tool results from client tool-call parts with output or approval,\n  // but only if not already covered by an explicit tool-result part above.\n  // These are appended at the end since they don't have explicit tool-result\n  // parts in the parts array to trigger inline emission.\n  for (const part of uiMessage.parts) {\n    if (part.type !== 'tool-call') continue\n\n    // Client tool with output - add as tool result (if not already emitted)\n    if (\n      part.output !== undefined &&\n      !part.approval &&\n      !emittedToolResultIds.has(part.id)\n    ) {\n      messageList.push({\n        role: 'tool',\n        content: JSON.stringify(part.output),\n        toolCallId: part.id,\n      })\n      emittedToolResultIds.add(part.id)\n    }\n\n    // Approval response - add as tool result for iteration tracking\n    if (\n      part.state === 'approval-responded' &&\n      part.approval?.approved !== undefined &&\n      !emittedToolResultIds.has(part.id)\n    ) {\n      const approved = part.approval.approved\n      messageList.push({\n        role: 'tool',\n        content: JSON.stringify({\n          approved,\n          ...(approved && { pendingExecution: true }),\n          message: approved\n            ? 'User approved this action'\n            : 'User denied this action',\n        }),\n        toolCallId: part.id,\n      })\n      emittedToolResultIds.add(part.id)\n    }\n  }\n\n  // If no messages were produced (e.g., empty parts), emit a minimal assistant message\n  if (messageList.length === 0) {\n    messageList.push({\n      role: 'assistant',\n      content: null,\n    })\n  }\n\n  return messageList\n}\n\n/**\n * Convert a ModelMessage to UIMessage\n *\n * This conversion creates a parts-based structure:\n * - content field → TextPart\n * - toolCalls array → ToolCallPart[]\n * - role=\"tool\" messages should be converted separately and merged\n *\n * @param modelMessage - The ModelMessage to convert\n * @param id - Optional ID for the UIMessage (generated if not provided)\n * @returns A UIMessage with parts\n */\nexport function modelMessageToUIMessage(\n  modelMessage: ModelMessage,\n  id?: string,\n): UIMessage {\n  const parts: Array<MessagePart> = []\n\n  // Handle tool results (when role is \"tool\") - only produce tool-result part,\n  // not a text part (the content IS the tool result, not display text)\n  if (modelMessage.role === 'tool' && modelMessage.toolCallId) {\n    parts.push({\n      type: 'tool-result',\n      toolCallId: modelMessage.toolCallId,\n      content: getTextContent(modelMessage.content),\n      state: 'complete',\n    })\n  } else if (Array.isArray(modelMessage.content)) {\n    // Multimodal content - preserve all content parts as MessageParts\n    for (const part of modelMessage.content) {\n      parts.push(part)\n    }\n  } else {\n    // String or null content\n    const textContent = getTextContent(modelMessage.content)\n    if (textContent) {\n      parts.push({\n        type: 'text',\n        content: textContent,\n      })\n    }\n  }\n\n  // Handle tool calls\n  if (modelMessage.toolCalls && modelMessage.toolCalls.length > 0) {\n    for (const toolCall of modelMessage.toolCalls) {\n      parts.push({\n        type: 'tool-call',\n        id: toolCall.id,\n        name: toolCall.function.name,\n        arguments: toolCall.function.arguments,\n        state: 'input-complete', // Model messages have complete arguments\n      })\n    }\n  }\n\n  return {\n    id: id || generateMessageId(),\n    role: modelMessage.role === 'tool' ? 'assistant' : modelMessage.role,\n    parts,\n  }\n}\n\n/**\n * Convert an array of ModelMessages to UIMessages\n *\n * This handles merging tool result messages with their corresponding assistant messages\n *\n * @param modelMessages - Array of ModelMessages to convert\n * @returns Array of UIMessages\n */\nexport function modelMessagesToUIMessages(\n  modelMessages: Array<ModelMessage>,\n): Array<UIMessage> {\n  const uiMessages: Array<UIMessage> = []\n  let currentAssistantMessage: UIMessage | null = null\n\n  for (const msg of modelMessages) {\n    if (msg.role === 'tool') {\n      // Tool result - merge into the last assistant message if possible\n      if (\n        currentAssistantMessage &&\n        currentAssistantMessage.role === 'assistant'\n      ) {\n        currentAssistantMessage.parts.push({\n          type: 'tool-result',\n          toolCallId: msg.toolCallId!,\n          content: getTextContent(msg.content),\n          state: 'complete',\n        })\n      } else {\n        // No assistant message to merge into, create a standalone one\n        const toolResultUIMessage = modelMessageToUIMessage(msg)\n        uiMessages.push(toolResultUIMessage)\n      }\n    } else {\n      // Regular message\n      const uiMessage = modelMessageToUIMessage(msg)\n      uiMessages.push(uiMessage)\n\n      // Track assistant messages for potential tool result merging\n      if (msg.role === 'assistant') {\n        currentAssistantMessage = uiMessage\n      } else {\n        currentAssistantMessage = null\n      }\n    }\n  }\n\n  return uiMessages\n}\n\n/**\n * Normalize a message (UIMessage or ModelMessage) to a UIMessage\n * Ensures the message has an ID and createdAt timestamp\n *\n * @param message - Either a UIMessage or ModelMessage\n * @param generateId - Function to generate a message ID if needed\n * @returns A UIMessage with guaranteed id and createdAt\n */\nexport function normalizeToUIMessage(\n  message: UIMessage | ModelMessage,\n  generateId: () => string,\n): UIMessage {\n  if ('parts' in message) {\n    // Already a UIMessage\n    return {\n      ...message,\n      id: message.id || generateId(),\n      createdAt: message.createdAt || new Date(),\n    }\n  } else {\n    // ModelMessage - convert to UIMessage\n    return {\n      ...modelMessageToUIMessage(message, generateId()),\n      createdAt: new Date(),\n    }\n  }\n}\n\n/**\n * Generate a unique message ID\n */\nexport function generateMessageId(): string {\n  return `msg-${Date.now()}-${Math.random().toString(36).substring(7)}`\n}\n"],"names":[],"mappings":"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"}