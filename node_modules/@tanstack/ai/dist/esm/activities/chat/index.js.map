{"version":3,"file":"index.js","sources":["../../../../src/activities/chat/index.ts"],"sourcesContent":["/**\n * Text Activity\n *\n * Handles agentic text generation, one-shot text generation, and agentic structured output.\n * This is a self-contained module with implementation, types, and JSDoc.\n */\n\nimport { aiEventClient } from '../../event-client.js'\nimport { streamToText } from '../../stream-to-response.js'\nimport { ToolCallManager, executeToolCalls } from './tools/tool-calls'\nimport {\n  convertSchemaToJsonSchema,\n  isStandardSchema,\n  parseWithStandardSchema,\n} from './tools/schema-converter'\nimport { maxIterations as maxIterationsStrategy } from './agent-loop-strategies'\nimport { convertMessagesToModelMessages } from './messages'\nimport type {\n  ApprovalRequest,\n  ClientToolRequest,\n  ToolResult,\n} from './tools/tool-calls'\nimport type { AnyTextAdapter } from './adapter'\nimport type {\n  AgentLoopStrategy,\n  ConstrainedModelMessage,\n  InferSchemaType,\n  ModelMessage,\n  RunFinishedEvent,\n  SchemaInput,\n  StreamChunk,\n  TextMessageContentEvent,\n  TextOptions,\n  Tool,\n  ToolCall,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from '../../types'\n\n// ===========================\n// Activity Kind\n// ===========================\n\n/** The adapter kind this activity handles */\nexport const kind = 'text' as const\n\n// ===========================\n// Activity Options Type\n// ===========================\n\n/**\n * Options for the text activity.\n * Types are extracted directly from the adapter (which has pre-resolved generics).\n *\n * @template TAdapter - The text adapter type (created by a provider function)\n * @template TSchema - Optional Standard Schema for structured output\n * @template TStream - Whether to stream the output (default: true)\n */\nexport interface TextActivityOptions<\n  TAdapter extends AnyTextAdapter,\n  TSchema extends SchemaInput | undefined,\n  TStream extends boolean,\n> {\n  /** The text adapter to use (created by a provider function like openaiText('gpt-4o')) */\n  adapter: TAdapter\n  /** Conversation messages - content types are constrained by the adapter's input modalities and metadata */\n  messages?: Array<\n    ConstrainedModelMessage<{\n      inputModalities: TAdapter['~types']['inputModalities']\n      messageMetadataByModality: TAdapter['~types']['messageMetadataByModality']\n    }>\n  >\n  /** System prompts to prepend to the conversation */\n  systemPrompts?: TextOptions['systemPrompts']\n  /** Tools for function calling (auto-executed when called) */\n  tools?: TextOptions['tools']\n  /** Controls the randomness of the output. Higher values make output more random. Range: [0.0, 2.0] */\n  temperature?: TextOptions['temperature']\n  /** Nucleus sampling parameter. The model considers tokens with topP probability mass. */\n  topP?: TextOptions['topP']\n  /** The maximum number of tokens to generate in the response. */\n  maxTokens?: TextOptions['maxTokens']\n  /** Additional metadata to attach to the request. */\n  metadata?: TextOptions['metadata']\n  /** Model-specific provider options (type comes from adapter) */\n  modelOptions?: TAdapter['~types']['providerOptions']\n  /** AbortController for cancellation */\n  abortController?: TextOptions['abortController']\n  /** Strategy for controlling the agent loop */\n  agentLoopStrategy?: TextOptions['agentLoopStrategy']\n  /** Unique conversation identifier for tracking */\n  conversationId?: TextOptions['conversationId']\n  /**\n   * Optional Standard Schema for structured output.\n   * When provided, the activity will:\n   * 1. Run the full agentic loop (executing tools as needed)\n   * 2. Once complete, return a Promise with the parsed output matching the schema\n   *\n   * Supports any Standard Schema compliant library (Zod v4+, ArkType, Valibot, etc.)\n   *\n   * @example\n   * ```ts\n   * const result = await chat({\n   *   adapter: openaiText('gpt-4o'),\n   *   messages: [{ role: 'user', content: 'Generate a person' }],\n   *   outputSchema: z.object({ name: z.string(), age: z.number() })\n   * })\n   * // result is { name: string, age: number }\n   * ```\n   */\n  outputSchema?: TSchema\n  /**\n   * Whether to stream the text result.\n   * When true (default), returns an AsyncIterable<StreamChunk> for streaming output.\n   * When false, returns a Promise<string> with the collected text content.\n   *\n   * Note: If outputSchema is provided, this option is ignored and the result\n   * is always a Promise<InferSchemaType<TSchema>>.\n   *\n   * @default true\n   *\n   * @example Non-streaming text\n   * ```ts\n   * const text = await chat({\n   *   adapter: openaiText('gpt-4o'),\n   *   messages: [{ role: 'user', content: 'Hello!' }],\n   *   stream: false\n   * })\n   * // text is a string with the full response\n   * ```\n   */\n  stream?: TStream\n}\n\n// ===========================\n// Chat Options Helper\n// ===========================\n\n/**\n * Create typed options for the chat() function without executing.\n * This is useful for pre-defining configurations with full type inference.\n *\n * @example\n * ```ts\n * const chatOptions = createChatOptions({\n *   adapter: anthropicText('claude-sonnet-4-5'),\n * })\n *\n * const stream = chat({ ...chatOptions, messages })\n * ```\n */\nexport function createChatOptions<\n  TAdapter extends AnyTextAdapter,\n  TSchema extends SchemaInput | undefined = undefined,\n  TStream extends boolean = true,\n>(\n  options: TextActivityOptions<TAdapter, TSchema, TStream>,\n): TextActivityOptions<TAdapter, TSchema, TStream> {\n  return options\n}\n\n// ===========================\n// Activity Result Type\n// ===========================\n\n/**\n * Result type for the text activity.\n * - If outputSchema is provided: Promise<InferSchemaType<TSchema>>\n * - If stream is false: Promise<string>\n * - Otherwise (stream is true, default): AsyncIterable<StreamChunk>\n */\nexport type TextActivityResult<\n  TSchema extends SchemaInput | undefined,\n  TStream extends boolean = true,\n> = TSchema extends SchemaInput\n  ? Promise<InferSchemaType<TSchema>>\n  : TStream extends false\n    ? Promise<string>\n    : AsyncIterable<StreamChunk>\n\n// ===========================\n// ChatEngine Implementation\n// ===========================\n\ninterface TextEngineConfig<\n  TAdapter extends AnyTextAdapter,\n  TParams extends TextOptions<any, any> = TextOptions<any>,\n> {\n  adapter: TAdapter\n  systemPrompts?: Array<string>\n  params: TParams\n}\n\ntype ToolPhaseResult = 'continue' | 'stop' | 'wait'\ntype CyclePhase = 'processText' | 'executeToolCalls'\n\nclass TextEngine<\n  TAdapter extends AnyTextAdapter,\n  TParams extends TextOptions<any, any> = TextOptions<any>,\n> {\n  private readonly adapter: TAdapter\n  private readonly params: TParams\n  private readonly systemPrompts: Array<string>\n  private readonly tools: ReadonlyArray<Tool>\n  private readonly loopStrategy: AgentLoopStrategy\n  private readonly toolCallManager: ToolCallManager\n  private readonly initialMessageCount: number\n  private readonly requestId: string\n  private readonly streamId: string\n  private readonly effectiveRequest?: Request | RequestInit\n  private readonly effectiveSignal?: AbortSignal\n\n  private messages: Array<ModelMessage>\n  private iterationCount = 0\n  private lastFinishReason: string | null = null\n  private streamStartTime = 0\n  private totalChunkCount = 0\n  private currentMessageId: string | null = null\n  private accumulatedContent = ''\n  private eventOptions?: Record<string, unknown>\n  private eventToolNames?: Array<string>\n  private finishedEvent: RunFinishedEvent | null = null\n  private shouldEmitStreamEnd = true\n  private earlyTermination = false\n  private toolPhase: ToolPhaseResult = 'continue'\n  private cyclePhase: CyclePhase = 'processText'\n  // Client state extracted from initial messages (before conversion to ModelMessage)\n  private readonly initialApprovals: Map<string, boolean>\n  private readonly initialClientToolResults: Map<string, any>\n\n  constructor(config: TextEngineConfig<TAdapter, TParams>) {\n    this.adapter = config.adapter\n    this.params = config.params\n    this.systemPrompts = config.params.systemPrompts || []\n    this.tools = config.params.tools || []\n    this.loopStrategy =\n      config.params.agentLoopStrategy || maxIterationsStrategy(5)\n    this.toolCallManager = new ToolCallManager(this.tools)\n    this.initialMessageCount = config.params.messages.length\n\n    // Extract client state (approvals, client tool results) from original messages BEFORE conversion\n    // This preserves UIMessage parts data that would be lost during conversion to ModelMessage\n    const { approvals, clientToolResults } =\n      this.extractClientStateFromOriginalMessages(\n        config.params.messages as Array<any>,\n      )\n    this.initialApprovals = approvals\n    this.initialClientToolResults = clientToolResults\n\n    // Convert messages to ModelMessage format (handles both UIMessage and ModelMessage input)\n    // This ensures consistent internal format regardless of what the client sends\n    this.messages = convertMessagesToModelMessages(\n      config.params.messages as Array<any>,\n    )\n    this.requestId = this.createId('chat')\n    this.streamId = this.createId('stream')\n    this.effectiveRequest = config.params.abortController\n      ? { signal: config.params.abortController.signal }\n      : undefined\n    this.effectiveSignal = config.params.abortController?.signal\n  }\n\n  /** Get the accumulated content after the chat loop completes */\n  getAccumulatedContent(): string {\n    return this.accumulatedContent\n  }\n\n  /** Get the final messages array after the chat loop completes */\n  getMessages(): Array<ModelMessage> {\n    return this.messages\n  }\n\n  async *run(): AsyncGenerator<StreamChunk> {\n    this.beforeRun()\n\n    try {\n      const pendingPhase = yield* this.checkForPendingToolCalls()\n      if (pendingPhase === 'wait') {\n        return\n      }\n\n      do {\n        if (this.earlyTermination || this.isAborted()) {\n          return\n        }\n\n        this.beginCycle()\n\n        if (this.cyclePhase === 'processText') {\n          yield* this.streamModelResponse()\n        } else {\n          yield* this.processToolCalls()\n        }\n\n        this.endCycle()\n      } while (this.shouldContinue())\n    } finally {\n      this.afterRun()\n    }\n  }\n\n  private beforeRun(): void {\n    this.streamStartTime = Date.now()\n    const { tools, temperature, topP, maxTokens, metadata } = this.params\n\n    // Gather flattened options into an object for event emission\n    const options: Record<string, unknown> = {}\n    if (temperature !== undefined) options.temperature = temperature\n    if (topP !== undefined) options.topP = topP\n    if (maxTokens !== undefined) options.maxTokens = maxTokens\n    if (metadata !== undefined) options.metadata = metadata\n\n    this.eventOptions = Object.keys(options).length > 0 ? options : undefined\n    this.eventToolNames = tools?.map((t) => t.name)\n\n    aiEventClient.emit('text:request:started', {\n      ...this.buildTextEventContext(),\n      timestamp: Date.now(),\n    })\n\n    // Always emit messages for tracking:\n    // - For existing conversations (with conversationId): only emit the latest user message\n    // - For new conversations (without conversationId): emit all messages for reconstruction\n    const messagesToEmit = this.params.conversationId\n      ? this.messages.slice(-1).filter((m) => m.role === 'user')\n      : this.messages\n\n    messagesToEmit.forEach((message, index) => {\n      const messageIndex = this.params.conversationId\n        ? this.messages.length - 1\n        : index\n      const messageId = this.createId('msg')\n      const baseContext = this.buildTextEventContext()\n      const content = this.getContentString(message.content)\n\n      aiEventClient.emit('text:message:created', {\n        ...baseContext,\n        messageId,\n        role: message.role,\n        content,\n        toolCalls: message.toolCalls,\n        messageIndex,\n        timestamp: Date.now(),\n      })\n\n      if (message.role === 'user') {\n        aiEventClient.emit('text:message:user', {\n          ...baseContext,\n          messageId,\n          role: 'user',\n          content,\n          messageIndex,\n          timestamp: Date.now(),\n        })\n      }\n    })\n  }\n\n  private afterRun(): void {\n    if (!this.shouldEmitStreamEnd) {\n      return\n    }\n\n    const now = Date.now()\n    // Emit text:request:completed with final state\n    aiEventClient.emit('text:request:completed', {\n      ...this.buildTextEventContext(),\n      content: this.accumulatedContent,\n      messageId: this.currentMessageId || undefined,\n      finishReason: this.lastFinishReason || undefined,\n      usage: this.finishedEvent?.usage,\n      duration: now - this.streamStartTime,\n      timestamp: now,\n    })\n  }\n\n  private beginCycle(): void {\n    if (this.cyclePhase === 'processText') {\n      this.beginIteration()\n    }\n  }\n\n  private endCycle(): void {\n    if (this.cyclePhase === 'processText') {\n      this.cyclePhase = 'executeToolCalls'\n      return\n    }\n\n    this.cyclePhase = 'processText'\n    this.iterationCount++\n  }\n\n  private beginIteration(): void {\n    this.currentMessageId = this.createId('msg')\n    this.accumulatedContent = ''\n    this.finishedEvent = null\n\n    const baseContext = this.buildTextEventContext()\n    aiEventClient.emit('text:message:created', {\n      ...baseContext,\n      messageId: this.currentMessageId,\n      role: 'assistant',\n      content: '',\n      timestamp: Date.now(),\n    })\n  }\n\n  private async *streamModelResponse(): AsyncGenerator<StreamChunk> {\n    const { temperature, topP, maxTokens, metadata, modelOptions } = this.params\n    const tools = this.params.tools\n\n    // Convert tool schemas to JSON Schema before passing to adapter\n    const toolsWithJsonSchemas = tools?.map((tool) => ({\n      ...tool,\n      inputSchema: tool.inputSchema\n        ? convertSchemaToJsonSchema(tool.inputSchema)\n        : undefined,\n      outputSchema: tool.outputSchema\n        ? convertSchemaToJsonSchema(tool.outputSchema)\n        : undefined,\n    }))\n\n    for await (const chunk of this.adapter.chatStream({\n      model: this.params.model,\n      messages: this.messages,\n      tools: toolsWithJsonSchemas,\n      temperature,\n      topP,\n      maxTokens,\n      metadata,\n      request: this.effectiveRequest,\n      modelOptions,\n      systemPrompts: this.systemPrompts,\n    })) {\n      if (this.isAborted()) {\n        break\n      }\n\n      this.totalChunkCount++\n\n      yield chunk\n      this.handleStreamChunk(chunk)\n\n      if (this.earlyTermination) {\n        break\n      }\n    }\n  }\n\n  private handleStreamChunk(chunk: StreamChunk): void {\n    switch (chunk.type) {\n      // AG-UI Events\n      case 'TEXT_MESSAGE_CONTENT':\n        this.handleTextMessageContentEvent(chunk)\n        break\n      case 'TOOL_CALL_START':\n        this.handleToolCallStartEvent(chunk)\n        break\n      case 'TOOL_CALL_ARGS':\n        this.handleToolCallArgsEvent(chunk)\n        break\n      case 'TOOL_CALL_END':\n        this.handleToolCallEndEvent(chunk)\n        break\n      case 'RUN_FINISHED':\n        this.handleRunFinishedEvent(chunk)\n        break\n      case 'RUN_ERROR':\n        this.handleRunErrorEvent(chunk)\n        break\n      case 'STEP_FINISHED':\n        this.handleStepFinishedEvent(chunk)\n        break\n\n      default:\n        // RUN_STARTED, TEXT_MESSAGE_START, TEXT_MESSAGE_END, STEP_STARTED,\n        // STATE_SNAPSHOT, STATE_DELTA, CUSTOM\n        // - no special handling needed in chat activity\n        break\n    }\n  }\n\n  // ===========================\n  // AG-UI Event Handlers\n  // ===========================\n\n  private handleTextMessageContentEvent(chunk: TextMessageContentEvent): void {\n    if (chunk.content) {\n      this.accumulatedContent = chunk.content\n    } else {\n      this.accumulatedContent += chunk.delta\n    }\n    aiEventClient.emit('text:chunk:content', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      content: this.accumulatedContent,\n      delta: chunk.delta,\n      timestamp: Date.now(),\n    })\n  }\n\n  private handleToolCallStartEvent(chunk: ToolCallStartEvent): void {\n    this.toolCallManager.addToolCallStartEvent(chunk)\n    aiEventClient.emit('text:chunk:tool-call', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      toolCallId: chunk.toolCallId,\n      toolName: chunk.toolName,\n      index: chunk.index ?? 0,\n      arguments: '',\n      timestamp: Date.now(),\n    })\n  }\n\n  private handleToolCallArgsEvent(chunk: ToolCallArgsEvent): void {\n    this.toolCallManager.addToolCallArgsEvent(chunk)\n    aiEventClient.emit('text:chunk:tool-call', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      toolCallId: chunk.toolCallId,\n      toolName: '',\n      index: 0,\n      arguments: chunk.delta,\n      timestamp: Date.now(),\n    })\n  }\n\n  private handleToolCallEndEvent(chunk: ToolCallEndEvent): void {\n    this.toolCallManager.completeToolCall(chunk)\n    aiEventClient.emit('text:chunk:tool-result', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      toolCallId: chunk.toolCallId,\n      result: chunk.result || '',\n      timestamp: Date.now(),\n    })\n  }\n\n  private handleRunFinishedEvent(chunk: RunFinishedEvent): void {\n    aiEventClient.emit('text:chunk:done', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      finishReason: chunk.finishReason,\n      usage: chunk.usage,\n      timestamp: Date.now(),\n    })\n\n    if (chunk.usage) {\n      aiEventClient.emit('text:usage', {\n        ...this.buildTextEventContext(),\n        messageId: this.currentMessageId || undefined,\n        usage: chunk.usage,\n        timestamp: Date.now(),\n      })\n    }\n\n    this.finishedEvent = chunk\n    this.lastFinishReason = chunk.finishReason\n  }\n\n  private handleRunErrorEvent(\n    chunk: Extract<StreamChunk, { type: 'RUN_ERROR' }>,\n  ): void {\n    aiEventClient.emit('text:chunk:error', {\n      ...this.buildTextEventContext(),\n      messageId: this.currentMessageId || undefined,\n      error: chunk.error.message,\n      timestamp: Date.now(),\n    })\n    this.earlyTermination = true\n    this.shouldEmitStreamEnd = false\n  }\n\n  private handleStepFinishedEvent(\n    chunk: Extract<StreamChunk, { type: 'STEP_FINISHED' }>,\n  ): void {\n    // Handle thinking/reasoning content from STEP_FINISHED events\n    if (chunk.content || chunk.delta) {\n      aiEventClient.emit('text:chunk:thinking', {\n        ...this.buildTextEventContext(),\n        messageId: this.currentMessageId || undefined,\n        content: chunk.content || '',\n        delta: chunk.delta,\n        timestamp: Date.now(),\n      })\n    }\n  }\n\n  private async *checkForPendingToolCalls(): AsyncGenerator<\n    StreamChunk,\n    ToolPhaseResult,\n    void\n  > {\n    const pendingToolCalls = this.getPendingToolCallsFromMessages()\n    if (pendingToolCalls.length === 0) {\n      return 'continue'\n    }\n\n    const finishEvent = this.createSyntheticFinishedEvent()\n\n    const { approvals, clientToolResults } = this.collectClientState()\n\n    const executionResult = await executeToolCalls(\n      pendingToolCalls,\n      this.tools,\n      approvals,\n      clientToolResults,\n    )\n\n    if (\n      executionResult.needsApproval.length > 0 ||\n      executionResult.needsClientExecution.length > 0\n    ) {\n      for (const chunk of this.emitApprovalRequests(\n        executionResult.needsApproval,\n        finishEvent,\n      )) {\n        yield chunk\n      }\n\n      for (const chunk of this.emitClientToolInputs(\n        executionResult.needsClientExecution,\n        finishEvent,\n      )) {\n        yield chunk\n      }\n\n      this.shouldEmitStreamEnd = false\n      return 'wait'\n    }\n\n    const toolResultChunks = this.emitToolResults(\n      executionResult.results,\n      finishEvent,\n    )\n\n    for (const chunk of toolResultChunks) {\n      yield chunk\n    }\n\n    return 'continue'\n  }\n\n  private async *processToolCalls(): AsyncGenerator<StreamChunk, void, void> {\n    if (!this.shouldExecuteToolPhase()) {\n      this.setToolPhase('stop')\n      return\n    }\n\n    const toolCalls = this.toolCallManager.getToolCalls()\n    const finishEvent = this.finishedEvent\n\n    if (!finishEvent || toolCalls.length === 0) {\n      this.setToolPhase('stop')\n      return\n    }\n\n    this.addAssistantToolCallMessage(toolCalls)\n\n    const { approvals, clientToolResults } = this.collectClientState()\n\n    const executionResult = await executeToolCalls(\n      toolCalls,\n      this.tools,\n      approvals,\n      clientToolResults,\n    )\n\n    if (\n      executionResult.needsApproval.length > 0 ||\n      executionResult.needsClientExecution.length > 0\n    ) {\n      for (const chunk of this.emitApprovalRequests(\n        executionResult.needsApproval,\n        finishEvent,\n      )) {\n        yield chunk\n      }\n\n      for (const chunk of this.emitClientToolInputs(\n        executionResult.needsClientExecution,\n        finishEvent,\n      )) {\n        yield chunk\n      }\n\n      this.setToolPhase('wait')\n      return\n    }\n\n    const toolResultChunks = this.emitToolResults(\n      executionResult.results,\n      finishEvent,\n    )\n\n    for (const chunk of toolResultChunks) {\n      yield chunk\n    }\n\n    this.toolCallManager.clear()\n\n    this.setToolPhase('continue')\n  }\n\n  private shouldExecuteToolPhase(): boolean {\n    return (\n      this.finishedEvent?.finishReason === 'tool_calls' &&\n      this.tools.length > 0 &&\n      this.toolCallManager.hasToolCalls()\n    )\n  }\n\n  private addAssistantToolCallMessage(toolCalls: Array<ToolCall>): void {\n    const messageId = this.currentMessageId ?? this.createId('msg')\n    this.messages = [\n      ...this.messages,\n      {\n        role: 'assistant',\n        content: this.accumulatedContent || null,\n        toolCalls,\n      },\n    ]\n\n    aiEventClient.emit('text:message:created', {\n      ...this.buildTextEventContext(),\n      messageId,\n      role: 'assistant',\n      content: this.accumulatedContent || '',\n      toolCalls,\n      timestamp: Date.now(),\n    })\n  }\n\n  /**\n   * Extract client state (approvals and client tool results) from original messages.\n   * This is called in the constructor BEFORE converting to ModelMessage format,\n   * because the parts array (which contains approval state) is lost during conversion.\n   */\n  private extractClientStateFromOriginalMessages(\n    originalMessages: Array<any>,\n  ): {\n    approvals: Map<string, boolean>\n    clientToolResults: Map<string, any>\n  } {\n    const approvals = new Map<string, boolean>()\n    const clientToolResults = new Map<string, any>()\n\n    for (const message of originalMessages) {\n      // Check for UIMessage format (parts array) - extract client tool results and approvals\n      if (message.role === 'assistant' && message.parts) {\n        for (const part of message.parts) {\n          if (part.type === 'tool-call') {\n            // Extract client tool results (tools without approval that have output)\n            if (part.output !== undefined && !part.approval) {\n              clientToolResults.set(part.id, part.output)\n            }\n            // Extract approval responses from UIMessage format parts\n            if (\n              part.approval?.id &&\n              part.approval?.approved !== undefined &&\n              part.state === 'approval-responded'\n            ) {\n              approvals.set(part.approval.id, part.approval.approved)\n            }\n          }\n        }\n      }\n    }\n\n    return { approvals, clientToolResults }\n  }\n\n  private collectClientState(): {\n    approvals: Map<string, boolean>\n    clientToolResults: Map<string, any>\n  } {\n    // Start with the initial client state extracted from original messages\n    const approvals = new Map(this.initialApprovals)\n    const clientToolResults = new Map(this.initialClientToolResults)\n\n    // Also check current messages for any additional tool results (from server tools)\n    for (const message of this.messages) {\n      // Check for ModelMessage format (role: 'tool' messages contain tool results)\n      // This handles results sent back from the client after executing client-side tools\n      if (message.role === 'tool' && message.toolCallId) {\n        // Parse content back to original output (was stringified by uiMessageToModelMessages)\n        let output: unknown\n        try {\n          output = JSON.parse(message.content as string)\n        } catch {\n          output = message.content\n        }\n        // Skip approval response messages (they have pendingExecution marker)\n        // These are NOT real client tool results â€” they are synthetic tool messages\n        // created by uiMessageToModelMessages for approved-but-not-yet-executed tools.\n        // Treating them as results would prevent the server from requesting actual\n        // client-side execution after approval (see GitHub issue #225).\n        if (\n          output &&\n          typeof output === 'object' &&\n          (output as any).pendingExecution === true\n        ) {\n          continue\n        }\n        clientToolResults.set(message.toolCallId, output)\n      }\n    }\n\n    return { approvals, clientToolResults }\n  }\n\n  private emitApprovalRequests(\n    approvals: Array<ApprovalRequest>,\n    finishEvent: RunFinishedEvent,\n  ): Array<StreamChunk> {\n    const chunks: Array<StreamChunk> = []\n\n    for (const approval of approvals) {\n      aiEventClient.emit('tools:approval:requested', {\n        ...this.buildTextEventContext(),\n        messageId: this.currentMessageId || undefined,\n        toolCallId: approval.toolCallId,\n        toolName: approval.toolName,\n        input: approval.input,\n        approvalId: approval.approvalId,\n        timestamp: Date.now(),\n      })\n\n      // Emit a CUSTOM event for approval requests\n      chunks.push({\n        type: 'CUSTOM',\n        timestamp: Date.now(),\n        model: finishEvent.model,\n        name: 'approval-requested',\n        data: {\n          toolCallId: approval.toolCallId,\n          toolName: approval.toolName,\n          input: approval.input,\n          approval: {\n            id: approval.approvalId,\n            needsApproval: true,\n          },\n        },\n      })\n    }\n\n    return chunks\n  }\n\n  private emitClientToolInputs(\n    clientRequests: Array<ClientToolRequest>,\n    finishEvent: RunFinishedEvent,\n  ): Array<StreamChunk> {\n    const chunks: Array<StreamChunk> = []\n\n    for (const clientTool of clientRequests) {\n      aiEventClient.emit('tools:input:available', {\n        ...this.buildTextEventContext(),\n        messageId: this.currentMessageId || undefined,\n        toolCallId: clientTool.toolCallId,\n        toolName: clientTool.toolName,\n        input: clientTool.input,\n        timestamp: Date.now(),\n      })\n\n      // Emit a CUSTOM event for client tool inputs\n      chunks.push({\n        type: 'CUSTOM',\n        timestamp: Date.now(),\n        model: finishEvent.model,\n        name: 'tool-input-available',\n        data: {\n          toolCallId: clientTool.toolCallId,\n          toolName: clientTool.toolName,\n          input: clientTool.input,\n        },\n      })\n    }\n\n    return chunks\n  }\n\n  private emitToolResults(\n    results: Array<ToolResult>,\n    finishEvent: RunFinishedEvent,\n  ): Array<StreamChunk> {\n    const chunks: Array<StreamChunk> = []\n\n    for (const result of results) {\n      aiEventClient.emit('tools:call:completed', {\n        ...this.buildTextEventContext(),\n        messageId: this.currentMessageId || undefined,\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result,\n        duration: result.duration ?? 0,\n        timestamp: Date.now(),\n      })\n\n      const content = JSON.stringify(result.result)\n\n      // Emit TOOL_CALL_END event\n      chunks.push({\n        type: 'TOOL_CALL_END',\n        timestamp: Date.now(),\n        model: finishEvent.model,\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: content,\n      })\n\n      this.messages = [\n        ...this.messages,\n        {\n          role: 'tool',\n          content,\n          toolCallId: result.toolCallId,\n        },\n      ]\n\n      aiEventClient.emit('text:message:created', {\n        ...this.buildTextEventContext(),\n        messageId: this.createId('msg'),\n        role: 'tool',\n        content,\n        timestamp: Date.now(),\n      })\n    }\n\n    return chunks\n  }\n\n  private getPendingToolCallsFromMessages(): Array<ToolCall> {\n    // Build a set of completed tool IDs, but exclude tools with pendingExecution marker\n    // (these are approved tools that still need to execute)\n    const completedToolIds = new Set<string>()\n\n    for (const message of this.messages) {\n      if (message.role === 'tool' && message.toolCallId) {\n        // Check if this is an approval response with pendingExecution marker\n        let hasPendingExecution = false\n        if (typeof message.content === 'string') {\n          try {\n            const parsed = JSON.parse(message.content)\n            if (parsed.pendingExecution === true) {\n              hasPendingExecution = true\n            }\n          } catch {\n            // Not JSON, treat as regular tool result\n          }\n        }\n\n        // Only mark as complete if NOT pending execution\n        if (!hasPendingExecution) {\n          completedToolIds.add(message.toolCallId)\n        }\n      }\n    }\n\n    const pending: Array<ToolCall> = []\n\n    for (const message of this.messages) {\n      if (message.role === 'assistant' && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          if (!completedToolIds.has(toolCall.id)) {\n            pending.push(toolCall)\n          }\n        }\n      }\n    }\n\n    return pending\n  }\n\n  private createSyntheticFinishedEvent(): RunFinishedEvent {\n    return {\n      type: 'RUN_FINISHED',\n      runId: this.createId('pending'),\n      model: this.params.model,\n      timestamp: Date.now(),\n      finishReason: 'tool_calls',\n    }\n  }\n\n  private shouldContinue(): boolean {\n    if (this.cyclePhase === 'executeToolCalls') {\n      return true\n    }\n\n    return (\n      this.loopStrategy({\n        iterationCount: this.iterationCount,\n        messages: this.messages,\n        finishReason: this.lastFinishReason,\n      }) && this.toolPhase === 'continue'\n    )\n  }\n\n  private isAborted(): boolean {\n    return !!this.effectiveSignal?.aborted\n  }\n\n  private buildTextEventContext(): {\n    requestId: string\n    streamId: string\n    provider: string\n    model: string\n    clientId?: string\n    source?: 'client' | 'server'\n    systemPrompts?: Array<string>\n    toolNames?: Array<string>\n    options?: Record<string, unknown>\n    modelOptions?: Record<string, unknown>\n    messageCount: number\n    hasTools: boolean\n    streaming: boolean\n  } {\n    return {\n      requestId: this.requestId,\n      streamId: this.streamId,\n      provider: this.adapter.name,\n      model: this.params.model,\n      clientId: this.params.conversationId,\n      source: 'server',\n      systemPrompts:\n        this.systemPrompts.length > 0 ? this.systemPrompts : undefined,\n      toolNames: this.eventToolNames,\n      options: this.eventOptions,\n      modelOptions: this.params.modelOptions as\n        | Record<string, unknown>\n        | undefined,\n      messageCount: this.initialMessageCount,\n      hasTools: this.tools.length > 0,\n      streaming: true,\n    }\n  }\n\n  private getContentString(content: ModelMessage['content']): string {\n    if (typeof content === 'string') return content\n    const text =\n      content\n        ?.map((part) => (part.type === 'text' ? part.content : ''))\n        .join('') || ''\n    return text\n  }\n\n  private setToolPhase(phase: ToolPhaseResult): void {\n    this.toolPhase = phase\n    if (phase === 'wait') {\n      this.shouldEmitStreamEnd = false\n    }\n  }\n\n  private createId(prefix: string): string {\n    return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  }\n}\n\n// ===========================\n// Activity Implementation\n// ===========================\n\n/**\n * Text activity - handles agentic text generation, one-shot text generation, and agentic structured output.\n *\n * This activity supports four modes:\n * 1. **Streaming agentic text**: Stream responses with automatic tool execution\n * 2. **Streaming one-shot text**: Simple streaming request/response without tools\n * 3. **Non-streaming text**: Returns collected text as a string (stream: false)\n * 4. **Agentic structured output**: Run tools, then return structured data\n *\n * @example Full agentic text (streaming with tools)\n * ```ts\n * import { chat } from '@tanstack/ai'\n * import { openaiText } from '@tanstack/ai-openai'\n *\n * for await (const chunk of chat({\n *   adapter: openaiText('gpt-4o'),\n *   messages: [{ role: 'user', content: 'What is the weather?' }],\n *   tools: [weatherTool]\n * })) {\n *   if (chunk.type === 'content') {\n *     console.log(chunk.delta)\n *   }\n * }\n * ```\n *\n * @example One-shot text (streaming without tools)\n * ```ts\n * for await (const chunk of chat({\n *   adapter: openaiText('gpt-4o'),\n *   messages: [{ role: 'user', content: 'Hello!' }]\n * })) {\n *   console.log(chunk)\n * }\n * ```\n *\n * @example Non-streaming text (stream: false)\n * ```ts\n * const text = await chat({\n *   adapter: openaiText('gpt-4o'),\n *   messages: [{ role: 'user', content: 'Hello!' }],\n *   stream: false\n * })\n * // text is a string with the full response\n * ```\n *\n * @example Agentic structured output (tools + structured response)\n * ```ts\n * import { z } from 'zod'\n *\n * const result = await chat({\n *   adapter: openaiText('gpt-4o'),\n *   messages: [{ role: 'user', content: 'Research and summarize the topic' }],\n *   tools: [researchTool, analyzeTool],\n *   outputSchema: z.object({\n *     summary: z.string(),\n *     keyPoints: z.array(z.string())\n *   })\n * })\n * // result is { summary: string, keyPoints: string[] }\n * ```\n */\nexport function chat<\n  TAdapter extends AnyTextAdapter,\n  TSchema extends SchemaInput | undefined = undefined,\n  TStream extends boolean = true,\n>(\n  options: TextActivityOptions<TAdapter, TSchema, TStream>,\n): TextActivityResult<TSchema, TStream> {\n  const { outputSchema, stream } = options\n\n  // If outputSchema is provided, run agentic structured output\n  if (outputSchema) {\n    return runAgenticStructuredOutput(\n      options as unknown as TextActivityOptions<\n        AnyTextAdapter,\n        SchemaInput,\n        boolean\n      >,\n    ) as TextActivityResult<TSchema, TStream>\n  }\n\n  // If stream is explicitly false, run non-streaming text\n  if (stream === false) {\n    return runNonStreamingText(\n      options as unknown as TextActivityOptions<\n        AnyTextAdapter,\n        undefined,\n        false\n      >,\n    ) as TextActivityResult<TSchema, TStream>\n  }\n\n  // Otherwise, run streaming text (default)\n  return runStreamingText(\n    options as unknown as TextActivityOptions<AnyTextAdapter, undefined, true>,\n  ) as TextActivityResult<TSchema, TStream>\n}\n\n/**\n * Run streaming text (agentic or one-shot depending on tools)\n */\nasync function* runStreamingText(\n  options: TextActivityOptions<AnyTextAdapter, undefined, true>,\n): AsyncIterable<StreamChunk> {\n  const { adapter, ...textOptions } = options\n  const model = adapter.model\n\n  const engine = new TextEngine({\n    adapter,\n    params: { ...textOptions, model } as TextOptions<\n      Record<string, any>,\n      Record<string, any>\n    >,\n  })\n\n  for await (const chunk of engine.run()) {\n    yield chunk\n  }\n}\n\n/**\n * Run non-streaming text - collects all content and returns as a string.\n * Runs the full agentic loop (if tools are provided) but returns collected text.\n */\nfunction runNonStreamingText(\n  options: TextActivityOptions<AnyTextAdapter, undefined, false>,\n): Promise<string> {\n  // Run the streaming text and collect all text using streamToText\n  const stream = runStreamingText(\n    options as unknown as TextActivityOptions<AnyTextAdapter, undefined, true>,\n  )\n\n  return streamToText(stream)\n}\n\n/**\n * Run agentic structured output:\n * 1. Execute the full agentic loop (with tools)\n * 2. Once complete, call adapter.structuredOutput with the conversation context\n * 3. Validate and return the structured result\n */\nasync function runAgenticStructuredOutput<TSchema extends SchemaInput>(\n  options: TextActivityOptions<AnyTextAdapter, TSchema, boolean>,\n): Promise<InferSchemaType<TSchema>> {\n  const { adapter, outputSchema, ...textOptions } = options\n  const model = adapter.model\n\n  if (!outputSchema) {\n    throw new Error('outputSchema is required for structured output')\n  }\n\n  // Create the engine and run the agentic loop\n  const engine = new TextEngine({\n    adapter,\n    params: { ...textOptions, model } as TextOptions<\n      Record<string, unknown>,\n      Record<string, unknown>\n    >,\n  })\n\n  // Consume the stream to run the agentic loop\n  for await (const _chunk of engine.run()) {\n    // Just consume the stream to execute the agentic loop\n  }\n\n  // Get the final messages from the engine (includes tool results)\n  const finalMessages = engine.getMessages()\n\n  // Build text options for structured output, excluding tools since\n  // the agentic loop is complete and we only need the final response\n  const {\n    tools: _tools,\n    agentLoopStrategy: _als,\n    ...structuredTextOptions\n  } = textOptions\n\n  // Convert the schema to JSON Schema before passing to the adapter\n  const jsonSchema = convertSchemaToJsonSchema(outputSchema)\n  if (!jsonSchema) {\n    throw new Error('Failed to convert output schema to JSON Schema')\n  }\n\n  // Call the adapter's structured output method with the conversation context\n  // The adapter receives JSON Schema and can apply vendor-specific patches\n  const result = await adapter.structuredOutput({\n    chatOptions: {\n      ...structuredTextOptions,\n      model,\n      messages: finalMessages,\n    },\n    outputSchema: jsonSchema,\n  })\n\n  // Validate the result against the schema if it's a Standard Schema\n  if (isStandardSchema(outputSchema)) {\n    return parseWithStandardSchema<InferSchemaType<TSchema>>(\n      outputSchema,\n      result.data,\n    )\n  }\n\n  // For plain JSON Schema, return the data as-is\n  return result.data as InferSchemaType<TSchema>\n}\n\n// Re-export adapter types\nexport type {\n  TextAdapter,\n  TextAdapterConfig,\n  StructuredOutputOptions,\n  StructuredOutputResult,\n} from './adapter'\nexport { BaseTextAdapter } from './adapter'\n"],"names":["maxIterationsStrategy"],"mappings":";;;;;;AA6CO,MAAM,OAAO;AA2Gb,SAAS,kBAKd,SACiD;AACjD,SAAO;AACT;AAqCA,MAAM,WAGJ;AAAA,EA+BA,YAAY,QAA6C;AAjBzD,SAAQ,iBAAiB;AACzB,SAAQ,mBAAkC;AAC1C,SAAQ,kBAAkB;AAC1B,SAAQ,kBAAkB;AAC1B,SAAQ,mBAAkC;AAC1C,SAAQ,qBAAqB;AAG7B,SAAQ,gBAAyC;AACjD,SAAQ,sBAAsB;AAC9B,SAAQ,mBAAmB;AAC3B,SAAQ,YAA6B;AACrC,SAAQ,aAAyB;AAM/B,SAAK,UAAU,OAAO;AACtB,SAAK,SAAS,OAAO;AACrB,SAAK,gBAAgB,OAAO,OAAO,iBAAiB,CAAA;AACpD,SAAK,QAAQ,OAAO,OAAO,SAAS,CAAA;AACpC,SAAK,eACH,OAAO,OAAO,qBAAqBA,cAAsB,CAAC;AAC5D,SAAK,kBAAkB,IAAI,gBAAgB,KAAK,KAAK;AACrD,SAAK,sBAAsB,OAAO,OAAO,SAAS;AAIlD,UAAM,EAAE,WAAW,kBAAA,IACjB,KAAK;AAAA,MACH,OAAO,OAAO;AAAA,IAAA;AAElB,SAAK,mBAAmB;AACxB,SAAK,2BAA2B;AAIhC,SAAK,WAAW;AAAA,MACd,OAAO,OAAO;AAAA,IAAA;AAEhB,SAAK,YAAY,KAAK,SAAS,MAAM;AACrC,SAAK,WAAW,KAAK,SAAS,QAAQ;AACtC,SAAK,mBAAmB,OAAO,OAAO,kBAClC,EAAE,QAAQ,OAAO,OAAO,gBAAgB,OAAA,IACxC;AACJ,SAAK,kBAAkB,OAAO,OAAO,iBAAiB;AAAA,EACxD;AAAA;AAAA,EAGA,wBAAgC;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGA,cAAmC;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,OAAO,MAAmC;AACxC,SAAK,UAAA;AAEL,QAAI;AACF,YAAM,eAAe,OAAO,KAAK,yBAAA;AACjC,UAAI,iBAAiB,QAAQ;AAC3B;AAAA,MACF;AAEA,SAAG;AACD,YAAI,KAAK,oBAAoB,KAAK,UAAA,GAAa;AAC7C;AAAA,QACF;AAEA,aAAK,WAAA;AAEL,YAAI,KAAK,eAAe,eAAe;AACrC,iBAAO,KAAK,oBAAA;AAAA,QACd,OAAO;AACL,iBAAO,KAAK,iBAAA;AAAA,QACd;AAEA,aAAK,SAAA;AAAA,MACP,SAAS,KAAK,eAAA;AAAA,IAChB,UAAA;AACE,WAAK,SAAA;AAAA,IACP;AAAA,EACF;AAAA,EAEQ,YAAkB;AACxB,SAAK,kBAAkB,KAAK,IAAA;AAC5B,UAAM,EAAE,OAAO,aAAa,MAAM,WAAW,SAAA,IAAa,KAAK;AAG/D,UAAM,UAAmC,CAAA;AACzC,QAAI,gBAAgB,OAAW,SAAQ,cAAc;AACrD,QAAI,SAAS,OAAW,SAAQ,OAAO;AACvC,QAAI,cAAc,OAAW,SAAQ,YAAY;AACjD,QAAI,aAAa,OAAW,SAAQ,WAAW;AAE/C,SAAK,eAAe,OAAO,KAAK,OAAO,EAAE,SAAS,IAAI,UAAU;AAChE,SAAK,iBAAiB,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI;AAE9C,kBAAc,KAAK,wBAAwB;AAAA,MACzC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAKD,UAAM,iBAAiB,KAAK,OAAO,iBAC/B,KAAK,SAAS,MAAM,EAAE,EAAE,OAAO,CAAC,MAAM,EAAE,SAAS,MAAM,IACvD,KAAK;AAET,mBAAe,QAAQ,CAAC,SAAS,UAAU;AACzC,YAAM,eAAe,KAAK,OAAO,iBAC7B,KAAK,SAAS,SAAS,IACvB;AACJ,YAAM,YAAY,KAAK,SAAS,KAAK;AACrC,YAAM,cAAc,KAAK,sBAAA;AACzB,YAAM,UAAU,KAAK,iBAAiB,QAAQ,OAAO;AAErD,oBAAc,KAAK,wBAAwB;AAAA,QACzC,GAAG;AAAA,QACH;AAAA,QACA,MAAM,QAAQ;AAAA,QACd;AAAA,QACA,WAAW,QAAQ;AAAA,QACnB;AAAA,QACA,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAED,UAAI,QAAQ,SAAS,QAAQ;AAC3B,sBAAc,KAAK,qBAAqB;AAAA,UACtC,GAAG;AAAA,UACH;AAAA,UACA,MAAM;AAAA,UACN;AAAA,UACA;AAAA,UACA,WAAW,KAAK,IAAA;AAAA,QAAI,CACrB;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,WAAiB;AACvB,QAAI,CAAC,KAAK,qBAAqB;AAC7B;AAAA,IACF;AAEA,UAAM,MAAM,KAAK,IAAA;AAEjB,kBAAc,KAAK,0BAA0B;AAAA,MAC3C,GAAG,KAAK,sBAAA;AAAA,MACR,SAAS,KAAK;AAAA,MACd,WAAW,KAAK,oBAAoB;AAAA,MACpC,cAAc,KAAK,oBAAoB;AAAA,MACvC,OAAO,KAAK,eAAe;AAAA,MAC3B,UAAU,MAAM,KAAK;AAAA,MACrB,WAAW;AAAA,IAAA,CACZ;AAAA,EACH;AAAA,EAEQ,aAAmB;AACzB,QAAI,KAAK,eAAe,eAAe;AACrC,WAAK,eAAA;AAAA,IACP;AAAA,EACF;AAAA,EAEQ,WAAiB;AACvB,QAAI,KAAK,eAAe,eAAe;AACrC,WAAK,aAAa;AAClB;AAAA,IACF;AAEA,SAAK,aAAa;AAClB,SAAK;AAAA,EACP;AAAA,EAEQ,iBAAuB;AAC7B,SAAK,mBAAmB,KAAK,SAAS,KAAK;AAC3C,SAAK,qBAAqB;AAC1B,SAAK,gBAAgB;AAErB,UAAM,cAAc,KAAK,sBAAA;AACzB,kBAAc,KAAK,wBAAwB;AAAA,MACzC,GAAG;AAAA,MACH,WAAW,KAAK;AAAA,MAChB,MAAM;AAAA,MACN,SAAS;AAAA,MACT,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA,EAEA,OAAe,sBAAmD;AAChE,UAAM,EAAE,aAAa,MAAM,WAAW,UAAU,aAAA,IAAiB,KAAK;AACtE,UAAM,QAAQ,KAAK,OAAO;AAG1B,UAAM,uBAAuB,OAAO,IAAI,CAAC,UAAU;AAAA,MACjD,GAAG;AAAA,MACH,aAAa,KAAK,cACd,0BAA0B,KAAK,WAAW,IAC1C;AAAA,MACJ,cAAc,KAAK,eACf,0BAA0B,KAAK,YAAY,IAC3C;AAAA,IAAA,EACJ;AAEF,qBAAiB,SAAS,KAAK,QAAQ,WAAW;AAAA,MAChD,OAAO,KAAK,OAAO;AAAA,MACnB,UAAU,KAAK;AAAA,MACf,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,KAAK;AAAA,MACd;AAAA,MACA,eAAe,KAAK;AAAA,IAAA,CACrB,GAAG;AACF,UAAI,KAAK,aAAa;AACpB;AAAA,MACF;AAEA,WAAK;AAEL,YAAM;AACN,WAAK,kBAAkB,KAAK;AAE5B,UAAI,KAAK,kBAAkB;AACzB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,kBAAkB,OAA0B;AAClD,YAAQ,MAAM,MAAA;AAAA;AAAA,MAEZ,KAAK;AACH,aAAK,8BAA8B,KAAK;AACxC;AAAA,MACF,KAAK;AACH,aAAK,yBAAyB,KAAK;AACnC;AAAA,MACF,KAAK;AACH,aAAK,wBAAwB,KAAK;AAClC;AAAA,MACF,KAAK;AACH,aAAK,uBAAuB,KAAK;AACjC;AAAA,MACF,KAAK;AACH,aAAK,uBAAuB,KAAK;AACjC;AAAA,MACF,KAAK;AACH,aAAK,oBAAoB,KAAK;AAC9B;AAAA,MACF,KAAK;AACH,aAAK,wBAAwB,KAAK;AAClC;AAAA,IAMA;AAAA,EAEN;AAAA;AAAA;AAAA;AAAA,EAMQ,8BAA8B,OAAsC;AAC1E,QAAI,MAAM,SAAS;AACjB,WAAK,qBAAqB,MAAM;AAAA,IAClC,OAAO;AACL,WAAK,sBAAsB,MAAM;AAAA,IACnC;AACA,kBAAc,KAAK,sBAAsB;AAAA,MACvC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,SAAS,KAAK;AAAA,MACd,OAAO,MAAM;AAAA,MACb,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA,EAEQ,yBAAyB,OAAiC;AAChE,SAAK,gBAAgB,sBAAsB,KAAK;AAChD,kBAAc,KAAK,wBAAwB;AAAA,MACzC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,YAAY,MAAM;AAAA,MAClB,UAAU,MAAM;AAAA,MAChB,OAAO,MAAM,SAAS;AAAA,MACtB,WAAW;AAAA,MACX,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA,EAEQ,wBAAwB,OAAgC;AAC9D,SAAK,gBAAgB,qBAAqB,KAAK;AAC/C,kBAAc,KAAK,wBAAwB;AAAA,MACzC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,YAAY,MAAM;AAAA,MAClB,UAAU;AAAA,MACV,OAAO;AAAA,MACP,WAAW,MAAM;AAAA,MACjB,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA,EAEQ,uBAAuB,OAA+B;AAC5D,SAAK,gBAAgB,iBAAiB,KAAK;AAC3C,kBAAc,KAAK,0BAA0B;AAAA,MAC3C,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,YAAY,MAAM;AAAA,MAClB,QAAQ,MAAM,UAAU;AAAA,MACxB,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA,EAEQ,uBAAuB,OAA+B;AAC5D,kBAAc,KAAK,mBAAmB;AAAA,MACpC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,cAAc,MAAM;AAAA,MACpB,OAAO,MAAM;AAAA,MACb,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAED,QAAI,MAAM,OAAO;AACf,oBAAc,KAAK,cAAc;AAAA,QAC/B,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,oBAAoB;AAAA,QACpC,OAAO,MAAM;AAAA,QACb,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAAA,IACH;AAEA,SAAK,gBAAgB;AACrB,SAAK,mBAAmB,MAAM;AAAA,EAChC;AAAA,EAEQ,oBACN,OACM;AACN,kBAAc,KAAK,oBAAoB;AAAA,MACrC,GAAG,KAAK,sBAAA;AAAA,MACR,WAAW,KAAK,oBAAoB;AAAA,MACpC,OAAO,MAAM,MAAM;AAAA,MACnB,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AACD,SAAK,mBAAmB;AACxB,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEQ,wBACN,OACM;AAEN,QAAI,MAAM,WAAW,MAAM,OAAO;AAChC,oBAAc,KAAK,uBAAuB;AAAA,QACxC,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,oBAAoB;AAAA,QACpC,SAAS,MAAM,WAAW;AAAA,QAC1B,OAAO,MAAM;AAAA,QACb,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAAA,IACH;AAAA,EACF;AAAA,EAEA,OAAe,2BAIb;AACA,UAAM,mBAAmB,KAAK,gCAAA;AAC9B,QAAI,iBAAiB,WAAW,GAAG;AACjC,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,KAAK,6BAAA;AAEzB,UAAM,EAAE,WAAW,sBAAsB,KAAK,mBAAA;AAE9C,UAAM,kBAAkB,MAAM;AAAA,MAC5B;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IAAA;AAGF,QACE,gBAAgB,cAAc,SAAS,KACvC,gBAAgB,qBAAqB,SAAS,GAC9C;AACA,iBAAW,SAAS,KAAK;AAAA,QACvB,gBAAgB;AAAA,QAChB;AAAA,MAAA,GACC;AACD,cAAM;AAAA,MACR;AAEA,iBAAW,SAAS,KAAK;AAAA,QACvB,gBAAgB;AAAA,QAChB;AAAA,MAAA,GACC;AACD,cAAM;AAAA,MACR;AAEA,WAAK,sBAAsB;AAC3B,aAAO;AAAA,IACT;AAEA,UAAM,mBAAmB,KAAK;AAAA,MAC5B,gBAAgB;AAAA,MAChB;AAAA,IAAA;AAGF,eAAW,SAAS,kBAAkB;AACpC,YAAM;AAAA,IACR;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAe,mBAA4D;AACzE,QAAI,CAAC,KAAK,0BAA0B;AAClC,WAAK,aAAa,MAAM;AACxB;AAAA,IACF;AAEA,UAAM,YAAY,KAAK,gBAAgB,aAAA;AACvC,UAAM,cAAc,KAAK;AAEzB,QAAI,CAAC,eAAe,UAAU,WAAW,GAAG;AAC1C,WAAK,aAAa,MAAM;AACxB;AAAA,IACF;AAEA,SAAK,4BAA4B,SAAS;AAE1C,UAAM,EAAE,WAAW,sBAAsB,KAAK,mBAAA;AAE9C,UAAM,kBAAkB,MAAM;AAAA,MAC5B;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IAAA;AAGF,QACE,gBAAgB,cAAc,SAAS,KACvC,gBAAgB,qBAAqB,SAAS,GAC9C;AACA,iBAAW,SAAS,KAAK;AAAA,QACvB,gBAAgB;AAAA,QAChB;AAAA,MAAA,GACC;AACD,cAAM;AAAA,MACR;AAEA,iBAAW,SAAS,KAAK;AAAA,QACvB,gBAAgB;AAAA,QAChB;AAAA,MAAA,GACC;AACD,cAAM;AAAA,MACR;AAEA,WAAK,aAAa,MAAM;AACxB;AAAA,IACF;AAEA,UAAM,mBAAmB,KAAK;AAAA,MAC5B,gBAAgB;AAAA,MAChB;AAAA,IAAA;AAGF,eAAW,SAAS,kBAAkB;AACpC,YAAM;AAAA,IACR;AAEA,SAAK,gBAAgB,MAAA;AAErB,SAAK,aAAa,UAAU;AAAA,EAC9B;AAAA,EAEQ,yBAAkC;AACxC,WACE,KAAK,eAAe,iBAAiB,gBACrC,KAAK,MAAM,SAAS,KACpB,KAAK,gBAAgB,aAAA;AAAA,EAEzB;AAAA,EAEQ,4BAA4B,WAAkC;AACpE,UAAM,YAAY,KAAK,oBAAoB,KAAK,SAAS,KAAK;AAC9D,SAAK,WAAW;AAAA,MACd,GAAG,KAAK;AAAA,MACR;AAAA,QACE,MAAM;AAAA,QACN,SAAS,KAAK,sBAAsB;AAAA,QACpC;AAAA,MAAA;AAAA,IACF;AAGF,kBAAc,KAAK,wBAAwB;AAAA,MACzC,GAAG,KAAK,sBAAA;AAAA,MACR;AAAA,MACA,MAAM;AAAA,MACN,SAAS,KAAK,sBAAsB;AAAA,MACpC;AAAA,MACA,WAAW,KAAK,IAAA;AAAA,IAAI,CACrB;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,uCACN,kBAIA;AACA,UAAM,gCAAgB,IAAA;AACtB,UAAM,wCAAwB,IAAA;AAE9B,eAAW,WAAW,kBAAkB;AAEtC,UAAI,QAAQ,SAAS,eAAe,QAAQ,OAAO;AACjD,mBAAW,QAAQ,QAAQ,OAAO;AAChC,cAAI,KAAK,SAAS,aAAa;AAE7B,gBAAI,KAAK,WAAW,UAAa,CAAC,KAAK,UAAU;AAC/C,gCAAkB,IAAI,KAAK,IAAI,KAAK,MAAM;AAAA,YAC5C;AAEA,gBACE,KAAK,UAAU,MACf,KAAK,UAAU,aAAa,UAC5B,KAAK,UAAU,sBACf;AACA,wBAAU,IAAI,KAAK,SAAS,IAAI,KAAK,SAAS,QAAQ;AAAA,YACxD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE,WAAW,kBAAA;AAAA,EACtB;AAAA,EAEQ,qBAGN;AAEA,UAAM,YAAY,IAAI,IAAI,KAAK,gBAAgB;AAC/C,UAAM,oBAAoB,IAAI,IAAI,KAAK,wBAAwB;AAG/D,eAAW,WAAW,KAAK,UAAU;AAGnC,UAAI,QAAQ,SAAS,UAAU,QAAQ,YAAY;AAEjD,YAAI;AACJ,YAAI;AACF,mBAAS,KAAK,MAAM,QAAQ,OAAiB;AAAA,QAC/C,QAAQ;AACN,mBAAS,QAAQ;AAAA,QACnB;AAMA,YACE,UACA,OAAO,WAAW,YACjB,OAAe,qBAAqB,MACrC;AACA;AAAA,QACF;AACA,0BAAkB,IAAI,QAAQ,YAAY,MAAM;AAAA,MAClD;AAAA,IACF;AAEA,WAAO,EAAE,WAAW,kBAAA;AAAA,EACtB;AAAA,EAEQ,qBACN,WACA,aACoB;AACpB,UAAM,SAA6B,CAAA;AAEnC,eAAW,YAAY,WAAW;AAChC,oBAAc,KAAK,4BAA4B;AAAA,QAC7C,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,oBAAoB;AAAA,QACpC,YAAY,SAAS;AAAA,QACrB,UAAU,SAAS;AAAA,QACnB,OAAO,SAAS;AAAA,QAChB,YAAY,SAAS;AAAA,QACrB,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAGD,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,WAAW,KAAK,IAAA;AAAA,QAChB,OAAO,YAAY;AAAA,QACnB,MAAM;AAAA,QACN,MAAM;AAAA,UACJ,YAAY,SAAS;AAAA,UACrB,UAAU,SAAS;AAAA,UACnB,OAAO,SAAS;AAAA,UAChB,UAAU;AAAA,YACR,IAAI,SAAS;AAAA,YACb,eAAe;AAAA,UAAA;AAAA,QACjB;AAAA,MACF,CACD;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,qBACN,gBACA,aACoB;AACpB,UAAM,SAA6B,CAAA;AAEnC,eAAW,cAAc,gBAAgB;AACvC,oBAAc,KAAK,yBAAyB;AAAA,QAC1C,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,oBAAoB;AAAA,QACpC,YAAY,WAAW;AAAA,QACvB,UAAU,WAAW;AAAA,QACrB,OAAO,WAAW;AAAA,QAClB,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAGD,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,WAAW,KAAK,IAAA;AAAA,QAChB,OAAO,YAAY;AAAA,QACnB,MAAM;AAAA,QACN,MAAM;AAAA,UACJ,YAAY,WAAW;AAAA,UACvB,UAAU,WAAW;AAAA,UACrB,OAAO,WAAW;AAAA,QAAA;AAAA,MACpB,CACD;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,gBACN,SACA,aACoB;AACpB,UAAM,SAA6B,CAAA;AAEnC,eAAW,UAAU,SAAS;AAC5B,oBAAc,KAAK,wBAAwB;AAAA,QACzC,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,oBAAoB;AAAA,QACpC,YAAY,OAAO;AAAA,QACnB,UAAU,OAAO;AAAA,QACjB,QAAQ,OAAO;AAAA,QACf,UAAU,OAAO,YAAY;AAAA,QAC7B,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAED,YAAM,UAAU,KAAK,UAAU,OAAO,MAAM;AAG5C,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,WAAW,KAAK,IAAA;AAAA,QAChB,OAAO,YAAY;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,UAAU,OAAO;AAAA,QACjB,QAAQ;AAAA,MAAA,CACT;AAED,WAAK,WAAW;AAAA,QACd,GAAG,KAAK;AAAA,QACR;AAAA,UACE,MAAM;AAAA,UACN;AAAA,UACA,YAAY,OAAO;AAAA,QAAA;AAAA,MACrB;AAGF,oBAAc,KAAK,wBAAwB;AAAA,QACzC,GAAG,KAAK,sBAAA;AAAA,QACR,WAAW,KAAK,SAAS,KAAK;AAAA,QAC9B,MAAM;AAAA,QACN;AAAA,QACA,WAAW,KAAK,IAAA;AAAA,MAAI,CACrB;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,kCAAmD;AAGzD,UAAM,uCAAuB,IAAA;AAE7B,eAAW,WAAW,KAAK,UAAU;AACnC,UAAI,QAAQ,SAAS,UAAU,QAAQ,YAAY;AAEjD,YAAI,sBAAsB;AAC1B,YAAI,OAAO,QAAQ,YAAY,UAAU;AACvC,cAAI;AACF,kBAAM,SAAS,KAAK,MAAM,QAAQ,OAAO;AACzC,gBAAI,OAAO,qBAAqB,MAAM;AACpC,oCAAsB;AAAA,YACxB;AAAA,UACF,QAAQ;AAAA,UAER;AAAA,QACF;AAGA,YAAI,CAAC,qBAAqB;AACxB,2BAAiB,IAAI,QAAQ,UAAU;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAA2B,CAAA;AAEjC,eAAW,WAAW,KAAK,UAAU;AACnC,UAAI,QAAQ,SAAS,eAAe,QAAQ,WAAW;AACrD,mBAAW,YAAY,QAAQ,WAAW;AACxC,cAAI,CAAC,iBAAiB,IAAI,SAAS,EAAE,GAAG;AACtC,oBAAQ,KAAK,QAAQ;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,+BAAiD;AACvD,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO,KAAK,SAAS,SAAS;AAAA,MAC9B,OAAO,KAAK,OAAO;AAAA,MACnB,WAAW,KAAK,IAAA;AAAA,MAChB,cAAc;AAAA,IAAA;AAAA,EAElB;AAAA,EAEQ,iBAA0B;AAChC,QAAI,KAAK,eAAe,oBAAoB;AAC1C,aAAO;AAAA,IACT;AAEA,WACE,KAAK,aAAa;AAAA,MAChB,gBAAgB,KAAK;AAAA,MACrB,UAAU,KAAK;AAAA,MACf,cAAc,KAAK;AAAA,IAAA,CACpB,KAAK,KAAK,cAAc;AAAA,EAE7B;AAAA,EAEQ,YAAqB;AAC3B,WAAO,CAAC,CAAC,KAAK,iBAAiB;AAAA,EACjC;AAAA,EAEQ,wBAcN;AACA,WAAO;AAAA,MACL,WAAW,KAAK;AAAA,MAChB,UAAU,KAAK;AAAA,MACf,UAAU,KAAK,QAAQ;AAAA,MACvB,OAAO,KAAK,OAAO;AAAA,MACnB,UAAU,KAAK,OAAO;AAAA,MACtB,QAAQ;AAAA,MACR,eACE,KAAK,cAAc,SAAS,IAAI,KAAK,gBAAgB;AAAA,MACvD,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,cAAc,KAAK,OAAO;AAAA,MAG1B,cAAc,KAAK;AAAA,MACnB,UAAU,KAAK,MAAM,SAAS;AAAA,MAC9B,WAAW;AAAA,IAAA;AAAA,EAEf;AAAA,EAEQ,iBAAiB,SAA0C;AACjE,QAAI,OAAO,YAAY,SAAU,QAAO;AACxC,UAAM,OACJ,SACI,IAAI,CAAC,SAAU,KAAK,SAAS,SAAS,KAAK,UAAU,EAAG,EACzD,KAAK,EAAE,KAAK;AACjB,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,OAA8B;AACjD,SAAK,YAAY;AACjB,QAAI,UAAU,QAAQ;AACpB,WAAK,sBAAsB;AAAA,IAC7B;AAAA,EACF;AAAA,EAEQ,SAAS,QAAwB;AACvC,WAAO,GAAG,MAAM,IAAI,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAAA,EAC1E;AACF;AAmEO,SAAS,KAKd,SACsC;AACtC,QAAM,EAAE,cAAc,OAAA,IAAW;AAGjC,MAAI,cAAc;AAChB,WAAO;AAAA,MACL;AAAA,IAAA;AAAA,EAMJ;AAGA,MAAI,WAAW,OAAO;AACpB,WAAO;AAAA,MACL;AAAA,IAAA;AAAA,EAMJ;AAGA,SAAO;AAAA,IACL;AAAA,EAAA;AAEJ;AAKA,gBAAgB,iBACd,SAC4B;AAC5B,QAAM,EAAE,SAAS,GAAG,YAAA,IAAgB;AACpC,QAAM,QAAQ,QAAQ;AAEtB,QAAM,SAAS,IAAI,WAAW;AAAA,IAC5B;AAAA,IACA,QAAQ,EAAE,GAAG,aAAa,MAAA;AAAA,EAAM,CAIjC;AAED,mBAAiB,SAAS,OAAO,OAAO;AACtC,UAAM;AAAA,EACR;AACF;AAMA,SAAS,oBACP,SACiB;AAEjB,QAAM,SAAS;AAAA,IACb;AAAA,EAAA;AAGF,SAAO,aAAa,MAAM;AAC5B;AAQA,eAAe,2BACb,SACmC;AACnC,QAAM,EAAE,SAAS,cAAc,GAAG,gBAAgB;AAClD,QAAM,QAAQ,QAAQ;AAEtB,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AAGA,QAAM,SAAS,IAAI,WAAW;AAAA,IAC5B;AAAA,IACA,QAAQ,EAAE,GAAG,aAAa,MAAA;AAAA,EAAM,CAIjC;AAGD,mBAAiB,UAAU,OAAO,OAAO;AAAA,EAEzC;AAGA,QAAM,gBAAgB,OAAO,YAAA;AAI7B,QAAM;AAAA,IACJ,OAAO;AAAA,IACP,mBAAmB;AAAA,IACnB,GAAG;AAAA,EAAA,IACD;AAGJ,QAAM,aAAa,0BAA0B,YAAY;AACzD,MAAI,CAAC,YAAY;AACf,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AAIA,QAAM,SAAS,MAAM,QAAQ,iBAAiB;AAAA,IAC5C,aAAa;AAAA,MACX,GAAG;AAAA,MACH;AAAA,MACA,UAAU;AAAA,IAAA;AAAA,IAEZ,cAAc;AAAA,EAAA,CACf;AAGD,MAAI,iBAAiB,YAAY,GAAG;AAClC,WAAO;AAAA,MACL;AAAA,MACA,OAAO;AAAA,IAAA;AAAA,EAEX;AAGA,SAAO,OAAO;AAChB;"}