import { BaseVideoAdapter } from "@tanstack/ai/adapters";
import { createOpenAIClient, getOpenAIApiKeyFromEnv } from "../utils/client.js";
import { validateVideoSize, validateVideoSeconds, toApiSeconds } from "../video/video-provider-options.js";
class OpenAIVideoAdapter extends BaseVideoAdapter {
  constructor(config, model) {
    super(config, model);
    this.name = "openai";
    this.client = createOpenAIClient(config);
  }
  /**
   * Create a new video generation job.
   *
   * API: POST /v1/videos
   * Docs: https://platform.openai.com/docs/api-reference/videos/create
   *
   * @experimental Video generation is an experimental feature and may change.
   *
   * @example
   * ```ts
   * const { jobId } = await adapter.createVideoJob({
   *   model: 'sora-2',
   *   prompt: 'A cat chasing a dog in a sunny park',
   *   size: '1280x720',
   *   duration: 8  // seconds: 4, 8, or 12
   * })
   * ```
   */
  async createVideoJob(options) {
    const { model, size, duration, modelOptions } = options;
    validateVideoSize(model, size);
    const seconds = duration ?? modelOptions?.seconds;
    validateVideoSeconds(model, seconds);
    const request = this.buildRequest(options);
    try {
      const client = this.client;
      const response = await client.videos.create(request);
      return {
        jobId: response.id,
        model
      };
    } catch (error) {
      if (error?.message?.includes("videos") || error?.code === "invalid_api") {
        throw new Error(
          `Video generation API is not available. The Sora API may require special access. Original error: ${error.message}`
        );
      }
      throw error;
    }
  }
  /**
   * Get the current status of a video generation job.
   *
   * API: GET /v1/videos/{video_id}
   * Docs: https://platform.openai.com/docs/api-reference/videos/get
   *
   * @experimental Video generation is an experimental feature and may change.
   *
   * @example
   * ```ts
   * const status = await adapter.getVideoStatus(jobId)
   * if (status.status === 'completed') {
   *   console.log('Video is ready!')
   * } else if (status.status === 'processing') {
   *   console.log(`Progress: ${status.progress}%`)
   * }
   * ```
   */
  async getVideoStatus(jobId) {
    try {
      const client = this.client;
      const response = await client.videos.retrieve(jobId);
      return {
        jobId,
        status: this.mapStatus(response.status),
        progress: response.progress,
        error: response.error?.message
      };
    } catch (error) {
      if (error.status === 404) {
        return {
          jobId,
          status: "failed",
          error: "Job not found"
        };
      }
      throw error;
    }
  }
  /**
   * Get the URL to download/view the generated video.
   *
   * API: GET /v1/videos/{video_id}/content
   * Docs: https://platform.openai.com/docs/api-reference/videos/content
   *
   * @experimental Video generation is an experimental feature and may change.
   *
   * @example
   * ```ts
   * const { url, expiresAt } = await adapter.getVideoUrl(jobId)
   * console.log('Video URL:', url)
   * console.log('Expires at:', expiresAt)
   * ```
   */
  async getVideoUrl(jobId) {
    try {
      const client = this.client;
      let response;
      if (typeof client.videos?.content === "function") {
        response = await client.videos.content(jobId);
      } else if (typeof client.videos?.getContent === "function") {
        response = await client.videos.getContent(jobId);
      } else if (typeof client.videos?.download === "function") {
        response = await client.videos.download(jobId);
      } else {
        const videoInfo = await client.videos.retrieve(jobId);
        if (videoInfo.url) {
          return {
            jobId,
            url: videoInfo.url,
            expiresAt: videoInfo.expires_at ? new Date(videoInfo.expires_at) : void 0
          };
        }
        const baseUrl = this.config.baseUrl || "https://api.openai.com/v1";
        const apiKey = this.config.apiKey;
        const contentResponse = await fetch(
          `${baseUrl}/videos/${jobId}/content`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${apiKey}`
            }
          }
        );
        if (!contentResponse.ok) {
          const contentType = contentResponse.headers.get("content-type");
          if (contentType?.includes("application/json")) {
            const errorData = await contentResponse.json().catch(() => ({}));
            throw new Error(
              errorData.error?.message || `Failed to get video content: ${contentResponse.status}`
            );
          }
          throw new Error(
            `Failed to get video content: ${contentResponse.status}`
          );
        }
        const videoBlob = await contentResponse.blob();
        const buffer = await videoBlob.arrayBuffer();
        const base64 = Buffer.from(buffer).toString("base64");
        const mimeType = contentResponse.headers.get("content-type") || "video/mp4";
        return {
          jobId,
          url: `data:${mimeType};base64,${base64}`,
          expiresAt: void 0
          // Data URLs don't expire
        };
      }
      return {
        jobId,
        url: response.url,
        expiresAt: response.expires_at ? new Date(response.expires_at) : void 0
      };
    } catch (error) {
      if (error.status === 404) {
        throw new Error(`Video job not found: ${jobId}`);
      }
      if (error.status === 400) {
        throw new Error(
          `Video is not ready for download. Check status first. Job ID: ${jobId}`
        );
      }
      throw error;
    }
  }
  buildRequest(options) {
    const { model, prompt, size, duration, modelOptions } = options;
    const request = {
      model,
      prompt
    };
    if (size) {
      request.size = size;
    } else if (modelOptions?.size) {
      request.size = modelOptions.size;
    }
    const seconds = duration ?? modelOptions?.seconds;
    if (seconds !== void 0) {
      request.seconds = toApiSeconds(seconds);
    }
    return request;
  }
  mapStatus(apiStatus) {
    switch (apiStatus) {
      case "queued":
      case "pending":
        return "pending";
      case "processing":
      case "in_progress":
        return "processing";
      case "completed":
      case "succeeded":
        return "completed";
      case "failed":
      case "error":
      case "cancelled":
        return "failed";
      default:
        return "processing";
    }
  }
}
function createOpenaiVideo(model, apiKey, config) {
  return new OpenAIVideoAdapter({ apiKey, ...config }, model);
}
function openaiVideo(model, config) {
  const apiKey = getOpenAIApiKeyFromEnv();
  return createOpenaiVideo(model, apiKey, config);
}
export {
  OpenAIVideoAdapter,
  createOpenaiVideo,
  openaiVideo
};
//# sourceMappingURL=video.js.map
