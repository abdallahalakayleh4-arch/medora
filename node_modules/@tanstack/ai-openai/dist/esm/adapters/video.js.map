{"version":3,"file":"video.js","sources":["../../../src/adapters/video.ts"],"sourcesContent":["import { BaseVideoAdapter } from '@tanstack/ai/adapters'\nimport { createOpenAIClient, getOpenAIApiKeyFromEnv } from '../utils/client'\nimport {\n  toApiSeconds,\n  validateVideoSeconds,\n  validateVideoSize,\n} from '../video/video-provider-options'\nimport type { VideoModel } from 'openai/resources'\nimport type { OpenAIVideoModel } from '../model-meta'\nimport type {\n  OpenAIVideoModelProviderOptionsByName,\n  OpenAIVideoProviderOptions,\n} from '../video/video-provider-options'\nimport type {\n  VideoGenerationOptions,\n  VideoJobResult,\n  VideoStatusResult,\n  VideoUrlResult,\n} from '@tanstack/ai'\nimport type OpenAI_SDK from 'openai'\nimport type { OpenAIClientConfig } from '../utils/client'\n\n/**\n * Configuration for OpenAI video adapter.\n *\n * @experimental Video generation is an experimental feature and may change.\n */\nexport interface OpenAIVideoConfig extends OpenAIClientConfig {}\n\n/**\n * OpenAI Video Generation Adapter\n *\n * Tree-shakeable adapter for OpenAI video generation functionality using Sora-2.\n * Uses a jobs/polling architecture for async video generation.\n *\n * @experimental Video generation is an experimental feature and may change.\n *\n * Features:\n * - Async job-based video generation\n * - Status polling for job progress\n * - URL retrieval for completed videos\n * - Model-specific type-safe provider options\n */\nexport class OpenAIVideoAdapter<\n  TModel extends OpenAIVideoModel,\n> extends BaseVideoAdapter<TModel, OpenAIVideoProviderOptions> {\n  readonly name = 'openai' as const\n\n  // Type-only property - never assigned at runtime\n  declare '~types': {\n    providerOptions: OpenAIVideoProviderOptions\n    modelProviderOptionsByName: OpenAIVideoModelProviderOptionsByName\n  }\n\n  private client: OpenAI_SDK\n\n  constructor(config: OpenAIVideoConfig, model: TModel) {\n    super(config, model)\n    this.client = createOpenAIClient(config)\n  }\n\n  /**\n   * Create a new video generation job.\n   *\n   * API: POST /v1/videos\n   * Docs: https://platform.openai.com/docs/api-reference/videos/create\n   *\n   * @experimental Video generation is an experimental feature and may change.\n   *\n   * @example\n   * ```ts\n   * const { jobId } = await adapter.createVideoJob({\n   *   model: 'sora-2',\n   *   prompt: 'A cat chasing a dog in a sunny park',\n   *   size: '1280x720',\n   *   duration: 8  // seconds: 4, 8, or 12\n   * })\n   * ```\n   */\n  async createVideoJob(\n    options: VideoGenerationOptions<OpenAIVideoProviderOptions>,\n  ): Promise<VideoJobResult> {\n    const { model, size, duration, modelOptions } = options\n\n    // Validate inputs\n    validateVideoSize(model, size)\n    // Duration maps to 'seconds' in the API\n    const seconds = duration ?? modelOptions?.seconds\n    validateVideoSeconds(model, seconds)\n\n    // Build request\n    const request = this.buildRequest(options)\n\n    try {\n      // POST /v1/videos\n      // Cast to any because the videos API may not be in SDK types yet\n      const client = this.client\n      const response = await client.videos.create(request)\n\n      return {\n        jobId: response.id,\n        model,\n      }\n    } catch (error: any) {\n      // Fallback for when the videos API is not available\n      if (error?.message?.includes('videos') || error?.code === 'invalid_api') {\n        throw new Error(\n          `Video generation API is not available. The Sora API may require special access. ` +\n            `Original error: ${error.message}`,\n        )\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get the current status of a video generation job.\n   *\n   * API: GET /v1/videos/{video_id}\n   * Docs: https://platform.openai.com/docs/api-reference/videos/get\n   *\n   * @experimental Video generation is an experimental feature and may change.\n   *\n   * @example\n   * ```ts\n   * const status = await adapter.getVideoStatus(jobId)\n   * if (status.status === 'completed') {\n   *   console.log('Video is ready!')\n   * } else if (status.status === 'processing') {\n   *   console.log(`Progress: ${status.progress}%`)\n   * }\n   * ```\n   */\n  async getVideoStatus(jobId: string): Promise<VideoStatusResult> {\n    try {\n      // GET /v1/videos/{video_id}\n      const client = this.client\n      const response = await client.videos.retrieve(jobId)\n\n      return {\n        jobId,\n        status: this.mapStatus(response.status),\n        progress: response.progress,\n        error: response.error?.message,\n      }\n    } catch (error: any) {\n      if (error.status === 404) {\n        return {\n          jobId,\n          status: 'failed',\n          error: 'Job not found',\n        }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get the URL to download/view the generated video.\n   *\n   * API: GET /v1/videos/{video_id}/content\n   * Docs: https://platform.openai.com/docs/api-reference/videos/content\n   *\n   * @experimental Video generation is an experimental feature and may change.\n   *\n   * @example\n   * ```ts\n   * const { url, expiresAt } = await adapter.getVideoUrl(jobId)\n   * console.log('Video URL:', url)\n   * console.log('Expires at:', expiresAt)\n   * ```\n   */\n  async getVideoUrl(jobId: string): Promise<VideoUrlResult> {\n    try {\n      // GET /v1/videos/{video_id}/content\n      // The SDK may not have a .content() method, so we try multiple approaches\n      const client = this.client as any\n\n      let response: any\n\n      // Try different possible method names\n      if (typeof client.videos?.content === 'function') {\n        response = await client.videos.content(jobId)\n      } else if (typeof client.videos?.getContent === 'function') {\n        response = await client.videos.getContent(jobId)\n      } else if (typeof client.videos?.download === 'function') {\n        response = await client.videos.download(jobId)\n      } else {\n        // Fallback: check if retrieve returns the URL directly\n        const videoInfo = await client.videos.retrieve(jobId)\n        if (videoInfo.url) {\n          return {\n            jobId,\n            url: videoInfo.url,\n            expiresAt: videoInfo.expires_at\n              ? new Date(videoInfo.expires_at)\n              : undefined,\n          }\n        }\n\n        // Last resort: The /content endpoint returns raw binary video data, not JSON.\n        // We need to construct a URL that the client can use to fetch the video.\n        // The URL needs to include auth, so we'll create a signed URL or return\n        // a proxy endpoint.\n\n        // For now, return a URL that goes through our API to proxy the request\n        // since the raw endpoint requires auth headers that browsers can't send.\n        // The video element can't add Authorization headers, so we need a workaround.\n\n        // Option 1: Return the direct URL (only works if OpenAI supports query param auth)\n        // Option 2: Return a blob URL after fetching (memory intensive)\n        // Option 3: Return a proxy URL through our server\n\n        // Let's try fetching and returning a data URL for now\n        const baseUrl = this.config.baseUrl || 'https://api.openai.com/v1'\n        const apiKey = this.config.apiKey\n\n        const contentResponse = await fetch(\n          `${baseUrl}/videos/${jobId}/content`,\n          {\n            method: 'GET',\n            headers: {\n              Authorization: `Bearer ${apiKey}`,\n            },\n          },\n        )\n\n        if (!contentResponse.ok) {\n          // Try to parse error as JSON, but it might be binary\n          const contentType = contentResponse.headers.get('content-type')\n          if (contentType?.includes('application/json')) {\n            const errorData = await contentResponse.json().catch(() => ({}))\n            throw new Error(\n              errorData.error?.message ||\n                `Failed to get video content: ${contentResponse.status}`,\n            )\n          }\n          throw new Error(\n            `Failed to get video content: ${contentResponse.status}`,\n          )\n        }\n\n        // The response is the raw video file - convert to base64 data URL\n        const videoBlob = await contentResponse.blob()\n        const buffer = await videoBlob.arrayBuffer()\n        const base64 = Buffer.from(buffer).toString('base64')\n        const mimeType =\n          contentResponse.headers.get('content-type') || 'video/mp4'\n\n        return {\n          jobId,\n          url: `data:${mimeType};base64,${base64}`,\n          expiresAt: undefined, // Data URLs don't expire\n        }\n      }\n\n      return {\n        jobId,\n        url: response.url,\n        expiresAt: response.expires_at\n          ? new Date(response.expires_at)\n          : undefined,\n      }\n    } catch (error: any) {\n      if (error.status === 404) {\n        throw new Error(`Video job not found: ${jobId}`)\n      }\n      if (error.status === 400) {\n        throw new Error(\n          `Video is not ready for download. Check status first. Job ID: ${jobId}`,\n        )\n      }\n      throw error\n    }\n  }\n\n  private buildRequest(\n    options: VideoGenerationOptions<OpenAIVideoProviderOptions>,\n  ): OpenAI_SDK.Videos.VideoCreateParams {\n    const { model, prompt, size, duration, modelOptions } = options\n\n    const request: OpenAI_SDK.Videos.VideoCreateParams = {\n      model: model as VideoModel,\n      prompt,\n    }\n\n    // Add size/resolution\n    // Supported: '1280x720', '720x1280', '1792x1024', '1024x1792'\n    if (size) {\n      request.size = size as OpenAI_SDK.Videos.VideoCreateParams['size']\n    } else if (modelOptions?.size) {\n      request.size = modelOptions.size\n    }\n\n    // Add seconds (duration)\n    // Supported: '4', '8', or '12' - yes, the API wants strings\n    const seconds = duration ?? modelOptions?.seconds\n    if (seconds !== undefined) {\n      request.seconds = toApiSeconds(seconds)\n    }\n\n    return request\n  }\n\n  private mapStatus(\n    apiStatus: string,\n  ): 'pending' | 'processing' | 'completed' | 'failed' {\n    switch (apiStatus) {\n      case 'queued':\n      case 'pending':\n        return 'pending'\n      case 'processing':\n      case 'in_progress':\n        return 'processing'\n      case 'completed':\n      case 'succeeded':\n        return 'completed'\n      case 'failed':\n      case 'error':\n      case 'cancelled':\n        return 'failed'\n      default:\n        return 'processing'\n    }\n  }\n}\n\n/**\n * Creates an OpenAI video adapter with an explicit API key.\n * Type resolution happens here at the call site.\n *\n * @experimental Video generation is an experimental feature and may change.\n *\n * @param model - The model name (e.g., 'sora-2')\n * @param apiKey - Your OpenAI API key\n * @param config - Optional additional configuration\n * @returns Configured OpenAI video adapter instance with resolved types\n *\n * @example\n * ```typescript\n * const adapter = createOpenaiVideo('sora-2', 'your-api-key');\n *\n * const { jobId } = await generateVideo({\n *   adapter,\n *   prompt: 'A beautiful sunset over the ocean'\n * });\n * ```\n */\nexport function createOpenaiVideo<TModel extends OpenAIVideoModel>(\n  model: TModel,\n  apiKey: string,\n  config?: Omit<OpenAIVideoConfig, 'apiKey'>,\n): OpenAIVideoAdapter<TModel> {\n  return new OpenAIVideoAdapter({ apiKey, ...config }, model)\n}\n\n/**\n * Creates an OpenAI video adapter with automatic API key detection from environment variables.\n * Type resolution happens here at the call site.\n *\n * Looks for `OPENAI_API_KEY` in:\n * - `process.env` (Node.js)\n * - `window.env` (Browser with injected env)\n *\n * @experimental Video generation is an experimental feature and may change.\n *\n * @param model - The model name (e.g., 'sora-2')\n * @param config - Optional configuration (excluding apiKey which is auto-detected)\n * @returns Configured OpenAI video adapter instance with resolved types\n * @throws Error if OPENAI_API_KEY is not found in environment\n *\n * @example\n * ```typescript\n * // Automatically uses OPENAI_API_KEY from environment\n * const adapter = openaiVideo('sora-2');\n *\n * // Create a video generation job\n * const { jobId } = await generateVideo({\n *   adapter,\n *   prompt: 'A cat playing piano'\n * });\n *\n * // Poll for status\n * const status = await getVideoJobStatus({\n *   adapter,\n *   jobId\n * });\n * ```\n */\nexport function openaiVideo<TModel extends OpenAIVideoModel>(\n  model: TModel,\n  config?: Omit<OpenAIVideoConfig, 'apiKey'>,\n): OpenAIVideoAdapter<TModel> {\n  const apiKey = getOpenAIApiKeyFromEnv()\n  return createOpenaiVideo(model, apiKey, config)\n}\n"],"names":[],"mappings":"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"}