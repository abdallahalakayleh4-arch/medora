import { BaseImageAdapter } from "@tanstack/ai/adapters";
import { createGeminiClient, generateId, getGeminiApiKeyFromEnv } from "../utils/client.js";
import { validatePrompt, validateImageSize, validateNumberOfImages, sizeToAspectRatio } from "../image/image-provider-options.js";
class GeminiImageAdapter extends BaseImageAdapter {
  constructor(config, model) {
    super({}, model);
    this.kind = "image";
    this.name = "gemini";
    this.client = createGeminiClient(config);
  }
  async generateImages(options) {
    const { model, prompt, numberOfImages, size } = options;
    validatePrompt({ prompt, model });
    validateImageSize(model, size);
    validateNumberOfImages(model, numberOfImages);
    const config = this.buildConfig(options);
    const response = await this.client.models.generateImages({
      model,
      prompt,
      config
    });
    return this.transformResponse(model, response);
  }
  buildConfig(options) {
    const { size, numberOfImages, modelOptions } = options;
    return {
      numberOfImages: numberOfImages ?? 1,
      // Map size to aspect ratio if provided (modelOptions.aspectRatio will override)
      aspectRatio: size ? sizeToAspectRatio(size) : void 0,
      ...modelOptions
    };
  }
  transformResponse(model, response) {
    const images = (response.generatedImages ?? []).map(
      (item) => ({
        b64Json: item.image?.imageBytes,
        revisedPrompt: item.enhancedPrompt
      })
    );
    return {
      id: generateId(this.name),
      model,
      images,
      usage: void 0
    };
  }
}
function createGeminiImage(model, apiKey, config) {
  return new GeminiImageAdapter({ apiKey, ...config }, model);
}
function geminiImage(model, config) {
  const apiKey = getGeminiApiKeyFromEnv();
  return createGeminiImage(model, apiKey, config);
}
export {
  GeminiImageAdapter,
  createGeminiImage,
  geminiImage
};
//# sourceMappingURL=image.js.map
