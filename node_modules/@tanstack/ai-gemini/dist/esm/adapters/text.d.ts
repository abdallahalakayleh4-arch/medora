import { BaseTextAdapter, StructuredOutputOptions, StructuredOutputResult } from '@tanstack/ai/adapters';
import { GEMINI_MODELS, GeminiChatModelProviderOptionsByName, GeminiModelInputModalitiesByName } from '../model-meta.js';
import { Modality, StreamChunk, TextOptions } from '@tanstack/ai';
import { ExternalTextProviderOptions } from '../text/text-provider-options.js';
import { GeminiMessageMetadataByModality } from '../message-types.js';
import { GeminiClientConfig } from '../utils.js';
/**
 * Configuration for Gemini text adapter
 */
export interface GeminiTextConfig extends GeminiClientConfig {
}
/**
 * Gemini-specific provider options for text/chat
 */
export type GeminiTextProviderOptions = ExternalTextProviderOptions;
/**
 * Resolve provider options for a specific model.
 * If the model has explicit options in the map, use those; otherwise use base options.
 */
type ResolveProviderOptions<TModel extends string> = TModel extends keyof GeminiChatModelProviderOptionsByName ? GeminiChatModelProviderOptionsByName[TModel] : GeminiTextProviderOptions;
/**
 * Resolve input modalities for a specific model.
 * If the model has explicit modalities in the map, use those; otherwise use all modalities.
 */
type ResolveInputModalities<TModel extends string> = TModel extends keyof GeminiModelInputModalitiesByName ? GeminiModelInputModalitiesByName[TModel] : readonly ['text', 'image', 'audio', 'video', 'document'];
/**
 * Gemini Text (Chat) Adapter
 *
 * Tree-shakeable adapter for Gemini chat/text completion functionality.
 * Import only what you need for smaller bundle sizes.
 */
export declare class GeminiTextAdapter<TModel extends (typeof GEMINI_MODELS)[number], TProviderOptions extends object = ResolveProviderOptions<TModel>, TInputModalities extends ReadonlyArray<Modality> = ResolveInputModalities<TModel>> extends BaseTextAdapter<TModel, TProviderOptions, TInputModalities, GeminiMessageMetadataByModality> {
    readonly kind: "text";
    readonly name: "gemini";
    private client;
    constructor(config: GeminiTextConfig, model: TModel);
    chatStream(options: TextOptions<GeminiTextProviderOptions>): AsyncIterable<StreamChunk>;
    /**
     * Generate structured output using Gemini's native JSON response format.
     * Uses responseMimeType: 'application/json' and responseSchema for structured output.
     * The outputSchema is already JSON Schema (converted in the ai layer).
     */
    structuredOutput(options: StructuredOutputOptions<GeminiTextProviderOptions>): Promise<StructuredOutputResult<unknown>>;
    /**
     * Extract text content from a non-streaming response
     */
    private extractTextFromResponse;
    private processStreamChunks;
    private convertContentPartToGemini;
    private formatMessages;
    /**
     * Merge consecutive messages of the same role into a single message.
     * Gemini's API requires strictly alternating user/model roles.
     * Tool results are mapped to role:'user', which can collide with actual
     * user messages in multi-turn conversations.
     *
     * Also filters out empty model messages (e.g., from a previous failed request)
     * and deduplicates functionResponse parts with the same name (tool call ID).
     */
    private mergeConsecutiveSameRoleMessages;
    private mapCommonOptionsToGemini;
}
/**
 * Creates a Gemini text adapter with explicit API key.
 * Type resolution happens here at the call site.
 */
export declare function createGeminiChat<TModel extends (typeof GEMINI_MODELS)[number]>(model: TModel, apiKey: string, config?: Omit<GeminiTextConfig, 'apiKey'>): GeminiTextAdapter<TModel, ResolveProviderOptions<TModel>, ResolveInputModalities<TModel>>;
/**
 * Creates a Gemini text adapter with automatic API key detection.
 * Type resolution happens here at the call site.
 */
export declare function geminiText<TModel extends (typeof GEMINI_MODELS)[number]>(model: TModel, config?: Omit<GeminiTextConfig, 'apiKey'>): GeminiTextAdapter<TModel, ResolveProviderOptions<TModel>, ResolveInputModalities<TModel>>;
export {};
