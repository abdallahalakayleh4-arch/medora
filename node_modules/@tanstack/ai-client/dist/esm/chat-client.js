import { StreamProcessor, normalizeToUIMessage, generateMessageId } from "@tanstack/ai";
import { DefaultChatClientEventEmitter } from "./events.js";
class ChatClient {
  constructor(options) {
    this.body = {};
    this.pendingMessageBody = void 0;
    this.isLoading = false;
    this.error = void 0;
    this.status = "ready";
    this.abortController = null;
    this.currentStreamId = null;
    this.currentMessageId = null;
    this.postStreamActions = [];
    this.pendingToolExecutions = /* @__PURE__ */ new Map();
    this.continuationPending = false;
    this.uniqueId = options.id || this.generateUniqueId("chat");
    this.body = options.body || {};
    this.connection = options.connection;
    this.events = new DefaultChatClientEventEmitter(this.uniqueId);
    this.clientToolsRef = { current: /* @__PURE__ */ new Map() };
    if (options.tools) {
      for (const tool of options.tools) {
        this.clientToolsRef.current.set(tool.name, tool);
      }
    }
    this.callbacksRef = {
      current: {
        onResponse: options.onResponse || (() => {
        }),
        onChunk: options.onChunk || (() => {
        }),
        onFinish: options.onFinish || (() => {
        }),
        onError: options.onError || (() => {
        }),
        onMessagesChange: options.onMessagesChange || (() => {
        }),
        onLoadingChange: options.onLoadingChange || (() => {
        }),
        onErrorChange: options.onErrorChange || (() => {
        }),
        onStatusChange: options.onStatusChange || (() => {
        })
      }
    };
    this.processor = new StreamProcessor({
      chunkStrategy: options.streamProcessor?.chunkStrategy,
      initialMessages: options.initialMessages,
      events: {
        onMessagesChange: (messages) => {
          this.callbacksRef.current.onMessagesChange(messages);
        },
        onStreamStart: () => {
          this.setStatus("streaming");
        },
        onStreamEnd: (message) => {
          this.callbacksRef.current.onFinish(message);
          this.setStatus("ready");
        },
        onError: (error) => {
          this.setError(error);
          this.setStatus("error");
          this.callbacksRef.current.onError(error);
        },
        onTextUpdate: (messageId, content) => {
          if (this.currentStreamId) {
            this.events.textUpdated(this.currentStreamId, messageId, content);
          }
        },
        onThinkingUpdate: (messageId, content) => {
          if (this.currentStreamId) {
            this.events.thinkingUpdated(
              this.currentStreamId,
              messageId,
              content
            );
          }
        },
        onToolCallStateChange: (messageId, toolCallId, state, args) => {
          const messages = this.processor.getMessages();
          const message = messages.find((m) => m.id === messageId);
          const toolCallPart = message?.parts.find(
            (p) => p.type === "tool-call" && p.id === toolCallId
          );
          const toolName = toolCallPart?.name || "unknown";
          if (this.currentStreamId) {
            this.events.toolCallStateChanged(
              this.currentStreamId,
              messageId,
              toolCallId,
              toolName,
              state,
              args
            );
          }
        },
        onToolCall: (args) => {
          const clientTool = this.clientToolsRef.current.get(args.toolName);
          const executeFunc = clientTool?.execute;
          if (executeFunc) {
            const executionPromise = (async () => {
              try {
                const output = await executeFunc(args.input);
                await this.addToolResult({
                  toolCallId: args.toolCallId,
                  tool: args.toolName,
                  output,
                  state: "output-available"
                });
              } catch (error) {
                await this.addToolResult({
                  toolCallId: args.toolCallId,
                  tool: args.toolName,
                  output: null,
                  state: "output-error",
                  errorText: error.message
                });
              } finally {
                this.pendingToolExecutions.delete(args.toolCallId);
              }
            })();
            this.pendingToolExecutions.set(args.toolCallId, executionPromise);
          }
        },
        onApprovalRequest: (args) => {
          if (this.currentStreamId) {
            this.events.approvalRequested(
              this.currentStreamId,
              this.currentMessageId || "",
              args.toolCallId,
              args.toolName,
              args.input,
              args.approvalId
            );
          }
        }
      }
    });
    this.events.clientCreated(this.processor.getMessages().length);
  }
  generateUniqueId(prefix) {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substring(7)}`;
  }
  setIsLoading(isLoading) {
    this.isLoading = isLoading;
    this.callbacksRef.current.onLoadingChange(isLoading);
    this.events.loadingChanged(isLoading);
  }
  setStatus(status) {
    this.status = status;
    this.callbacksRef.current.onStatusChange(status);
  }
  setError(error) {
    this.error = error;
    this.callbacksRef.current.onErrorChange(error);
    this.events.errorChanged(error?.message || null);
  }
  /**
   * Process a stream through the StreamProcessor
   */
  async processStream(source) {
    this.currentStreamId = this.generateUniqueId("stream");
    this.processor.prepareAssistantMessage();
    for await (const chunk of source) {
      this.callbacksRef.current.onChunk(chunk);
      this.processor.processChunk(chunk);
      if (!this.currentMessageId) {
        const newMessageId = this.processor.getCurrentAssistantMessageId() ?? null;
        if (newMessageId) {
          this.currentMessageId = newMessageId;
          const assistantMessage = this.processor.getMessages().find((m) => m.id === newMessageId);
          if (assistantMessage) {
            this.events.messageAppended(
              assistantMessage,
              this.currentStreamId || void 0
            );
          }
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    if (this.pendingToolExecutions.size > 0) {
      await Promise.all(this.pendingToolExecutions.values());
    }
    this.processor.finalizeStream();
    const messageId = this.processor.getCurrentAssistantMessageId();
    this.currentStreamId = null;
    this.currentMessageId = null;
    if (messageId) {
      const messages = this.processor.getMessages();
      return messages.find((m) => m.id === messageId) || null;
    }
    return null;
  }
  /**
   * Send a message and stream the response.
   * Supports both simple string content and multimodal content (images, audio, video, documents).
   *
   * @param content - The message content. Can be:
   *   - A simple string for text-only messages
   *   - A MultimodalContent object with content array and optional custom ID
   * @param body - Optional body parameters to merge with the client's base body for this request.
   *               Uses shallow merge with per-message body taking priority.
   *
   * @example
   * ```ts
   * // Simple text message
   * await client.sendMessage('Hello!')
   *
   * // Text message with custom body params
   * await client.sendMessage('Hello!', { temperature: 0.7 })
   *
   * // Multimodal message with image
   * await client.sendMessage({
   *   content: [
   *     { type: 'text', content: 'What is in this image?' },
   *     { type: 'image', source: { type: 'url', value: 'https://example.com/photo.jpg' } }
   *   ]
   * })
   *
   * // Multimodal message with custom ID and body params
   * await client.sendMessage(
   *   {
   *     content: [
   *       { type: 'text', content: 'Describe this audio' },
   *       { type: 'audio', source: { type: 'data', value: 'base64...' } }
   *     ],
   *     id: 'custom-message-id'
   *   },
   *   { model: 'gpt-4-audio' }
   * )
   * ```
   */
  async sendMessage(content, body) {
    const emptyMessage = typeof content === "string" && !content.trim();
    if (emptyMessage || this.isLoading) {
      return;
    }
    const normalizedContent = this.normalizeMessageInput(content);
    this.pendingMessageBody = body;
    const userMessage = this.processor.addUserMessage(
      normalizedContent.content,
      normalizedContent.id
    );
    this.events.messageSent(userMessage.id, normalizedContent.content);
    await this.streamResponse();
  }
  /**
   * Normalize the message input to extract content and optional id.
   * Trims string content automatically.
   */
  normalizeMessageInput(input) {
    if (typeof input === "string") {
      return { content: input.trim() };
    }
    return { content: input.content, id: input.id };
  }
  /**
   * Append a message and stream the response
   */
  async append(message) {
    const normalizedMessage = normalizeToUIMessage(message, generateMessageId);
    if (normalizedMessage.role === "system") {
      return;
    }
    const uiMessage = normalizedMessage;
    this.events.messageAppended(uiMessage);
    const messages = this.processor.getMessages();
    this.processor.setMessages([...messages, uiMessage]);
    if (this.isLoading) {
      this.queuePostStreamAction(() => this.streamResponse());
      return;
    }
    await this.streamResponse();
  }
  /**
   * Stream a response from the LLM
   */
  async streamResponse() {
    if (this.isLoading) {
      return;
    }
    this.setIsLoading(true);
    this.setStatus("submitted");
    this.setError(void 0);
    this.abortController = new AbortController();
    this.pendingToolExecutions.clear();
    let streamCompletedSuccessfully = false;
    try {
      const messages = this.processor.getMessages();
      await this.callbacksRef.current.onResponse();
      const mergedBody = {
        ...this.body,
        ...this.pendingMessageBody,
        conversationId: this.uniqueId
      };
      this.pendingMessageBody = void 0;
      const stream = this.connection.connect(
        messages,
        mergedBody,
        this.abortController.signal
      );
      await this.processStream(stream);
      streamCompletedSuccessfully = true;
    } catch (err) {
      if (err instanceof Error) {
        if (err.name === "AbortError") {
          return;
        }
        this.setError(err);
        this.setStatus("error");
        this.callbacksRef.current.onError(err);
      }
    } finally {
      this.abortController = null;
      this.setIsLoading(false);
      this.pendingMessageBody = void 0;
      await this.drainPostStreamActions();
      if (streamCompletedSuccessfully) {
        const messages = this.processor.getMessages();
        const lastPart = messages.at(-1)?.parts.at(-1);
        if (lastPart?.type === "tool-result" && this.shouldAutoSend()) {
          try {
            await this.checkForContinuation();
          } catch (error) {
            console.error("Failed to continue flow after tool result:", error);
          }
        }
      }
    }
  }
  /**
   * Reload the last assistant message
   */
  async reload() {
    const messages = this.processor.getMessages();
    if (messages.length === 0) return;
    const lastUserMessageIndex = messages.findLastIndex(
      (m) => m.role === "user"
    );
    if (lastUserMessageIndex === -1) return;
    this.events.reloaded(lastUserMessageIndex);
    this.processor.removeMessagesAfter(lastUserMessageIndex);
    await this.streamResponse();
  }
  /**
   * Stop the current stream
   */
  stop() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.setIsLoading(false);
    this.setStatus("ready");
    this.events.stopped();
  }
  /**
   * Clear all messages
   */
  clear() {
    this.processor.clearMessages();
    this.setError(void 0);
    this.events.messagesCleared();
  }
  /**
   * Add the result of a client-side tool execution
   */
  async addToolResult(result) {
    this.events.toolResultAdded(
      result.toolCallId,
      result.tool,
      result.output,
      result.state || "output-available"
    );
    this.processor.addToolResult(
      result.toolCallId,
      result.output,
      result.errorText
    );
    if (this.isLoading) {
      this.queuePostStreamAction(() => this.checkForContinuation());
      return;
    }
    await this.checkForContinuation();
  }
  /**
   * Respond to a tool approval request
   */
  async addToolApprovalResponse(response) {
    const messages = this.processor.getMessages();
    let foundToolCallId;
    for (const msg of messages) {
      const toolCallPart = msg.parts.find(
        (p) => p.type === "tool-call" && p.approval?.id === response.id
      );
      if (toolCallPart) {
        foundToolCallId = toolCallPart.id;
        break;
      }
    }
    if (foundToolCallId) {
      this.events.toolApprovalResponded(
        response.id,
        foundToolCallId,
        response.approved
      );
    }
    this.processor.addToolApprovalResponse(response.id, response.approved);
    if (this.isLoading) {
      this.queuePostStreamAction(() => this.checkForContinuation());
      return;
    }
    await this.checkForContinuation();
  }
  /**
   * Queue an action to be executed after the current stream ends
   */
  queuePostStreamAction(action) {
    this.postStreamActions.push(action);
  }
  /**
   * Drain and execute all queued post-stream actions
   */
  async drainPostStreamActions() {
    while (this.postStreamActions.length > 0) {
      const action = this.postStreamActions.shift();
      await action();
    }
  }
  /**
   * Check if we should continue the flow and do so if needed
   */
  async checkForContinuation() {
    if (this.continuationPending || this.isLoading) {
      return;
    }
    if (this.shouldAutoSend()) {
      this.continuationPending = true;
      try {
        await this.streamResponse();
      } finally {
        this.continuationPending = false;
      }
    }
  }
  /**
   * Check if all tool calls are complete and we should auto-send
   */
  shouldAutoSend() {
    return this.processor.areAllToolsComplete();
  }
  /**
   * Get current messages
   */
  getMessages() {
    return this.processor.getMessages();
  }
  /**
   * Get loading state
   */
  getIsLoading() {
    return this.isLoading;
  }
  /**
   * Get current status
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get current error
   */
  getError() {
    return this.error;
  }
  /**
   * Manually set messages
   */
  setMessagesManually(messages) {
    this.processor.setMessages(messages);
  }
  /**
   * Update options refs (for use in React hooks to avoid recreating client)
   */
  updateOptions(options) {
    if (options.connection !== void 0) {
      this.connection = options.connection;
    }
    if (options.body !== void 0) {
      this.body = options.body;
    }
    if (options.tools !== void 0) {
      this.clientToolsRef.current = /* @__PURE__ */ new Map();
      for (const tool of options.tools) {
        this.clientToolsRef.current.set(tool.name, tool);
      }
    }
    if (options.onResponse !== void 0) {
      this.callbacksRef.current.onResponse = options.onResponse;
    }
    if (options.onChunk !== void 0) {
      this.callbacksRef.current.onChunk = options.onChunk;
    }
    if (options.onFinish !== void 0) {
      this.callbacksRef.current.onFinish = options.onFinish;
    }
    if (options.onError !== void 0) {
      this.callbacksRef.current.onError = options.onError;
    }
  }
}
export {
  ChatClient
};
//# sourceMappingURL=chat-client.js.map
