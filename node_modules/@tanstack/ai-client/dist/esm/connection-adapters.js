function mergeHeaders(customHeaders) {
  if (!customHeaders) {
    return {};
  }
  if (customHeaders instanceof Headers) {
    const result = {};
    customHeaders.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  return customHeaders;
}
async function* readStreamLines(reader, abortSignal) {
  try {
    const decoder = new TextDecoder();
    let buffer = "";
    while (true) {
      if (abortSignal?.aborted) {
        break;
      }
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        if (line.trim()) {
          yield line;
        }
      }
    }
    if (buffer.trim()) {
      yield buffer;
    }
  } finally {
    reader.releaseLock();
  }
}
function fetchServerSentEvents(url, options = {}) {
  return {
    async *connect(messages, data, abortSignal) {
      const resolvedUrl = typeof url === "function" ? url() : url;
      const resolvedOptions = typeof options === "function" ? await options() : options;
      const requestHeaders = {
        "Content-Type": "application/json",
        ...mergeHeaders(resolvedOptions.headers)
      };
      const requestBody = {
        messages,
        data,
        ...resolvedOptions.body
      };
      const fetchClient = resolvedOptions.fetchClient ?? fetch;
      const response = await fetchClient(resolvedUrl, {
        method: "POST",
        headers: requestHeaders,
        body: JSON.stringify(requestBody),
        credentials: resolvedOptions.credentials || "same-origin",
        signal: abortSignal || resolvedOptions.signal
      });
      if (!response.ok) {
        throw new Error(
          `HTTP error! status: ${response.status} ${response.statusText}`
        );
      }
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("Response body is not readable");
      }
      for await (const line of readStreamLines(reader, abortSignal)) {
        const data2 = line.startsWith("data: ") ? line.slice(6) : line;
        if (data2 === "[DONE]") continue;
        try {
          const parsed = JSON.parse(data2);
          yield parsed;
        } catch (parseError) {
          console.warn("Failed to parse SSE chunk:", data2);
        }
      }
    }
  };
}
function fetchHttpStream(url, options = {}) {
  return {
    async *connect(messages, data, abortSignal) {
      const resolvedUrl = typeof url === "function" ? url() : url;
      const resolvedOptions = typeof options === "function" ? await options() : options;
      const requestHeaders = {
        "Content-Type": "application/json",
        ...mergeHeaders(resolvedOptions.headers)
      };
      const requestBody = {
        messages,
        data,
        ...resolvedOptions.body
      };
      const fetchClient = resolvedOptions.fetchClient ?? fetch;
      const response = await fetchClient(resolvedUrl, {
        method: "POST",
        headers: requestHeaders,
        body: JSON.stringify(requestBody),
        credentials: resolvedOptions.credentials || "same-origin",
        signal: abortSignal || resolvedOptions.signal
      });
      if (!response.ok) {
        throw new Error(
          `HTTP error! status: ${response.status} ${response.statusText}`
        );
      }
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("Response body is not readable");
      }
      for await (const line of readStreamLines(reader, abortSignal)) {
        try {
          const parsed = JSON.parse(line);
          yield parsed;
        } catch (parseError) {
          console.warn("Failed to parse HTTP stream chunk:", line);
        }
      }
    }
  };
}
function stream(streamFactory) {
  return {
    async *connect(messages, data) {
      yield* streamFactory(messages, data);
    }
  };
}
function rpcStream(rpcCall) {
  return {
    async *connect(messages, data) {
      yield* rpcCall(messages, data);
    }
  };
}
export {
  fetchHttpStream,
  fetchServerSentEvents,
  rpcStream,
  stream
};
//# sourceMappingURL=connection-adapters.js.map
