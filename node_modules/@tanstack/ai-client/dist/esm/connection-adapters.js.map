{"version":3,"file":"connection-adapters.js","sources":["../../src/connection-adapters.ts"],"sourcesContent":["import type { ModelMessage, StreamChunk, UIMessage } from '@tanstack/ai'\n\n/**\n * Merge custom headers into request headers\n */\nfunction mergeHeaders(\n  customHeaders?: Record<string, string> | Headers,\n): Record<string, string> {\n  if (!customHeaders) {\n    return {}\n  }\n  if (customHeaders instanceof Headers) {\n    const result: Record<string, string> = {}\n    customHeaders.forEach((value, key) => {\n      result[key] = value\n    })\n    return result\n  }\n  return customHeaders\n}\n\n/**\n * Read lines from a stream (newline-delimited)\n */\nasync function* readStreamLines(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  abortSignal?: AbortSignal,\n): AsyncGenerator<string> {\n  try {\n    const decoder = new TextDecoder()\n    let buffer = ''\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n      // Check if aborted before reading\n      if (abortSignal?.aborted) {\n        break\n      }\n\n      const { done, value } = await reader.read()\n      if (done) break\n\n      buffer += decoder.decode(value, { stream: true })\n      const lines = buffer.split('\\n')\n\n      // Keep the last incomplete line in the buffer\n      buffer = lines.pop() || ''\n\n      for (const line of lines) {\n        if (line.trim()) {\n          yield line\n        }\n      }\n    }\n\n    // Process any remaining data in the buffer\n    if (buffer.trim()) {\n      yield buffer\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n\n/**\n * Connection adapter interface - converts a connection into a stream of chunks\n */\nexport interface ConnectionAdapter {\n  /**\n   * Connect and return an async iterable of StreamChunks\n   * @param messages - The messages to send (UIMessages or ModelMessages)\n   * @param data - Additional data to send\n   * @param abortSignal - Optional abort signal for request cancellation\n   */\n  connect: (\n    messages: Array<UIMessage> | Array<ModelMessage>,\n    data?: Record<string, any>,\n    abortSignal?: AbortSignal,\n  ) => AsyncIterable<StreamChunk>\n}\n\n/**\n * Options for fetch-based connection adapters\n */\nexport interface FetchConnectionOptions {\n  headers?: Record<string, string> | Headers\n  credentials?: RequestCredentials\n  signal?: AbortSignal\n  body?: Record<string, any>\n  fetchClient?: typeof globalThis.fetch\n}\n\n/**\n * Create a Server-Sent Events connection adapter\n *\n * @param url - The API endpoint URL (or a function that returns the URL)\n * @param options - Fetch options (headers, credentials, body, etc.) or a function that returns options (can be async)\n * @returns A connection adapter for SSE streams\n *\n * @example\n * ```typescript\n * // Static URL\n * const connection = fetchServerSentEvents('/api/chat');\n *\n * // Dynamic URL\n * const connection = fetchServerSentEvents(() => `/api/chat?user=${userId}`);\n *\n * // With options\n * const connection = fetchServerSentEvents('/api/chat', {\n *   headers: { 'Authorization': 'Bearer token' }\n * });\n *\n * // With dynamic options\n * const connection = fetchServerSentEvents('/api/chat', () => ({\n *   headers: { 'Authorization': `Bearer ${getToken()}` }\n * }));\n *\n * // With additional body data\n * const connection = fetchServerSentEvents('/api/chat', async () => ({\n *   body: {\n *     provider: 'openai',\n *     model: 'gpt-4o',\n *   }\n * }));\n * ```\n */\nexport function fetchServerSentEvents(\n  url: string | (() => string),\n  options:\n    | FetchConnectionOptions\n    | (() => FetchConnectionOptions | Promise<FetchConnectionOptions>) = {},\n): ConnectionAdapter {\n  return {\n    async *connect(messages, data, abortSignal) {\n      // Resolve URL and options if they are functions\n      const resolvedUrl = typeof url === 'function' ? url() : url\n      const resolvedOptions =\n        typeof options === 'function' ? await options() : options\n\n      const requestHeaders: Record<string, string> = {\n        'Content-Type': 'application/json',\n        ...mergeHeaders(resolvedOptions.headers),\n      }\n\n      // Send messages as-is (UIMessages with parts preserved)\n      // Server-side TextEngine handles conversion to ModelMessages\n      const requestBody = {\n        messages,\n        data,\n        ...resolvedOptions.body,\n      }\n\n      const fetchClient = resolvedOptions.fetchClient ?? fetch\n      const response = await fetchClient(resolvedUrl, {\n        method: 'POST',\n        headers: requestHeaders,\n        body: JSON.stringify(requestBody),\n        credentials: resolvedOptions.credentials || 'same-origin',\n        signal: abortSignal || resolvedOptions.signal,\n      })\n\n      if (!response.ok) {\n        throw new Error(\n          `HTTP error! status: ${response.status} ${response.statusText}`,\n        )\n      }\n\n      // Parse Server-Sent Events format\n      const reader = response.body?.getReader()\n      if (!reader) {\n        throw new Error('Response body is not readable')\n      }\n\n      for await (const line of readStreamLines(reader, abortSignal)) {\n        // Handle Server-Sent Events format\n        const data = line.startsWith('data: ') ? line.slice(6) : line\n\n        if (data === '[DONE]') continue\n\n        try {\n          const parsed: StreamChunk = JSON.parse(data)\n          yield parsed\n        } catch (parseError) {\n          // Skip non-JSON lines or malformed chunks\n          console.warn('Failed to parse SSE chunk:', data)\n        }\n      }\n    },\n  }\n}\n\n/**\n * Create an HTTP streaming connection adapter (for raw streaming without SSE format)\n *\n * @param url - The API endpoint URL (or a function that returns the URL)\n * @param options - Fetch options (headers, credentials, body, etc.) or a function that returns options (can be async)\n * @returns A connection adapter for HTTP streams\n *\n * @example\n * ```typescript\n * // Static URL\n * const connection = fetchHttpStream('/api/chat');\n *\n * // Dynamic URL\n * const connection = fetchHttpStream(() => `/api/chat?user=${userId}`);\n *\n * // With options\n * const connection = fetchHttpStream('/api/chat', {\n *   headers: { 'Authorization': 'Bearer token' }\n * });\n *\n * // With dynamic options\n * const connection = fetchHttpStream('/api/chat', () => ({\n *   headers: { 'Authorization': `Bearer ${getToken()}` }\n * }));\n *\n * // With additional body data\n * const connection = fetchHttpStream('/api/chat', async () => ({\n *   body: {\n *     provider: 'openai',\n *     model: 'gpt-4o',\n *   }\n * }));\n * ```\n */\nexport function fetchHttpStream(\n  url: string | (() => string),\n  options:\n    | FetchConnectionOptions\n    | (() => FetchConnectionOptions | Promise<FetchConnectionOptions>) = {},\n): ConnectionAdapter {\n  return {\n    async *connect(messages, data, abortSignal) {\n      // Resolve URL and options if they are functions\n      const resolvedUrl = typeof url === 'function' ? url() : url\n      const resolvedOptions =\n        typeof options === 'function' ? await options() : options\n\n      const requestHeaders: Record<string, string> = {\n        'Content-Type': 'application/json',\n        ...mergeHeaders(resolvedOptions.headers),\n      }\n\n      // Send messages as-is (UIMessages with parts preserved)\n      // Server-side TextEngine handles conversion to ModelMessages\n      const requestBody = {\n        messages,\n        data,\n        ...resolvedOptions.body,\n      }\n\n      const fetchClient = resolvedOptions.fetchClient ?? fetch\n      const response = await fetchClient(resolvedUrl, {\n        method: 'POST',\n        headers: requestHeaders,\n        body: JSON.stringify(requestBody),\n        credentials: resolvedOptions.credentials || 'same-origin',\n        signal: abortSignal || resolvedOptions.signal,\n      })\n\n      if (!response.ok) {\n        throw new Error(\n          `HTTP error! status: ${response.status} ${response.statusText}`,\n        )\n      }\n\n      // Parse raw HTTP stream (newline-delimited JSON)\n      const reader = response.body?.getReader()\n      if (!reader) {\n        throw new Error('Response body is not readable')\n      }\n\n      for await (const line of readStreamLines(reader, abortSignal)) {\n        try {\n          const parsed: StreamChunk = JSON.parse(line)\n          yield parsed\n        } catch (parseError) {\n          console.warn('Failed to parse HTTP stream chunk:', line)\n        }\n      }\n    },\n  }\n}\n\n/**\n * Create a direct stream connection adapter (for server functions or direct streams)\n *\n * @param streamFactory - A function that returns an async iterable of StreamChunks\n * @returns A connection adapter for direct streams\n *\n * @example\n * ```typescript\n * // With TanStack Start server function\n * const connection = stream(() => serverFunction({ messages }));\n *\n * const client = new ChatClient({ connection });\n * ```\n */\nexport function stream(\n  streamFactory: (\n    messages: Array<UIMessage> | Array<ModelMessage>,\n    data?: Record<string, any>,\n  ) => AsyncIterable<StreamChunk>,\n): ConnectionAdapter {\n  return {\n    async *connect(messages, data) {\n      // Pass messages as-is (UIMessages with parts preserved)\n      // Server-side chat() handles conversion to ModelMessages\n      yield* streamFactory(messages, data)\n    },\n  }\n}\n\n/**\n * Create an RPC stream connection adapter (for RPC-based streaming like Cap'n Web RPC)\n *\n * @param rpcCall - A function that accepts messages and returns an async iterable of StreamChunks\n * @returns A connection adapter for RPC streams\n *\n * @example\n * ```typescript\n * // With Cap'n Web RPC\n * const connection = rpcStream((messages, data) =>\n *   api.streamMurfResponse(messages, data)\n * );\n *\n * const client = new ChatClient({ connection });\n * ```\n */\nexport function rpcStream(\n  rpcCall: (\n    messages: Array<UIMessage> | Array<ModelMessage>,\n    data?: Record<string, any>,\n  ) => AsyncIterable<StreamChunk>,\n): ConnectionAdapter {\n  return {\n    async *connect(messages, data) {\n      // Pass messages as-is (UIMessages with parts preserved)\n      // Server-side chat() handles conversion to ModelMessages\n      yield* rpcCall(messages, data)\n    },\n  }\n}\n"],"names":["data"],"mappings":"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"}